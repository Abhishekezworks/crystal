import chalk from "chalk";
import debugFactory from "debug";

import { crystalPrint, crystalPrintPathIdentity } from "./crystalPrint";
import { exportAsMany } from "./exportAs";

debugFactory.formatters.c = crystalPrint;
debugFactory.formatters.p = (pathIdentity) =>
  chalk.bold.yellow(crystalPrintPathIdentity(pathIdentity));

import { Aether, CrystalError } from "./aether";
import { ROOT_PATH } from "./constants";
import { defer, Deferred } from "./deferred";
// Handy for debugging
import { isDev, noop } from "./dev";
import { crystalEnforce } from "./enforceCrystal";
import { getCurrentParentPathIdentity } from "./global";
import {
  InputListPlan,
  InputObjectPlan,
  InputPlan,
  InputStaticLeafPlan,
} from "./input";
import {
  ArgumentPlanResolver,
  BaseGraphQLArguments,
  BaseGraphQLContext,
  BaseGraphQLRootValue,
  BaseGraphQLVariables,
  CrystalResultsList,
  CrystalResultStreamList,
  CrystalSubscriber,
  CrystalValuesList,
  ExecutablePlanResolver,
  GraphileFieldConfig,
  GraphileFieldConfigArgumentMap,
  InputObjectFieldPlanResolver,
  OutputPlanForType,
  PlanOptimizeOptions,
  PlanStreamOptions,
  PolymorphicData,
  PromiseOrDirect,
} from "./interfaces";
import {
  assertListCapablePlan,
  BasePlan,
  ExecutablePlan,
  isExecutablePlan,
  isListCapablePlan,
  isModifierPlan,
  isObjectLikePlan,
  isStreamablePlan,
  ListCapablePlan,
  ModifierPlan,
  ObjectLikePlan,
  PolymorphicPlan,
  StreamablePlan,
} from "./plan";
import {
  __ItemPlan,
  __TrackedObjectPlan,
  __ValuePlan,
  access,
  AccessPlan,
  aether,
  connection,
  ConnectionCapablePlan,
  ConnectionPlan,
  constant,
  ConstantPlan,
  context,
  debugPlans,
  each,
  EachPlan,
  first,
  FirstPlan,
  groupBy,
  lambda,
  LambdaPlan,
  last,
  LastPlan,
  list,
  ListPlan,
  makeMapper,
  map,
  MapPlan,
  object,
  ObjectPlan,
  PageInfoCapablePlan,
  reverse,
  reverseArray,
  ReversePlan,
  subscribe,
  SubscribePlan,
  transform,
} from "./plans";
import { polymorphicWrap, resolveType } from "./polymorphic";
import {
  $$crystalWrapped,
  crystalWrapResolve,
  makeCrystalSubscriber,
} from "./resolvers";
import { stripAnsi } from "./stripAnsi";
import {
  arraysMatch,
  getEnumValueConfig,
  GraphileObjectType,
  inputObjectFieldSpec,
  InputObjectTypeSpec,
  newGraphileFieldConfigBuilder,
  newInputObjectTypeBuilder,
  newObjectTypeBuilder,
  objectFieldSpec,
  objectSpec,
  ObjectTypeSpec,
  planGroupsOverlap,
} from "./utils";

export { isAsyncIterable } from "iterall";

export {
  __ItemPlan,
  __TrackedObjectPlan,
  __ValuePlan,
  $$crystalWrapped,
  access,
  AccessPlan,
  Aether,
  aether,
  ArgumentPlanResolver,
  arraysMatch,
  assertListCapablePlan,
  BaseGraphQLArguments,
  BaseGraphQLContext,
  BaseGraphQLRootValue,
  BaseGraphQLVariables,
  BasePlan,
  connection,
  ConnectionCapablePlan,
  ConnectionPlan,
  constant,
  ConstantPlan,
  context,
  crystalEnforce,
  CrystalError,
  crystalPrint,
  crystalPrintPathIdentity,
  CrystalResultsList,
  CrystalResultStreamList,
  CrystalSubscriber,
  CrystalValuesList,
  crystalWrapResolve,
  debugPlans,
  defer,
  Deferred,
  each,
  EachPlan,
  ExecutablePlan,
  ExecutablePlanResolver,
  first,
  FirstPlan,
  getCurrentParentPathIdentity,
  getEnumValueConfig,
  GraphileFieldConfig,
  GraphileFieldConfigArgumentMap,
  GraphileObjectType,
  groupBy,
  InputListPlan,
  InputObjectFieldPlanResolver,
  inputObjectFieldSpec,
  InputObjectPlan,
  InputObjectTypeSpec,
  InputPlan,
  InputStaticLeafPlan,
  isDev,
  isExecutablePlan,
  isListCapablePlan,
  isModifierPlan,
  isObjectLikePlan,
  isStreamablePlan,
  lambda,
  LambdaPlan,
  last,
  LastPlan,
  list,
  ListCapablePlan,
  ListPlan,
  makeCrystalSubscriber,
  makeMapper,
  map,
  MapPlan,
  ModifierPlan,
  newGraphileFieldConfigBuilder,
  newInputObjectTypeBuilder,
  newObjectTypeBuilder,
  noop,
  object,
  objectFieldSpec,
  ObjectLikePlan,
  ObjectPlan,
  objectSpec,
  ObjectTypeSpec,
  OutputPlanForType,
  PageInfoCapablePlan,
  planGroupsOverlap,
  PlanOptimizeOptions,
  PlanStreamOptions,
  PolymorphicData,
  PolymorphicPlan,
  polymorphicWrap,
  PromiseOrDirect,
  resolveType,
  reverse,
  reverseArray,
  ReversePlan,
  ROOT_PATH,
  StreamablePlan,
  stripAnsi,
  subscribe,
  SubscribePlan,
  transform,
};

exportAsMany({
  crystalPrint,
  crystalPrintPathIdentity,
  Aether,
  ROOT_PATH,
  defer,
  crystalEnforce,
  InputListPlan,
  InputObjectPlan,
  InputStaticLeafPlan,
  assertListCapablePlan,
  isExecutablePlan,
  isListCapablePlan,
  isModifierPlan,
  isObjectLikePlan,
  isStreamablePlan,
  __ItemPlan,
  __TrackedObjectPlan,
  __ValuePlan,
  access,
  AccessPlan,
  aether,
  connection,
  ConnectionPlan,
  constant,
  ConstantPlan,
  context,
  CrystalError,
  debugPlans,
  each,
  groupBy,
  transform,
  EachPlan,
  first,
  FirstPlan,
  last,
  LastPlan,
  lambda,
  LambdaPlan,
  list,
  ListPlan,
  makeMapper,
  map,
  MapPlan,
  object,
  ObjectPlan,
  reverse,
  reverseArray,
  ReversePlan,
  subscribe,
  SubscribePlan,
  polymorphicWrap,
  resolveType,
  $$crystalWrapped,
  crystalWrapResolve,
  makeCrystalSubscriber,
  stripAnsi,
  arraysMatch,
  inputObjectFieldSpec,
  newGraphileFieldConfigBuilder,
  newInputObjectTypeBuilder,
  newObjectTypeBuilder,
  objectFieldSpec,
  objectSpec,
  planGroupsOverlap,
  isDev,
  noop,
  getCurrentParentPathIdentity,
  getEnumValueConfig,
});
