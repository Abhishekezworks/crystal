---
sidebar_position: 11
---

# Polymorphism

GraphQL has two types of output polymorphism currently: interfaces and unions.
An interface defines a list of fields; all objects that implement the interface
must implement fields compatible with these. A union is a simple list of
possible object types.

Gra*fast* supports both of these forms of GraphQL polymorphism, both through
resolvers and through plans. Resolvers work the same (basically) as they do in
GraphQL.js so we won't dig into them here, but let's look into how Gra*fast*
supports polymorphism via plans.

## Polymorphic positions

Let's define the term "polymorphic position" to make it easier to talk about
planning our polymorphic GraphQL query. Imagine you have a GraphQL schema such
as:

```graphql
interface Animal {
  name: String!
}
type Cat extends Animal {
  name: String!
  numberOfLives: Int!
}
type Dog extends Animal {
  name: String!
  wagsTail: Boolean!
}
type Query {
  bestAnimal: Animal
  randomAnimals: [Animal]
}
```

One query to this schema could be:

```graphql
{
  bestAnimal {
    name
    ... on Cat {
      numberOfLives
    }
    ... on Dog {
      wagsTail
    }
  }
}
```

Here the return type of the `bestAnimal` field is a polymorphic type (`Animal`,
which is an interface), so the return type of `bestAnimal` is a polymorphic
position in this query.

Another query could be:

```graphql
{
  randomAnimals {
    name
    ... on Cat {
      numberOfLives
    }
    ... on Dog {
      wagsTail
    }
  }
}
```

Here the return type of `randomAnimals` is a list (`[Animal]`). A list is not
itself polymorphic, however the type inside the list is a polymorphic type
(`Animal` again), so a polymorphic position in this query is inside the list
returned by `randomAnimals`.

Operations may have any number (0 or higher) of polymorphic positions.

## Caveats

<!-- TODO: update this -->

Highly polymorphic operations may result in very significant planning time,
this is something we're working to optimize but for now we recommend that you
use persisted operations (aka persisted queries) to ensure that only your
developers operations are allowed. Alternatively, use our plugin that validates
that operations don't contain too much polymorphism (TODO: plugin not yet
available).

:::info

Currently Gra*fast* uses a rudimentary strategy where all possible polymorphic
types at each point in the GraphQL operation are planned at planning time. This
is a simple approach, but it can inflate the time spent planning an operation,
especially for highly polymorphic operations where combinatorics is a
significant concern.

At some point, Gra*fast* will add support for on-demand polymorphic planning.
With this strategy, each "polymorphic branch" of the plan will only be planned
the first time that an object of that type is met at runtime. This on-demand
polymorphic planning strategy should significantly decrease initial planning
time for highly polymorphic operations, and may result in many of the paths
never needing to be planned at all!

:::
