---
sidebar_position: 1
---

import Mermaid from '@theme/Mermaid';
import mermaidPlan from '../examples/users-and-friends/plan.mermaid?raw';


# Grafast Introduction

The GraphQL specification describes how a GraphQL operation should be executed,
talking in terms of layer-by-layer resolution of data using "resolvers." But
critical to note is this sentence from the beginning of the specification:

> _Conformance requirements [...] can be fulfilled [...] in any way as long as
> the perceived result is equivalent._  
> â”€ https://spec.graphql.org/draft/#sec-Conforming-Algorithms

Before Gra*fast*, there was only one GraphQL execution engine available in
JavaScript: the GraphQL reference implementation, which we will refer to as
[graphql-js][] from now on. A design goal of graphql-js is to follow the
specification as much as possible, it therefore follows the advice to use
resolvers.

Resolvers are relatively straightforward to understand, but when implemented
naively can very quickly result in serious performance issues. [DataLoader][] is
one of the approaches suggested to solve the "N+1 problem," but this is only the
most egregious performance issue that a naive GraphQL schema may face - there
are other such as server-side over-fetching and under-fetching and related
issues.

Gra*fast* was designed from the ground up to eliminate these issues and more
whilst maintaining pleasant APIs for developers to use. To do this, it eschews
the concept of opaque resolvers, favoring instead a planning strategy that
unlocks the potential for significant optimizations not previously achievable
without hundreds or thousands of lines of custom logic.

## Plans

Grafast plan resolvers are generally straightforward, like regular resolvers
should be, but instead of dealing with concrete runtime values and being called
many times, they are called only once at planning time, and they deal with
"steps" which are placeholders for all possible future values of something.

Imagine that we have this GraphQL schema:

```graphql
type Query {
  currentUser: User
}
type User {
  name: String!
  friends: [User!]!
}
```

And a query such as:

```graphql
{
  currentUser {
    name
    friends {
      name
      friends {
        name
      }
    }
  }
}
```

In graphql-js, you might have these resolvers:

```ts
const resolvers = {
  Query: {
    async currentUser(_, args, context) {
      return context.userLoader.load(context.currentUserId);
    },
  },
  User: {
    name(user) {
      return user.full_name;
    },
    async friends(user, args, context) {
      const friendships = await context.friendshipsByUserIdLoader.load(user.id);
      return Promise.all(
        friendships.map((id) => context.userLoader.load(friendship.friendId)),
      );
    },
  },
};
```

In Grafast, we use "plan resolvers" instead, which might look something like:

```ts
const planResolvers = {
  Query: {
    currentUser() {
      return userById(context().get("currentUserId"));
    },
  },
  User: {
    name($user) {
      return access($user, "full_name");
    },
    friends($user) {
      const $friendships = friendshipsByUserId(access($user, "id"));
      return each($friendships, ($friendship) =>
        userById(access($friendship, "friend_id")),
      );
    },
  },
};
```

As you can see, the shape of the logic is quite similar, but the Grafast
resolvers build a plan, like this:

<Mermaid chart={mermaidPlan}/>
