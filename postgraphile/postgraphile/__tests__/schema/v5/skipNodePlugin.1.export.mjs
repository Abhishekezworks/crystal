import { PgDeleteSingleStep, PgExecutor, PgResource, PgSelectSingleStep, PgSelectStep, PgUnionAllStep, TYPES, assertPgClassSingleStep, domainOfCodec, enumCodec, listOfCodec, makeRegistry, pgClassExpression, pgDeleteSingle, pgInsertSingle, pgSelectFromRecord, pgSelectFromRecords, pgSelectSingleFromRecord, pgUpdateSingle, rangeOfCodec, recordCodec, sqlFromArgDigests } from "@dataplan/pg";
import { ConnectionStep, EdgeStep, ObjectStep, SafeError, __ValueStep, access, assertEdgeCapableStep, assertExecutableStep, assertPageInfoCapableStep, connection, constant, context, first, getEnumValueConfig, makeGrafastSchema, object, rootValue, stepAMayDependOnStepB } from "grafast";
import { sql } from "pg-sql2";
import { inspect } from "util";
function Query_queryPlan() {
  return rootValue();
}
const executor_mainPgExecutor = new PgExecutor({
  name: "main",
  context() {
    const ctx = context();
    return object({
      pgSettings: "pgSettings" != null ? ctx.get("pgSettings") : constant(null),
      withPgClient: ctx.get("withPgClient")
    });
  }
});
const registryConfig_pgCodecs_CFuncOutOutRecord_CFuncOutOutRecord = recordCodec({
  name: "CFuncOutOutRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: Object.assign(Object.create(null), {
    first_out: {
      notNull: false,
      codec: TYPES.int,
      extensions: {
        argIndex: 0,
        argName: "first_out"
      }
    },
    second_out: {
      notNull: false,
      codec: TYPES.text,
      extensions: {
        argIndex: 1,
        argName: "second_out"
      }
    }
  }),
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes2 = Object.assign(Object.create(null), {
  o1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 0,
      argName: "o1"
    }
  },
  o2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: "o2"
    }
  }
});
const registryConfig_pgCodecs_CFuncOutOutSetofRecord_CFuncOutOutSetofRecord = recordCodec({
  name: "CFuncOutOutSetofRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes2,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes3 = Object.assign(Object.create(null), {
  column1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 0,
      argName: undefined
    }
  },
  column2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: undefined
    }
  }
});
const registryConfig_pgCodecs_CFuncOutOutUnnamedRecord_CFuncOutOutUnnamedRecord = recordCodec({
  name: "CFuncOutOutUnnamedRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes3,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes4 = Object.assign(Object.create(null), {
  first_out: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 0,
      argName: "first_out"
    }
  },
  second_out: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: "second_out"
    }
  }
});
const registryConfig_pgCodecs_CMutationOutOutRecord_CMutationOutOutRecord = recordCodec({
  name: "CMutationOutOutRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes4,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes5 = Object.assign(Object.create(null), {
  o1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 0,
      argName: "o1"
    }
  },
  o2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: "o2"
    }
  }
});
const registryConfig_pgCodecs_CMutationOutOutSetofRecord_CMutationOutOutSetofRecord = recordCodec({
  name: "CMutationOutOutSetofRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes5,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes6 = Object.assign(Object.create(null), {
  column1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 0,
      argName: undefined
    }
  },
  column2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: undefined
    }
  }
});
const registryConfig_pgCodecs_CMutationOutOutUnnamedRecord_CMutationOutOutUnnamedRecord = recordCodec({
  name: "CMutationOutOutUnnamedRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes6,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes7 = Object.assign(Object.create(null), {
  id: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 0,
      argName: "id"
    }
  },
  total_duration: {
    notNull: false,
    codec: TYPES.interval,
    extensions: {
      argIndex: 1,
      argName: "total_duration"
    }
  }
});
const registryConfig_pgCodecs_CSearchTestSummariesRecord_CSearchTestSummariesRecord = recordCodec({
  name: "CSearchTestSummariesRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes7,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes8 = Object.assign(Object.create(null), {
  column1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 0,
      argName: ""
    }
  },
  o2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: "o2"
    }
  },
  column3: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 2,
      argName: ""
    }
  }
});
const registryConfig_pgCodecs_CFuncOutUnnamedOutOutUnnamedRecord_CFuncOutUnnamedOutOutUnnamedRecord = recordCodec({
  name: "CFuncOutUnnamedOutOutUnnamedRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes8,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes9 = Object.assign(Object.create(null), {
  col1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 1,
      argName: "col1"
    }
  },
  col2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 2,
      argName: "col2"
    }
  }
});
const registryConfig_pgCodecs_CFuncReturnsTableMultiColRecord_CFuncReturnsTableMultiColRecord = recordCodec({
  name: "CFuncReturnsTableMultiColRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes9,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes10 = Object.assign(Object.create(null), {
  column1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 0,
      argName: ""
    }
  },
  o2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: "o2"
    }
  },
  column3: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 2,
      argName: ""
    }
  }
});
const registryConfig_pgCodecs_CMutationOutUnnamedOutOutUnnamedRecord_CMutationOutUnnamedOutOutUnnamedRecord = recordCodec({
  name: "CMutationOutUnnamedOutOutUnnamedRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes10,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes11 = Object.assign(Object.create(null), {
  col1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 1,
      argName: "col1"
    }
  },
  col2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 2,
      argName: "col2"
    }
  }
});
const registryConfig_pgCodecs_CMutationReturnsTableMultiColRecord_CMutationReturnsTableMultiColRecord = recordCodec({
  name: "CMutationReturnsTableMultiColRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes11,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const sqlIdent = sql.identifier(...["b", "guid"]);
const registryConfig_pgCodecs_bGuid_bGuid = domainOfCodec(TYPES.varchar, "bGuid", sqlIdent, {
  description: undefined,
  extensions: {
    oid: "1467949",
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "guid"
    },
    tags: Object.create(null)
  },
  notNull: false
});
const extensions2 = {
  oid: "1187",
  pg: {
    serviceName: "main",
    schemaName: "pg_catalog",
    name: "_interval"
  },
  tags: Object.create(null)
};
const registryConfig_pgCodecs_pgCatalogIntervalArray_pgCatalogIntervalArray = listOfCodec(TYPES.interval, {
  extensions: extensions2,
  typeDelim: ",",
  description: undefined,
  name: "pgCatalogIntervalArray"
});
const extensions3 = {
  oid: "1009",
  pg: {
    serviceName: "main",
    schemaName: "pg_catalog",
    name: "_text"
  },
  tags: Object.create(null)
};
const registryConfig_pgCodecs_pgCatalogTextArray_pgCatalogTextArray = listOfCodec(TYPES.text, {
  extensions: extensions3,
  typeDelim: ",",
  description: undefined,
  name: "pgCatalogTextArray"
});
const attributes12 = Object.assign(Object.create(null), {
  "?column?": {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions4 = {
  oid: "1468027",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "non_updatable_view"
  },
  tags: Object.create(null)
};
const parts2 = ["a", "non_updatable_view"];
const sqlIdent2 = sql.identifier(...parts2);
const spec_nonUpdatableView = {
  name: "nonUpdatableView",
  identifier: sqlIdent2,
  attributes: attributes12,
  description: undefined,
  extensions: extensions4,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_nonUpdatableView_nonUpdatableView = recordCodec(spec_nonUpdatableView);
const attributes13 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions5 = {
  oid: "1468240",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "inputs"
  },
  tags: Object.create(null)
};
const parts3 = ["a", "inputs"];
const sqlIdent3 = sql.identifier(...parts3);
const spec_inputs = {
  name: "inputs",
  identifier: sqlIdent3,
  attributes: attributes13,
  description: "Should output as Input",
  extensions: extensions5,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_inputs_inputs = recordCodec(spec_inputs);
const attributes14 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions6 = {
  oid: "1468247",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "patchs"
  },
  tags: Object.create(null)
};
const parts4 = ["a", "patchs"];
const sqlIdent4 = sql.identifier(...parts4);
const spec_patchs = {
  name: "patchs",
  identifier: sqlIdent4,
  attributes: attributes14,
  description: "Should output as Patch",
  extensions: extensions6,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_patchs_patchs = recordCodec(spec_patchs);
const attributes15 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions7 = {
  oid: "1468254",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "reserved"
  },
  tags: Object.create(null)
};
const parts5 = ["a", "reserved"];
const sqlIdent5 = sql.identifier(...parts5);
const spec_reserved = {
  name: "reserved",
  identifier: sqlIdent5,
  attributes: attributes15,
  description: undefined,
  extensions: extensions7,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_reserved_reserved = recordCodec(spec_reserved);
const attributes16 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions8 = {
  oid: "1468268",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "reservedPatchs"
  },
  tags: Object.create(null)
};
const parts6 = ["a", "reservedPatchs"];
const sqlIdent6 = sql.identifier(...parts6);
const spec_reservedPatchs = {
  name: "reservedPatchs",
  identifier: sqlIdent6,
  attributes: attributes16,
  description: "`reservedPatchs` table should get renamed to ReservedPatchRecord to prevent clashes with ReservedPatch from `reserved` table",
  extensions: extensions8,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_reservedPatchs_reservedPatchs = recordCodec(spec_reservedPatchs);
const attributes17 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions9 = {
  oid: "1468261",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "reserved_input"
  },
  tags: Object.create(null)
};
const parts7 = ["a", "reserved_input"];
const sqlIdent7 = sql.identifier(...parts7);
const spec_reservedInput = {
  name: "reservedInput",
  identifier: sqlIdent7,
  attributes: attributes17,
  description: "`reserved_input` table should get renamed to ReservedInputRecord to prevent clashes with ReservedInput from `reserved` table",
  extensions: extensions9,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_reservedInput_reservedInput = recordCodec(spec_reservedInput);
const attributes18 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  null_value: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions10 = {
  oid: "1468217",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "default_value"
  },
  tags: Object.create(null)
};
const parts8 = ["a", "default_value"];
const sqlIdent8 = sql.identifier(...parts8);
const spec_defaultValue = {
  name: "defaultValue",
  identifier: sqlIdent8,
  attributes: attributes18,
  description: undefined,
  extensions: extensions10,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_defaultValue_defaultValue = recordCodec(spec_defaultValue);
const attributes19 = Object.assign(Object.create(null), {
  person_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  compound_key_1: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  compound_key_2: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions11 = {
  oid: "1468046",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "foreign_key"
  },
  tags: Object.create(null)
};
const parts9 = ["a", "foreign_key"];
const sqlIdent9 = sql.identifier(...parts9);
const spec_foreignKey = {
  name: "foreignKey",
  identifier: sqlIdent9,
  attributes: attributes19,
  description: undefined,
  extensions: extensions11,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_foreignKey_foreignKey = recordCodec(spec_foreignKey);
const attributes20 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  str: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions12 = {
  oid: "1467856",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "no_primary_key"
  },
  tags: Object.create(null)
};
const parts10 = ["a", "no_primary_key"];
const sqlIdent10 = sql.identifier(...parts10);
const spec_noPrimaryKey = {
  name: "noPrimaryKey",
  identifier: sqlIdent10,
  attributes: attributes20,
  description: undefined,
  extensions: extensions12,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_noPrimaryKey_noPrimaryKey = recordCodec(spec_noPrimaryKey);
const attributes21 = Object.assign(Object.create(null), {
  testviewid: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  col1: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  col2: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions13 = {
  oid: "1468233",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "testview"
  },
  tags: Object.create(null)
};
const parts11 = ["a", "testview"];
const sqlIdent11 = sql.identifier(...parts11);
const spec_testview = {
  name: "testview",
  identifier: sqlIdent11,
  attributes: attributes21,
  description: undefined,
  extensions: extensions13,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_testview_testview = recordCodec(spec_testview);
const attributes22 = Object.assign(Object.create(null), {
  compound_key_1: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  compound_key_2: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions14 = {
  oid: "1468064",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "unique_foreign_key"
  },
  tags: Object.assign(Object.create(null), {
    omit: "create,update,delete,all,order,filter"
  })
};
const parts12 = ["a", "unique_foreign_key"];
const sqlIdent12 = sql.identifier(...parts12);
const spec_uniqueForeignKey = {
  name: "uniqueForeignKey",
  identifier: sqlIdent12,
  attributes: attributes22,
  description: undefined,
  extensions: extensions14,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_uniqueForeignKey_uniqueForeignKey = recordCodec(spec_uniqueForeignKey);
const attributes23 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  json_data: {
    description: undefined,
    codec: TYPES.jsonb,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions15 = {
  oid: "1468276",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "my_table"
  },
  tags: Object.create(null)
};
const parts13 = ["c", "my_table"];
const sqlIdent13 = sql.identifier(...parts13);
const spec_cMyTable = {
  name: "cMyTable",
  identifier: sqlIdent13,
  attributes: attributes23,
  description: undefined,
  extensions: extensions15,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_cMyTable_cMyTable = recordCodec(spec_cMyTable);
const attributes24 = Object.assign(Object.create(null), {
  person_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  sekrit: {
    description: "A secret held by the associated Person",
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {
        name: "secret"
      }
    }
  }
});
const extensions16 = {
  oid: "1467877",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_secret"
  },
  tags: Object.assign(Object.create(null), {
    deprecated: "This is deprecated (comment on table c.person_secret)."
  })
};
const parts14 = ["c", "person_secret"];
const sqlIdent14 = sql.identifier(...parts14);
const spec_cPersonSecret = {
  name: "cPersonSecret",
  identifier: sqlIdent14,
  attributes: attributes24,
  description: "Tracks the person's secret",
  extensions: extensions16,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_cPersonSecret_cPersonSecret = recordCodec(spec_cPersonSecret);
const attributes25 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  col1: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  col2: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions17 = {
  oid: "1468227",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "view_table"
  },
  tags: Object.create(null)
};
const parts15 = ["a", "view_table"];
const sqlIdent15 = sql.identifier(...parts15);
const spec_viewTable = {
  name: "viewTable",
  identifier: sqlIdent15,
  attributes: attributes25,
  description: undefined,
  extensions: extensions17,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_viewTable_viewTable = recordCodec(spec_viewTable);
const attributes_object_Object_ = Object.assign(Object.create(null), {
  x: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  name: {
    description: undefined,
    codec: TYPES.varchar,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  description: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  constant: {
    description: "This is constantly 2",
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions18 = {
  oid: "1468023",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "updatable_view"
  },
  tags: Object.assign(Object.create(null), {
    uniqueKey: "x"
  })
};
const parts16 = ["b", "updatable_view"];
const sqlIdent16 = sql.identifier(...parts16);
const spec_bUpdatableView = {
  name: "bUpdatableView",
  identifier: sqlIdent16,
  attributes: attributes_object_Object_,
  description: "YOYOYO!!",
  extensions: extensions18,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_bUpdatableView_bUpdatableView = recordCodec(spec_bUpdatableView);
const attributes26 = Object.assign(Object.create(null), {
  person_id_2: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  person_id_1: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  extra: {
    description: undefined,
    codec: TYPES.boolean,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions19 = {
  oid: "1468031",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "compound_key"
  },
  tags: Object.create(null)
};
const parts17 = ["c", "compound_key"];
const sqlIdent17 = sql.identifier(...parts17);
const spec_cCompoundKey = {
  name: "cCompoundKey",
  identifier: sqlIdent17,
  attributes: attributes26,
  description: undefined,
  extensions: extensions19,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_cCompoundKey_cCompoundKey = recordCodec(spec_cCompoundKey);
const attributes27 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  col1: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  col2: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  col3: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions20 = {
  oid: "1468203",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "similar_table_1"
  },
  tags: Object.create(null)
};
const parts18 = ["a", "similar_table_1"];
const sqlIdent18 = sql.identifier(...parts18);
const spec_similarTable1 = {
  name: "similarTable1",
  identifier: sqlIdent18,
  attributes: attributes27,
  description: undefined,
  extensions: extensions20,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_similarTable1_similarTable1 = recordCodec(spec_similarTable1);
const attributes28 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  col3: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  col4: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  col5: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions21 = {
  oid: "1468210",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "similar_table_2"
  },
  tags: Object.create(null)
};
const parts19 = ["a", "similar_table_2"];
const sqlIdent19 = sql.identifier(...parts19);
const spec_similarTable2 = {
  name: "similarTable2",
  identifier: sqlIdent19,
  attributes: attributes28,
  description: undefined,
  extensions: extensions21,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_similarTable2_similarTable2 = recordCodec(spec_similarTable2);
const attributes29 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  nullable_text: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  nullable_int: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  non_null_text: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions22 = {
  oid: "1468294",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "null_test_record"
  },
  tags: Object.create(null)
};
const parts20 = ["c", "null_test_record"];
const sqlIdent20 = sql.identifier(...parts20);
const spec_cNullTestRecord = {
  name: "cNullTestRecord",
  identifier: sqlIdent20,
  attributes: attributes29,
  description: undefined,
  extensions: extensions22,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_cNullTestRecord_cNullTestRecord = recordCodec(spec_cNullTestRecord);
const extensions23 = {
  oid: "2951",
  pg: {
    serviceName: "main",
    schemaName: "pg_catalog",
    name: "_uuid"
  },
  tags: Object.create(null)
};
const registryConfig_pgCodecs_pgCatalogUuidArray_pgCatalogUuidArray = listOfCodec(TYPES.uuid, {
  extensions: extensions23,
  typeDelim: ",",
  description: undefined,
  name: "pgCatalogUuidArray"
});
const attributes30 = Object.assign(Object.create(null), {
  not_null_has_default: {
    description: undefined,
    codec: TYPES.boolean,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  wont_cast_easy: {
    description: undefined,
    codec: TYPES.int2,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  row_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions24 = {
  oid: "1468079",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "edge_case"
  },
  tags: Object.create(null)
};
const parts21 = ["c", "edge_case"];
const sqlIdent21 = sql.identifier(...parts21);
const spec_cEdgeCase = {
  name: "cEdgeCase",
  identifier: sqlIdent21,
  attributes: attributes30,
  description: undefined,
  extensions: extensions24,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_cEdgeCase_cEdgeCase = recordCodec(spec_cEdgeCase);
const attributes31 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  person_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  length_in_metres: {
    description: undefined,
    codec: TYPES.float,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  mood: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions25 = {
  oid: "1467890",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "left_arm"
  },
  tags: Object.create(null)
};
const parts22 = ["c", "left_arm"];
const sqlIdent22 = sql.identifier(...parts22);
const spec_cLeftArm = {
  name: "cLeftArm",
  identifier: sqlIdent22,
  attributes: attributes31,
  description: "Tracks metadata about the left arms of various people",
  extensions: extensions25,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_cLeftArm_cLeftArm = recordCodec(spec_cLeftArm);
const attributes32 = Object.assign(Object.create(null), {
  role: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  exp: {
    description: undefined,
    codec: TYPES.bigint,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  a: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  b: {
    description: undefined,
    codec: TYPES.numeric,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  c: {
    description: undefined,
    codec: TYPES.bigint,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions26 = {
  oid: "1468192",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "jwt_token"
  },
  tags: Object.create(null)
};
const parts23 = ["b", "jwt_token"];
const sqlIdent23 = sql.identifier(...parts23);
const spec_bJwtToken = {
  name: "bJwtToken",
  identifier: sqlIdent23,
  attributes: attributes32,
  description: undefined,
  extensions: extensions26,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_bJwtToken_bJwtToken = recordCodec(spec_bJwtToken);
const extensions27 = {
  oid: "1468283",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "not_null_timestamp"
  },
  tags: Object.create(null)
};
const parts24 = ["c", "not_null_timestamp"];
const sqlIdent24 = sql.identifier(...parts24);
const attributes_ts_codec_cNotNullTimestamp = domainOfCodec(TYPES.timestamptz, "cNotNullTimestamp", sqlIdent24, {
  description: undefined,
  extensions: extensions27,
  notNull: true
});
const attributes33 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  ts: {
    description: undefined,
    codec: attributes_ts_codec_cNotNullTimestamp,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions28 = {
  oid: "1468287",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "issue756"
  },
  tags: Object.create(null)
};
const parts25 = ["c", "issue756"];
const sqlIdent25 = sql.identifier(...parts25);
const spec_cIssue756 = {
  name: "cIssue756",
  identifier: sqlIdent25,
  attributes: attributes33,
  description: undefined,
  extensions: extensions28,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_cIssue756_cIssue756 = recordCodec(spec_cIssue756);
const attributes34 = Object.assign(Object.create(null), {
  jwt: {
    description: undefined,
    codec: registryConfig_pgCodecs_bJwtToken_bJwtToken,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  admin: {
    description: undefined,
    codec: TYPES.boolean,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions29 = {
  oid: "1468198",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "auth_payload"
  },
  tags: Object.assign(Object.create(null), {
    foreignKey: "(id) references c.person"
  })
};
const parts26 = ["b", "auth_payload"];
const sqlIdent26 = sql.identifier(...parts26);
const spec_bAuthPayload = {
  name: "bAuthPayload",
  identifier: sqlIdent26,
  attributes: attributes34,
  description: undefined,
  extensions: extensions29,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_bAuthPayload_bAuthPayload = recordCodec(spec_bAuthPayload);
const extensions30 = {
  oid: "1467980",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "color"
  },
  tags: Object.create(null)
};
const parts27 = ["b", "color"];
const sqlIdent27 = sql.identifier(...parts27);
const attributes_c_codec_bColor = enumCodec({
  name: "bColor",
  identifier: sqlIdent27,
  values: ["red", "green", "blue"],
  description: undefined,
  extensions: extensions30
});
const enumLabels2 = ["FOO_BAR", "BAR_FOO", "BAZ_QUX", "0_BAR"];
const extensions31 = {
  oid: "1467988",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "enum_caps"
  },
  tags: Object.create(null)
};
const parts28 = ["b", "enum_caps"];
const sqlIdent28 = sql.identifier(...parts28);
const attributes_e_codec_bEnumCaps = enumCodec({
  name: "bEnumCaps",
  identifier: sqlIdent28,
  values: enumLabels2,
  description: undefined,
  extensions: extensions31
});
const enumLabels3 = ["", "one", "two"];
const extensions32 = {
  oid: "1467998",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "enum_with_empty_string"
  },
  tags: Object.create(null)
};
const parts29 = ["b", "enum_with_empty_string"];
const sqlIdent29 = sql.identifier(...parts29);
const attributes_f_codec_bEnumWithEmptyString = enumCodec({
  name: "bEnumWithEmptyString",
  identifier: sqlIdent29,
  values: enumLabels3,
  description: undefined,
  extensions: extensions32
});
const attributes36 = Object.assign(Object.create(null), {
  a: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  b: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  c: {
    description: undefined,
    codec: attributes_c_codec_bColor,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  d: {
    description: undefined,
    codec: TYPES.uuid,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  e: {
    description: undefined,
    codec: attributes_e_codec_bEnumCaps,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  f: {
    description: undefined,
    codec: attributes_f_codec_bEnumWithEmptyString,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  g: {
    description: undefined,
    codec: TYPES.interval,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  foo_bar: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions33 = {
  oid: "1468007",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "compound_type"
  },
  tags: Object.create(null)
};
const parts30 = ["c", "compound_type"];
const sqlIdent30 = sql.identifier(...parts30);
const spec_cCompoundType = {
  name: "cCompoundType",
  identifier: sqlIdent30,
  attributes: attributes36,
  description: "Awesome feature!",
  extensions: extensions33,
  executor: executor_mainPgExecutor
};
const attributes_o2_codec_cCompoundType = recordCodec(spec_cCompoundType);
const attributes35 = Object.assign(Object.create(null), {
  o1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 1,
      argName: "o1"
    }
  },
  o2: {
    notNull: false,
    codec: attributes_o2_codec_cCompoundType,
    extensions: {
      argIndex: 2,
      argName: "o2"
    }
  }
});
const registryConfig_pgCodecs_CFuncOutOutCompoundTypeRecord_CFuncOutOutCompoundTypeRecord = recordCodec({
  name: "CFuncOutOutCompoundTypeRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes35,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes37 = Object.assign(Object.create(null), {
  o1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 1,
      argName: "o1"
    }
  },
  o2: {
    notNull: false,
    codec: attributes_o2_codec_cCompoundType,
    extensions: {
      argIndex: 2,
      argName: "o2"
    }
  }
});
const registryConfig_pgCodecs_CMutationOutOutCompoundTypeRecord_CMutationOutOutCompoundTypeRecord = recordCodec({
  name: "CMutationOutOutCompoundTypeRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes37,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const extensions34 = {
  oid: "1467907",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "_an_enum"
  },
  tags: Object.create(null)
};
const enumLabels4 = ["awaiting", "rejected", "published", "*", "**", "***", "foo*", "foo*_", "_foo*", "*bar", "*bar_", "_*bar_", "*baz*", "_*baz*_", "%", ">=", "~~", "$"];
const extensions35 = {
  oid: "1467908",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "an_enum"
  },
  tags: Object.create(null)
};
const parts31 = ["a", "an_enum"];
const sqlIdent31 = sql.identifier(...parts31);
const innerCodec_anEnum = enumCodec({
  name: "anEnum",
  identifier: sqlIdent31,
  values: enumLabels4,
  description: undefined,
  extensions: extensions35
});
const attributes_enums_codec_anEnumArray = listOfCodec(innerCodec_anEnum, {
  extensions: extensions34,
  typeDelim: ",",
  description: undefined,
  name: "anEnumArray"
});
const extensions36 = {
  oid: "1467946",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "_comptype"
  },
  tags: Object.create(null)
};
const attributes40 = Object.assign(Object.create(null), {
  schedule: {
    description: undefined,
    codec: TYPES.timestamptz,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  is_optimised: {
    description: undefined,
    codec: TYPES.boolean,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions37 = {
  oid: "1467947",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "comptype"
  },
  tags: Object.create(null)
};
const parts32 = ["a", "comptype"];
const sqlIdent32 = sql.identifier(...parts32);
const spec_comptype = {
  name: "comptype",
  identifier: sqlIdent32,
  attributes: attributes40,
  description: undefined,
  extensions: extensions37,
  executor: executor_mainPgExecutor
};
const innerCodec_comptype = recordCodec(spec_comptype);
const attributes_comptypes_codec_comptypeArray = listOfCodec(innerCodec_comptype, {
  extensions: extensions36,
  typeDelim: ",",
  description: undefined,
  name: "comptypeArray"
});
const attributes39 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  headline: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  body: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  author_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  enums: {
    description: undefined,
    codec: attributes_enums_codec_anEnumArray,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  comptypes: {
    description: undefined,
    codec: attributes_comptypes_codec_comptypeArray,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions38 = {
  oid: "1467955",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post"
  },
  tags: Object.create(null)
};
const parts33 = ["a", "post"];
const sqlIdent33 = sql.identifier(...parts33);
const spec_post = {
  name: "post",
  identifier: sqlIdent33,
  attributes: attributes39,
  description: undefined,
  extensions: extensions38,
  executor: executor_mainPgExecutor
};
const attributes_post_codec_post = recordCodec(spec_post);
const attributes38 = Object.assign(Object.create(null), {
  txt: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 2,
      argName: "txt"
    }
  },
  left_arm: {
    notNull: false,
    codec: registryConfig_pgCodecs_cLeftArm_cLeftArm,
    extensions: {
      argIndex: 3,
      argName: "left_arm"
    }
  },
  post: {
    notNull: false,
    codec: attributes_post_codec_post,
    extensions: {
      argIndex: 4,
      argName: "post"
    }
  }
});
const registryConfig_pgCodecs_CQueryOutputTwoRowsRecord_CQueryOutputTwoRowsRecord = recordCodec({
  name: "CQueryOutputTwoRowsRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes38,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes41 = Object.assign(Object.create(null), {
  o1: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: "o1"
    }
  },
  o2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 2,
      argName: "o2"
    }
  }
});
const registryConfig_pgCodecs_CPersonComputedOutOutRecord_CPersonComputedOutOutRecord = recordCodec({
  name: "CPersonComputedOutOutRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes41,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes42 = Object.assign(Object.create(null), {
  ino: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: "ino"
    }
  },
  o: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 2,
      argName: "o"
    }
  }
});
const registryConfig_pgCodecs_CPersonComputedInoutOutRecord_CPersonComputedInoutOutRecord = recordCodec({
  name: "CPersonComputedInoutOutRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes42,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const extensions39 = {
  oid: "1467852",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "email"
  },
  tags: Object.create(null)
};
const parts34 = ["b", "email"];
const sqlIdent34 = sql.identifier(...parts34);
const attributes_email_codec_bEmail = domainOfCodec(TYPES.text, "bEmail", sqlIdent34, {
  description: undefined,
  extensions: extensions39,
  notNull: false
});
const extensions40 = {
  oid: "1467847",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "not_null_url"
  },
  tags: Object.create(null)
};
const parts35 = ["b", "not_null_url"];
const sqlIdent35 = sql.identifier(...parts35);
const attributes_url_codec_bNotNullUrl = domainOfCodec(TYPES.varchar, "bNotNullUrl", sqlIdent35, {
  description: undefined,
  extensions: extensions40,
  notNull: true
});
const attributes45 = Object.assign(Object.create(null), {
  url: {
    description: undefined,
    codec: attributes_url_codec_bNotNullUrl,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions41 = {
  oid: "1467850",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "wrapped_url"
  },
  tags: Object.create(null)
};
const parts36 = ["b", "wrapped_url"];
const sqlIdent36 = sql.identifier(...parts36);
const spec_bWrappedUrl = {
  name: "bWrappedUrl",
  identifier: sqlIdent36,
  attributes: attributes45,
  description: undefined,
  extensions: extensions41,
  executor: executor_mainPgExecutor
};
const attributes_site_codec_bWrappedUrl = recordCodec(spec_bWrappedUrl);
const attributes44 = Object.assign(Object.create(null), {
  id: {
    description: "The primary unique identifier for the person",
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  person_full_name: {
    description: "The person\u2019s name",
    codec: TYPES.varchar,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {
        name: "name"
      }
    }
  },
  aliases: {
    description: undefined,
    codec: registryConfig_pgCodecs_pgCatalogTextArray_pgCatalogTextArray,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  about: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  email: {
    description: undefined,
    codec: attributes_email_codec_bEmail,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  site: {
    description: undefined,
    codec: attributes_site_codec_bWrappedUrl,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {
        deprecated: "Don\u2019t use me"
      }
    }
  },
  config: {
    description: undefined,
    codec: TYPES.hstore,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  last_login_from_ip: {
    description: undefined,
    codec: TYPES.inet,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  last_login_from_subnet: {
    description: undefined,
    codec: TYPES.cidr,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  user_mac: {
    description: undefined,
    codec: TYPES.macaddr,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  created_at: {
    description: undefined,
    codec: TYPES.timestamp,
    notNull: false,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions42 = {
  oid: "1467864",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person"
  },
  tags: Object.create(null)
};
const parts37 = ["c", "person"];
const sqlIdent37 = sql.identifier(...parts37);
const spec_cPerson = {
  name: "cPerson",
  identifier: sqlIdent37,
  attributes: attributes44,
  description: "Person test comment",
  extensions: extensions42,
  executor: executor_mainPgExecutor
};
const attributes_person_codec_cPerson = recordCodec(spec_cPerson);
const attributes43 = Object.assign(Object.create(null), {
  person: {
    notNull: false,
    codec: attributes_person_codec_cPerson,
    extensions: {
      argIndex: 0,
      argName: "person"
    }
  },
  o: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 1,
      argName: "o"
    }
  }
});
const registryConfig_pgCodecs_CPersonComputedFirstArgInoutOutRecord_CPersonComputedFirstArgInoutOutRecord = recordCodec({
  name: "CPersonComputedFirstArgInoutOutRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes43,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes46 = Object.assign(Object.create(null), {
  x: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 2,
      argName: "x"
    }
  },
  y: {
    notNull: false,
    codec: attributes_o2_codec_cCompoundType,
    extensions: {
      argIndex: 3,
      argName: "y"
    }
  },
  z: {
    notNull: false,
    codec: attributes_person_codec_cPerson,
    extensions: {
      argIndex: 4,
      argName: "z"
    }
  }
});
const registryConfig_pgCodecs_CFuncOutComplexRecord_CFuncOutComplexRecord = recordCodec({
  name: "CFuncOutComplexRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes46,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes47 = Object.assign(Object.create(null), {
  x: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 2,
      argName: "x"
    }
  },
  y: {
    notNull: false,
    codec: attributes_o2_codec_cCompoundType,
    extensions: {
      argIndex: 3,
      argName: "y"
    }
  },
  z: {
    notNull: false,
    codec: attributes_person_codec_cPerson,
    extensions: {
      argIndex: 4,
      argName: "z"
    }
  }
});
const registryConfig_pgCodecs_CFuncOutComplexSetofRecord_CFuncOutComplexSetofRecord = recordCodec({
  name: "CFuncOutComplexSetofRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes47,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes48 = Object.assign(Object.create(null), {
  x: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 2,
      argName: "x"
    }
  },
  y: {
    notNull: false,
    codec: attributes_o2_codec_cCompoundType,
    extensions: {
      argIndex: 3,
      argName: "y"
    }
  },
  z: {
    notNull: false,
    codec: attributes_person_codec_cPerson,
    extensions: {
      argIndex: 4,
      argName: "z"
    }
  }
});
const registryConfig_pgCodecs_CMutationOutComplexRecord_CMutationOutComplexRecord = recordCodec({
  name: "CMutationOutComplexRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes48,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes49 = Object.assign(Object.create(null), {
  x: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 2,
      argName: "x"
    }
  },
  y: {
    notNull: false,
    codec: attributes_o2_codec_cCompoundType,
    extensions: {
      argIndex: 3,
      argName: "y"
    }
  },
  z: {
    notNull: false,
    codec: attributes_person_codec_cPerson,
    extensions: {
      argIndex: 4,
      argName: "z"
    }
  }
});
const registryConfig_pgCodecs_CMutationOutComplexSetofRecord_CMutationOutComplexSetofRecord = recordCodec({
  name: "CMutationOutComplexSetofRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes49,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes50 = Object.assign(Object.create(null), {
  x: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 3,
      argName: "x"
    }
  },
  y: {
    notNull: false,
    codec: attributes_o2_codec_cCompoundType,
    extensions: {
      argIndex: 4,
      argName: "y"
    }
  },
  z: {
    notNull: false,
    codec: attributes_person_codec_cPerson,
    extensions: {
      argIndex: 5,
      argName: "z"
    }
  }
});
const registryConfig_pgCodecs_CPersonComputedComplexRecord_CPersonComputedComplexRecord = recordCodec({
  name: "CPersonComputedComplexRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes50,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const extensions43 = {
  oid: "1467979",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "_color"
  },
  tags: Object.create(null)
};
const attributes_enum_array_codec_bColorArray = listOfCodec(attributes_c_codec_bColor, {
  extensions: extensions43,
  typeDelim: ",",
  description: undefined,
  name: "bColorArray"
});
const extensions44 = {
  oid: "1468085",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "an_int"
  },
  tags: Object.create(null)
};
const parts38 = ["a", "an_int"];
const sqlIdent38 = sql.identifier(...parts38);
const attributes_domain_codec_anInt = domainOfCodec(TYPES.int, "anInt", sqlIdent38, {
  description: undefined,
  extensions: extensions44,
  notNull: false
});
const extensions45 = {
  oid: "1468087",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "another_int"
  },
  tags: Object.create(null)
};
const parts39 = ["b", "another_int"];
const sqlIdent39 = sql.identifier(...parts39);
const attributes_domain2_codec_bAnotherInt = domainOfCodec(attributes_domain_codec_anInt, "bAnotherInt", sqlIdent39, {
  description: undefined,
  extensions: extensions45,
  notNull: false
});
const extensions46 = {
  oid: "3906",
  pg: {
    serviceName: "main",
    schemaName: "pg_catalog",
    name: "numrange"
  },
  tags: Object.create(null)
};
const parts40 = ["pg_catalog", "numrange"];
const sqlIdent40 = sql.identifier(...parts40);
const attributes_nullable_range_codec_pgCatalogNumrange = rangeOfCodec(TYPES.numeric, "pgCatalogNumrange", sqlIdent40, {
  description: "range of numerics",
  extensions: extensions46
});
const extensions47 = {
  oid: "3912",
  pg: {
    serviceName: "main",
    schemaName: "pg_catalog",
    name: "daterange"
  },
  tags: Object.create(null)
};
const parts41 = ["pg_catalog", "daterange"];
const sqlIdent41 = sql.identifier(...parts41);
const attributes_daterange_codec_pgCatalogDaterange = rangeOfCodec(TYPES.date, "pgCatalogDaterange", sqlIdent41, {
  description: "range of dates",
  extensions: extensions47
});
const extensions48 = {
  oid: "1468091",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "an_int_range"
  },
  tags: Object.create(null)
};
const parts42 = ["a", "an_int_range"];
const sqlIdent42 = sql.identifier(...parts42);
const attributes_an_int_range_codec_anIntRange = rangeOfCodec(attributes_domain_codec_anInt, "anIntRange", sqlIdent42, {
  description: undefined,
  extensions: extensions48
});
const attributes52 = Object.assign(Object.create(null), {
  a: {
    description: undefined,
    codec: attributes_o2_codec_cCompoundType,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  b: {
    description: undefined,
    codec: attributes_o2_codec_cCompoundType,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  baz_buz: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions49 = {
  oid: "1468010",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "nested_compound_type"
  },
  tags: Object.create(null)
};
const parts43 = ["b", "nested_compound_type"];
const sqlIdent43 = sql.identifier(...parts43);
const spec_bNestedCompoundType = {
  name: "bNestedCompoundType",
  identifier: sqlIdent43,
  attributes: attributes52,
  description: undefined,
  extensions: extensions49,
  executor: executor_mainPgExecutor
};
const attributes_nested_compound_type_codec_bNestedCompoundType = recordCodec(spec_bNestedCompoundType);
const extensions50 = {
  oid: "1468099",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "text_array_domain"
  },
  tags: Object.create(null)
};
const parts44 = ["c", "text_array_domain"];
const sqlIdent44 = sql.identifier(...parts44);
const attributes_text_array_domain_codec_cTextArrayDomain = domainOfCodec(registryConfig_pgCodecs_pgCatalogTextArray_pgCatalogTextArray, "cTextArrayDomain", sqlIdent44, {
  description: undefined,
  extensions: extensions50,
  notNull: false
});
const extensions51 = {
  oid: "1468101",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "int8_array_domain"
  },
  tags: Object.create(null)
};
const extensions52 = {
  oid: "1016",
  pg: {
    serviceName: "main",
    schemaName: "pg_catalog",
    name: "_int8"
  },
  tags: Object.create(null)
};
const innerCodec_pgCatalogInt8Array = listOfCodec(TYPES.bigint, {
  extensions: extensions52,
  typeDelim: ",",
  description: undefined,
  name: "pgCatalogInt8Array"
});
const parts45 = ["c", "int8_array_domain"];
const sqlIdent45 = sql.identifier(...parts45);
const attributes_int8_array_domain_codec_cInt8ArrayDomain = domainOfCodec(innerCodec_pgCatalogInt8Array, "cInt8ArrayDomain", sqlIdent45, {
  description: undefined,
  extensions: extensions51,
  notNull: false
});
const extensions53 = {
  oid: "1001",
  pg: {
    serviceName: "main",
    schemaName: "pg_catalog",
    name: "_bytea"
  },
  tags: Object.create(null)
};
const attributes_bytea_array_codec_pgCatalogByteaArray = listOfCodec(TYPES.bytea, {
  extensions: extensions53,
  typeDelim: ",",
  description: undefined,
  name: "pgCatalogByteaArray"
});
const attributes_ltree_codec_ltree = {
  name: "ltree",
  sqlType: sql`ltree`,
  toPg(str) {
    return str;
  },
  fromPg(str) {
    return str;
  },
  executor: null,
  attributes: undefined
};
const attributes_ltree_array_codec_ltree_ = listOfCodec(attributes_ltree_codec_ltree);
const attributes51 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  smallint: {
    description: undefined,
    codec: TYPES.int2,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  bigint: {
    description: undefined,
    codec: TYPES.bigint,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  numeric: {
    description: undefined,
    codec: TYPES.numeric,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  decimal: {
    description: undefined,
    codec: TYPES.numeric,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  boolean: {
    description: undefined,
    codec: TYPES.boolean,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  varchar: {
    description: undefined,
    codec: TYPES.varchar,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  enum: {
    description: undefined,
    codec: attributes_c_codec_bColor,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  enum_array: {
    description: undefined,
    codec: attributes_enum_array_codec_bColorArray,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  domain: {
    description: undefined,
    codec: attributes_domain_codec_anInt,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  domain2: {
    description: undefined,
    codec: attributes_domain2_codec_bAnotherInt,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  text_array: {
    description: undefined,
    codec: registryConfig_pgCodecs_pgCatalogTextArray_pgCatalogTextArray,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  json: {
    description: undefined,
    codec: TYPES.json,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  jsonb: {
    description: undefined,
    codec: TYPES.jsonb,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  nullable_range: {
    description: undefined,
    codec: attributes_nullable_range_codec_pgCatalogNumrange,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  numrange: {
    description: undefined,
    codec: attributes_nullable_range_codec_pgCatalogNumrange,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  daterange: {
    description: undefined,
    codec: attributes_daterange_codec_pgCatalogDaterange,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  an_int_range: {
    description: undefined,
    codec: attributes_an_int_range_codec_anIntRange,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  timestamp: {
    description: undefined,
    codec: TYPES.timestamp,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  timestamptz: {
    description: undefined,
    codec: TYPES.timestamptz,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  date: {
    description: undefined,
    codec: TYPES.date,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  time: {
    description: undefined,
    codec: TYPES.time,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  timetz: {
    description: undefined,
    codec: TYPES.timetz,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  interval: {
    description: undefined,
    codec: TYPES.interval,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  interval_array: {
    description: undefined,
    codec: registryConfig_pgCodecs_pgCatalogIntervalArray_pgCatalogIntervalArray,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  money: {
    description: undefined,
    codec: TYPES.money,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  compound_type: {
    description: undefined,
    codec: attributes_o2_codec_cCompoundType,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  nested_compound_type: {
    description: undefined,
    codec: attributes_nested_compound_type_codec_bNestedCompoundType,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  nullable_compound_type: {
    description: undefined,
    codec: attributes_o2_codec_cCompoundType,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  nullable_nested_compound_type: {
    description: undefined,
    codec: attributes_nested_compound_type_codec_bNestedCompoundType,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  point: {
    description: undefined,
    codec: TYPES.point,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  nullablePoint: {
    description: undefined,
    codec: TYPES.point,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  inet: {
    description: undefined,
    codec: TYPES.inet,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  cidr: {
    description: undefined,
    codec: TYPES.cidr,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  macaddr: {
    description: undefined,
    codec: TYPES.macaddr,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  regproc: {
    description: undefined,
    codec: TYPES.regproc,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  regprocedure: {
    description: undefined,
    codec: TYPES.regprocedure,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  regoper: {
    description: undefined,
    codec: TYPES.regoper,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  regoperator: {
    description: undefined,
    codec: TYPES.regoperator,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  regclass: {
    description: undefined,
    codec: TYPES.regclass,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  regtype: {
    description: undefined,
    codec: TYPES.regtype,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  regconfig: {
    description: undefined,
    codec: TYPES.regconfig,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  regdictionary: {
    description: undefined,
    codec: TYPES.regdictionary,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  text_array_domain: {
    description: undefined,
    codec: attributes_text_array_domain_codec_cTextArrayDomain,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  int8_array_domain: {
    description: undefined,
    codec: attributes_int8_array_domain_codec_cInt8ArrayDomain,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  bytea: {
    description: undefined,
    codec: TYPES.bytea,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  bytea_array: {
    description: undefined,
    codec: attributes_bytea_array_codec_pgCatalogByteaArray,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  ltree: {
    description: undefined,
    codec: attributes_ltree_codec_ltree,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  ltree_array: {
    description: undefined,
    codec: attributes_ltree_array_codec_ltree_,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions54 = {
  oid: "1468105",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "types"
  },
  tags: Object.assign(Object.create(null), {
    foreignKey: ["(smallint) references a.post", "(id) references a.post"]
  })
};
const parts46 = ["b", "types"];
const sqlIdent46 = sql.identifier(...parts46);
const spec_bTypes = {
  name: "bTypes",
  identifier: sqlIdent46,
  attributes: attributes51,
  description: undefined,
  extensions: extensions54,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_bTypes_bTypes = recordCodec(spec_bTypes);
const extensions55 = {
  oid: "1468006",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "_compound_type"
  },
  tags: Object.create(null)
};
const extensions56 = {
  oid: "1468191",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "_jwt_token"
  },
  tags: Object.create(null)
};
const extensions57 = {
  oid: "1468104",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "_types"
  },
  tags: Object.create(null)
};
const extensions58 = {
  oid: "1007",
  pg: {
    serviceName: "main",
    schemaName: "pg_catalog",
    name: "_int4"
  },
  tags: Object.create(null)
};
const registryConfig_pgCodecs_pgCatalogInt4Array_pgCatalogInt4Array = listOfCodec(TYPES.int, {
  extensions: extensions58,
  typeDelim: ",",
  description: undefined,
  name: "pgCatalogInt4Array"
});
const extensions59 = {
  oid: "1468014",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "floatrange"
  },
  tags: Object.create(null)
};
const parts47 = ["c", "floatrange"];
const sqlIdent47 = sql.identifier(...parts47);
const registryConfig_pgCodecs_cFloatrange_cFloatrange = rangeOfCodec(TYPES.float, "cFloatrange", sqlIdent47, {
  description: undefined,
  extensions: extensions59
});
const extensions60 = {
  oid: "1467954",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "_post"
  },
  tags: Object.create(null)
};
const registryConfig_pgCodecs_postArray_postArray = listOfCodec(attributes_post_codec_post, {
  extensions: extensions60,
  typeDelim: ",",
  description: undefined,
  name: "postArray"
});
const attributes53 = Object.assign(Object.create(null), {
  row_name: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_1: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_2: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions61 = {
  oid: "1467395",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "tablefunc_crosstab_2"
  },
  tags: Object.create(null)
};
const parts48 = ["a", "tablefunc_crosstab_2"];
const sqlIdent48 = sql.identifier(...parts48);
const spec_tablefuncCrosstab2 = {
  name: "tablefuncCrosstab2",
  identifier: sqlIdent48,
  attributes: attributes53,
  description: undefined,
  extensions: extensions61,
  executor: executor_mainPgExecutor
};
const attributes54 = Object.assign(Object.create(null), {
  row_name: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_1: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_2: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_3: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions62 = {
  oid: "1467398",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "tablefunc_crosstab_3"
  },
  tags: Object.create(null)
};
const parts49 = ["a", "tablefunc_crosstab_3"];
const sqlIdent49 = sql.identifier(...parts49);
const spec_tablefuncCrosstab3 = {
  name: "tablefuncCrosstab3",
  identifier: sqlIdent49,
  attributes: attributes54,
  description: undefined,
  extensions: extensions62,
  executor: executor_mainPgExecutor
};
const attributes55 = Object.assign(Object.create(null), {
  row_name: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_1: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_2: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_3: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_4: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions63 = {
  oid: "1467401",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "tablefunc_crosstab_4"
  },
  tags: Object.create(null)
};
const parts50 = ["a", "tablefunc_crosstab_4"];
const sqlIdent50 = sql.identifier(...parts50);
const spec_tablefuncCrosstab4 = {
  name: "tablefuncCrosstab4",
  identifier: sqlIdent50,
  attributes: attributes55,
  description: undefined,
  extensions: extensions63,
  executor: executor_mainPgExecutor
};
const extensions64 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "current_user_id"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts51 = ["c", "current_user_id"];
const sqlIdent51 = sql.identifier(...parts51);
const extensions65 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out"
  },
  tags: {
    behavior: ["-filter -order"]
  },
  singleOutputParameterName: "o"
};
const parts52 = ["c", "func_out"];
const sqlIdent52 = sql.identifier(...parts52);
const fromCallback2 = (...args) => sql`${sqlIdent52}(${sqlFromArgDigests(args)})`;
const parameters2 = [];
const extensions66 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_setof"
  },
  tags: {
    behavior: ["-filter -order"]
  },
  singleOutputParameterName: "o"
};
const parts53 = ["c", "func_out_setof"];
const sqlIdent53 = sql.identifier(...parts53);
const fromCallback3 = (...args) => sql`${sqlIdent53}(${sqlFromArgDigests(args)})`;
const parameters3 = [];
const extensions67 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_unnamed"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts54 = ["c", "func_out_unnamed"];
const sqlIdent54 = sql.identifier(...parts54);
const fromCallback4 = (...args) => sql`${sqlIdent54}(${sqlFromArgDigests(args)})`;
const parameters4 = [];
const extensions68 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out"
  },
  tags: {
    behavior: ["-filter -order"]
  },
  singleOutputParameterName: "o"
};
const parts55 = ["c", "mutation_out"];
const sqlIdent55 = sql.identifier(...parts55);
const fromCallback5 = (...args) => sql`${sqlIdent55}(${sqlFromArgDigests(args)})`;
const parameters5 = [];
const extensions69 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_setof"
  },
  tags: {
    behavior: ["-filter -order"]
  },
  singleOutputParameterName: "o"
};
const parts56 = ["c", "mutation_out_setof"];
const sqlIdent56 = sql.identifier(...parts56);
const fromCallback6 = (...args) => sql`${sqlIdent56}(${sqlFromArgDigests(args)})`;
const parameters6 = [];
const extensions70 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_unnamed"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts57 = ["c", "mutation_out_unnamed"];
const sqlIdent57 = sql.identifier(...parts57);
const fromCallback7 = (...args) => sql`${sqlIdent57}(${sqlFromArgDigests(args)})`;
const parameters7 = [];
const extensions71 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "no_args_mutation"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts58 = ["c", "no_args_mutation"];
const sqlIdent58 = sql.identifier(...parts58);
const fromCallback8 = (...args) => sql`${sqlIdent58}(${sqlFromArgDigests(args)})`;
const parameters8 = [];
const extensions72 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "no_args_query"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts59 = ["c", "no_args_query"];
const sqlIdent59 = sql.identifier(...parts59);
const fromCallback9 = (...args) => sql`${sqlIdent59}(${sqlFromArgDigests(args)})`;
const parameters9 = [];
const extensions73 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "return_void_mutation"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts60 = ["a", "return_void_mutation"];
const sqlIdent60 = sql.identifier(...parts60);
const fromCallback10 = (...args) => sql`${sqlIdent60}(${sqlFromArgDigests(args)})`;
const parameters10 = [];
const extensions74 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "mutation_interval_set"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts61 = ["a", "mutation_interval_set"];
const sqlIdent61 = sql.identifier(...parts61);
const fromCallback11 = (...args) => sql`${sqlIdent61}(${sqlFromArgDigests(args)})`;
const parameters11 = [];
const extensions75 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "query_interval_set"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts62 = ["a", "query_interval_set"];
const sqlIdent62 = sql.identifier(...parts62);
const fromCallback12 = (...args) => sql`${sqlIdent62}(${sqlFromArgDigests(args)})`;
const parameters12 = [];
const extensions76 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "static_big_integer"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts63 = ["a", "static_big_integer"];
const sqlIdent63 = sql.identifier(...parts63);
const fromCallback13 = (...args) => sql`${sqlIdent63}(${sqlFromArgDigests(args)})`;
const parameters13 = [];
const extensions77 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_in_out"
  },
  tags: {
    behavior: ["-filter -order"]
  },
  singleOutputParameterName: "o"
};
const parts64 = ["c", "func_in_out"];
const sqlIdent64 = sql.identifier(...parts64);
const fromCallback14 = (...args) => sql`${sqlIdent64}(${sqlFromArgDigests(args)})`;
const parameters14 = [{
  name: "i",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions78 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_returns_table_one_col"
  },
  tags: {
    behavior: ["-filter -order"]
  },
  singleOutputParameterName: "col1"
};
const parts65 = ["c", "func_returns_table_one_col"];
const sqlIdent65 = sql.identifier(...parts65);
const fromCallback15 = (...args) => sql`${sqlIdent65}(${sqlFromArgDigests(args)})`;
const parameters15 = [{
  name: "i",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions79 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_in_out"
  },
  tags: {
    behavior: ["-filter -order"]
  },
  singleOutputParameterName: "o"
};
const parts66 = ["c", "mutation_in_out"];
const sqlIdent66 = sql.identifier(...parts66);
const fromCallback16 = (...args) => sql`${sqlIdent66}(${sqlFromArgDigests(args)})`;
const parameters16 = [{
  name: "i",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions80 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_returns_table_one_col"
  },
  tags: {
    behavior: ["-filter -order"]
  },
  singleOutputParameterName: "col1"
};
const parts67 = ["c", "mutation_returns_table_one_col"];
const sqlIdent67 = sql.identifier(...parts67);
const fromCallback17 = (...args) => sql`${sqlIdent67}(${sqlFromArgDigests(args)})`;
const parameters17 = [{
  name: "i",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions81 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "assert_something"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts68 = ["a", "assert_something"];
const sqlIdent68 = sql.identifier(...parts68);
const fromCallback18 = (...args) => sql`${sqlIdent68}(${sqlFromArgDigests(args)})`;
const parameters18 = [{
  name: "in_arg",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions82 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "assert_something_nx"
  },
  tags: {
    omit: "execute",
    behavior: ["-filter -order"]
  }
};
const parts69 = ["a", "assert_something_nx"];
const sqlIdent69 = sql.identifier(...parts69);
const fromCallback19 = (...args) => sql`${sqlIdent69}(${sqlFromArgDigests(args)})`;
const parameters19 = [{
  name: "in_arg",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions83 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "json_identity"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts70 = ["c", "json_identity"];
const sqlIdent70 = sql.identifier(...parts70);
const fromCallback20 = (...args) => sql`${sqlIdent70}(${sqlFromArgDigests(args)})`;
const parameters20 = [{
  name: "json",
  required: true,
  notNull: false,
  codec: TYPES.json
}];
const extensions84 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "json_identity_mutation"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts71 = ["c", "json_identity_mutation"];
const sqlIdent71 = sql.identifier(...parts71);
const fromCallback21 = (...args) => sql`${sqlIdent71}(${sqlFromArgDigests(args)})`;
const parameters21 = [{
  name: "json",
  required: true,
  notNull: false,
  codec: TYPES.json
}];
const extensions85 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "jsonb_identity"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts72 = ["c", "jsonb_identity"];
const sqlIdent72 = sql.identifier(...parts72);
const fromCallback22 = (...args) => sql`${sqlIdent72}(${sqlFromArgDigests(args)})`;
const parameters22 = [{
  name: "json",
  required: true,
  notNull: false,
  codec: TYPES.jsonb
}];
const extensions86 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "jsonb_identity_mutation"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts73 = ["c", "jsonb_identity_mutation"];
const sqlIdent73 = sql.identifier(...parts73);
const fromCallback23 = (...args) => sql`${sqlIdent73}(${sqlFromArgDigests(args)})`;
const parameters23 = [{
  name: "json",
  required: true,
  notNull: false,
  codec: TYPES.jsonb
}];
const extensions87 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "jsonb_identity_mutation_plpgsql"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts74 = ["c", "jsonb_identity_mutation_plpgsql"];
const sqlIdent74 = sql.identifier(...parts74);
const fromCallback24 = (...args) => sql`${sqlIdent74}(${sqlFromArgDigests(args)})`;
const parameters24 = [{
  name: "_the_json",
  required: true,
  notNull: true,
  codec: TYPES.jsonb
}];
const extensions88 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "jsonb_identity_mutation_plpgsql_with_default"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts75 = ["c", "jsonb_identity_mutation_plpgsql_with_default"];
const sqlIdent75 = sql.identifier(...parts75);
const fromCallback25 = (...args) => sql`${sqlIdent75}(${sqlFromArgDigests(args)})`;
const parameters25 = [{
  name: "_the_json",
  required: false,
  notNull: true,
  codec: TYPES.jsonb
}];
const extensions89 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_1_mutation"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts76 = ["a", "add_1_mutation"];
const sqlIdent76 = sql.identifier(...parts76);
const fromCallback26 = (...args) => sql`${sqlIdent76}(${sqlFromArgDigests(args)})`;
const parameters26 = [{
  name: null,
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: null,
  required: true,
  notNull: true,
  codec: TYPES.int
}];
const extensions90 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_1_query"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts77 = ["a", "add_1_query"];
const sqlIdent77 = sql.identifier(...parts77);
const fromCallback27 = (...args) => sql`${sqlIdent77}(${sqlFromArgDigests(args)})`;
const parameters27 = [{
  name: null,
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: null,
  required: true,
  notNull: true,
  codec: TYPES.int
}];
const extensions91 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_2_mutation"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts78 = ["a", "add_2_mutation"];
const sqlIdent78 = sql.identifier(...parts78);
const fromCallback28 = (...args) => sql`${sqlIdent78}(${sqlFromArgDigests(args)})`;
const parameters28 = [{
  name: "a",
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: "b",
  required: false,
  notNull: true,
  codec: TYPES.int
}];
const extensions92 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_2_query"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts79 = ["a", "add_2_query"];
const sqlIdent79 = sql.identifier(...parts79);
const fromCallback29 = (...args) => sql`${sqlIdent79}(${sqlFromArgDigests(args)})`;
const parameters29 = [{
  name: "a",
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: "b",
  required: false,
  notNull: true,
  codec: TYPES.int
}];
const extensions93 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_3_mutation"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts80 = ["a", "add_3_mutation"];
const sqlIdent80 = sql.identifier(...parts80);
const fromCallback30 = (...args) => sql`${sqlIdent80}(${sqlFromArgDigests(args)})`;
const parameters30 = [{
  name: "a",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions94 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_3_query"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts81 = ["a", "add_3_query"];
const sqlIdent81 = sql.identifier(...parts81);
const fromCallback31 = (...args) => sql`${sqlIdent81}(${sqlFromArgDigests(args)})`;
const parameters31 = [{
  name: "a",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions95 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_4_mutation"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts82 = ["a", "add_4_mutation"];
const sqlIdent82 = sql.identifier(...parts82);
const fromCallback32 = (...args) => sql`${sqlIdent82}(${sqlFromArgDigests(args)})`;
const parameters32 = [{
  name: "",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "b",
  required: false,
  notNull: false,
  codec: TYPES.int
}];
const extensions96 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_4_mutation_error"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts83 = ["a", "add_4_mutation_error"];
const sqlIdent83 = sql.identifier(...parts83);
const fromCallback33 = (...args) => sql`${sqlIdent83}(${sqlFromArgDigests(args)})`;
const parameters33 = [{
  name: "",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "b",
  required: false,
  notNull: false,
  codec: TYPES.int
}];
const extensions97 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_4_query"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts84 = ["a", "add_4_query"];
const sqlIdent84 = sql.identifier(...parts84);
const fromCallback34 = (...args) => sql`${sqlIdent84}(${sqlFromArgDigests(args)})`;
const parameters34 = [{
  name: "",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "b",
  required: false,
  notNull: false,
  codec: TYPES.int
}];
const extensions98 = {
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "mult_1"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts85 = ["b", "mult_1"];
const sqlIdent85 = sql.identifier(...parts85);
const fromCallback35 = (...args) => sql`${sqlIdent85}(${sqlFromArgDigests(args)})`;
const parameters35 = [{
  name: null,
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: null,
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions99 = {
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "mult_2"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts86 = ["b", "mult_2"];
const sqlIdent86 = sql.identifier(...parts86);
const fromCallback36 = (...args) => sql`${sqlIdent86}(${sqlFromArgDigests(args)})`;
const parameters36 = [{
  name: null,
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: null,
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions100 = {
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "mult_3"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts87 = ["b", "mult_3"];
const sqlIdent87 = sql.identifier(...parts87);
const fromCallback37 = (...args) => sql`${sqlIdent87}(${sqlFromArgDigests(args)})`;
const parameters37 = [{
  name: null,
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: null,
  required: true,
  notNull: true,
  codec: TYPES.int
}];
const extensions101 = {
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "mult_4"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts88 = ["b", "mult_4"];
const sqlIdent88 = sql.identifier(...parts88);
const fromCallback38 = (...args) => sql`${sqlIdent88}(${sqlFromArgDigests(args)})`;
const parameters38 = [{
  name: null,
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: null,
  required: true,
  notNull: true,
  codec: TYPES.int
}];
const extensions102 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_in_inout"
  },
  tags: {
    behavior: ["-filter -order"]
  },
  singleOutputParameterName: "ino"
};
const parts89 = ["c", "func_in_inout"];
const sqlIdent89 = sql.identifier(...parts89);
const fromCallback39 = (...args) => sql`${sqlIdent89}(${sqlFromArgDigests(args)})`;
const parameters39 = [{
  name: "i",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "ino",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions103 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_out"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts90 = ["c", "func_out_out"];
const sqlIdent90 = sql.identifier(...parts90);
const fromCallback40 = (...args) => sql`${sqlIdent90}(${sqlFromArgDigests(args)})`;
const parameters40 = [];
const extensions104 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_out_setof"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts91 = ["c", "func_out_out_setof"];
const sqlIdent91 = sql.identifier(...parts91);
const fromCallback41 = (...args) => sql`${sqlIdent91}(${sqlFromArgDigests(args)})`;
const parameters41 = [];
const extensions105 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_out_unnamed"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts92 = ["c", "func_out_out_unnamed"];
const sqlIdent92 = sql.identifier(...parts92);
const fromCallback42 = (...args) => sql`${sqlIdent92}(${sqlFromArgDigests(args)})`;
const parameters42 = [];
const extensions106 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_in_inout"
  },
  tags: {
    behavior: ["-filter -order"]
  },
  singleOutputParameterName: "ino"
};
const parts93 = ["c", "mutation_in_inout"];
const sqlIdent93 = sql.identifier(...parts93);
const fromCallback43 = (...args) => sql`${sqlIdent93}(${sqlFromArgDigests(args)})`;
const parameters43 = [{
  name: "i",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "ino",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions107 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_out"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts94 = ["c", "mutation_out_out"];
const sqlIdent94 = sql.identifier(...parts94);
const fromCallback44 = (...args) => sql`${sqlIdent94}(${sqlFromArgDigests(args)})`;
const parameters44 = [];
const extensions108 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_out_setof"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts95 = ["c", "mutation_out_out_setof"];
const sqlIdent95 = sql.identifier(...parts95);
const fromCallback45 = (...args) => sql`${sqlIdent95}(${sqlFromArgDigests(args)})`;
const parameters45 = [];
const extensions109 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_out_unnamed"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts96 = ["c", "mutation_out_out_unnamed"];
const sqlIdent96 = sql.identifier(...parts96);
const fromCallback46 = (...args) => sql`${sqlIdent96}(${sqlFromArgDigests(args)})`;
const parameters46 = [];
const extensions110 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "search_test_summaries"
  },
  tags: {
    simpleCollections: "only",
    behavior: ["-filter -order"]
  }
};
const parts97 = ["c", "search_test_summaries"];
const sqlIdent97 = sql.identifier(...parts97);
const fromCallback47 = (...args) => sql`${sqlIdent97}(${sqlFromArgDigests(args)})`;
const parameters47 = [];
const extensions111 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "optional_missing_middle_1"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts98 = ["a", "optional_missing_middle_1"];
const sqlIdent98 = sql.identifier(...parts98);
const fromCallback48 = (...args) => sql`${sqlIdent98}(${sqlFromArgDigests(args)})`;
const parameters48 = [{
  name: "",
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: "b",
  required: false,
  notNull: true,
  codec: TYPES.int
}, {
  name: "c",
  required: false,
  notNull: true,
  codec: TYPES.int
}];
const extensions112 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "optional_missing_middle_2"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts99 = ["a", "optional_missing_middle_2"];
const sqlIdent99 = sql.identifier(...parts99);
const fromCallback49 = (...args) => sql`${sqlIdent99}(${sqlFromArgDigests(args)})`;
const parameters49 = [{
  name: "a",
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: "b",
  required: false,
  notNull: true,
  codec: TYPES.int
}, {
  name: "c",
  required: false,
  notNull: true,
  codec: TYPES.int
}];
const extensions113 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "optional_missing_middle_3"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts100 = ["a", "optional_missing_middle_3"];
const sqlIdent100 = sql.identifier(...parts100);
const fromCallback50 = (...args) => sql`${sqlIdent100}(${sqlFromArgDigests(args)})`;
const parameters50 = [{
  name: "a",
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: "",
  required: false,
  notNull: true,
  codec: TYPES.int
}, {
  name: "c",
  required: false,
  notNull: true,
  codec: TYPES.int
}];
const extensions114 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "optional_missing_middle_4"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts101 = ["a", "optional_missing_middle_4"];
const sqlIdent101 = sql.identifier(...parts101);
const fromCallback51 = (...args) => sql`${sqlIdent101}(${sqlFromArgDigests(args)})`;
const parameters51 = [{
  name: "",
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: "b",
  required: false,
  notNull: true,
  codec: TYPES.int
}, {
  name: "",
  required: false,
  notNull: true,
  codec: TYPES.int
}];
const extensions115 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "optional_missing_middle_5"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts102 = ["a", "optional_missing_middle_5"];
const sqlIdent102 = sql.identifier(...parts102);
const fromCallback52 = (...args) => sql`${sqlIdent102}(${sqlFromArgDigests(args)})`;
const parameters52 = [{
  name: "a",
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: "",
  required: false,
  notNull: true,
  codec: TYPES.int
}, {
  name: "",
  required: false,
  notNull: true,
  codec: TYPES.int
}];
const extensions116 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_unnamed_out_out_unnamed"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts103 = ["c", "func_out_unnamed_out_out_unnamed"];
const sqlIdent103 = sql.identifier(...parts103);
const fromCallback53 = (...args) => sql`${sqlIdent103}(${sqlFromArgDigests(args)})`;
const parameters53 = [];
const extensions117 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_returns_table_multi_col"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts104 = ["c", "func_returns_table_multi_col"];
const sqlIdent104 = sql.identifier(...parts104);
const fromCallback54 = (...args) => sql`${sqlIdent104}(${sqlFromArgDigests(args)})`;
const parameters54 = [{
  name: "i",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions118 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "int_set_mutation"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts105 = ["c", "int_set_mutation"];
const sqlIdent105 = sql.identifier(...parts105);
const fromCallback55 = (...args) => sql`${sqlIdent105}(${sqlFromArgDigests(args)})`;
const parameters55 = [{
  name: "x",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "y",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "z",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions119 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "int_set_query"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts106 = ["c", "int_set_query"];
const sqlIdent106 = sql.identifier(...parts106);
const fromCallback56 = (...args) => sql`${sqlIdent106}(${sqlFromArgDigests(args)})`;
const parameters56 = [{
  name: "x",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "y",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "z",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions120 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_unnamed_out_out_unnamed"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts107 = ["c", "mutation_out_unnamed_out_out_unnamed"];
const sqlIdent107 = sql.identifier(...parts107);
const fromCallback57 = (...args) => sql`${sqlIdent107}(${sqlFromArgDigests(args)})`;
const parameters57 = [];
const extensions121 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_returns_table_multi_col"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts108 = ["c", "mutation_returns_table_multi_col"];
const sqlIdent108 = sql.identifier(...parts108);
const fromCallback58 = (...args) => sql`${sqlIdent108}(${sqlFromArgDigests(args)})`;
const parameters58 = [{
  name: "i",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions122 = {
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "guid_fn"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts109 = ["b", "guid_fn"];
const sqlIdent109 = sql.identifier(...parts109);
const fromCallback59 = (...args) => sql`${sqlIdent109}(${sqlFromArgDigests(args)})`;
const parameters59 = [{
  name: "g",
  required: true,
  notNull: false,
  codec: registryConfig_pgCodecs_bGuid_bGuid
}];
const extensions123 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "mutation_interval_array"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts110 = ["a", "mutation_interval_array"];
const sqlIdent110 = sql.identifier(...parts110);
const fromCallback60 = (...args) => sql`${sqlIdent110}(${sqlFromArgDigests(args)})`;
const parameters60 = [];
const extensions124 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "query_interval_array"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts111 = ["a", "query_interval_array"];
const sqlIdent111 = sql.identifier(...parts111);
const fromCallback61 = (...args) => sql`${sqlIdent111}(${sqlFromArgDigests(args)})`;
const parameters61 = [];
const extensions125 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "mutation_text_array"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts112 = ["a", "mutation_text_array"];
const sqlIdent112 = sql.identifier(...parts112);
const fromCallback62 = (...args) => sql`${sqlIdent112}(${sqlFromArgDigests(args)})`;
const parameters62 = [];
const extensions126 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "query_text_array"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts113 = ["a", "query_text_array"];
const sqlIdent113 = sql.identifier(...parts113);
const fromCallback63 = (...args) => sql`${sqlIdent113}(${sqlFromArgDigests(args)})`;
const parameters63 = [];
const extensions127 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "non_updatable_view"
  },
  tags: {
    behavior: ["-insert", "-update", "-delete"]
  }
};
const extensions128 = {
  description: "Should output as Input",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "inputs"
  },
  tags: {}
};
const uniques2 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions129 = {
  description: "Should output as Patch",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "patchs"
  },
  tags: {}
};
const uniques3 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions130 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "reserved"
  },
  tags: {}
};
const uniques4 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions131 = {
  description: "`reservedPatchs` table should get renamed to ReservedPatchRecord to prevent clashes with ReservedPatch from `reserved` table",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "reservedPatchs"
  },
  tags: {}
};
const uniques5 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions132 = {
  description: "`reserved_input` table should get renamed to ReservedInputRecord to prevent clashes with ReservedInput from `reserved` table",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "reserved_input"
  },
  tags: {}
};
const uniques6 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions133 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "default_value"
  },
  tags: {}
};
const uniques7 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions134 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "foreign_key"
  },
  tags: {}
};
const uniques8 = [];
const registryConfig_pgResources_foreign_key_foreign_key = {
  executor: executor_mainPgExecutor,
  name: "foreign_key",
  identifier: "main.a.foreign_key",
  from: registryConfig_pgCodecs_foreignKey_foreignKey.sqlType,
  codec: registryConfig_pgCodecs_foreignKey_foreignKey,
  uniques: uniques8,
  isVirtual: false,
  description: undefined,
  extensions: extensions134
};
const extensions135 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "no_primary_key"
  },
  tags: {}
};
const uniques9 = [{
  isPrimary: false,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions136 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "testview"
  },
  tags: {}
};
const uniques10 = [];
const extensions137 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "unique_foreign_key"
  },
  tags: {
    omit: "create,update,delete,all,order,filter"
  }
};
const uniques11 = [{
  isPrimary: false,
  attributes: ["compound_key_1", "compound_key_2"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_unique_foreign_key_unique_foreign_key = {
  executor: executor_mainPgExecutor,
  name: "unique_foreign_key",
  identifier: "main.a.unique_foreign_key",
  from: registryConfig_pgCodecs_uniqueForeignKey_uniqueForeignKey.sqlType,
  codec: registryConfig_pgCodecs_uniqueForeignKey_uniqueForeignKey,
  uniques: uniques11,
  isVirtual: false,
  description: undefined,
  extensions: extensions137
};
const extensions138 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "my_table"
  },
  tags: {}
};
const uniques12 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions139 = {
  description: "Tracks the person's secret",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_secret"
  },
  tags: {
    deprecated: "This is deprecated (comment on table c.person_secret)."
  }
};
const uniques13 = [{
  isPrimary: true,
  attributes: ["person_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_c_person_secret_c_person_secret = {
  executor: executor_mainPgExecutor,
  name: "c_person_secret",
  identifier: "main.c.person_secret",
  from: registryConfig_pgCodecs_cPersonSecret_cPersonSecret.sqlType,
  codec: registryConfig_pgCodecs_cPersonSecret_cPersonSecret,
  uniques: uniques13,
  isVirtual: false,
  description: "Tracks the person's secret",
  extensions: extensions139
};
const extensions140 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "view_table"
  },
  tags: {}
};
const uniques14 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions141 = {
  description: "YOYOYO!!",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "updatable_view"
  },
  tags: {
    uniqueKey: "x"
  }
};
const uniques15 = [];
const extensions142 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "compound_key"
  },
  tags: {}
};
const uniques16 = [{
  isPrimary: true,
  attributes: ["person_id_1", "person_id_2"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_c_compound_key_c_compound_key = {
  executor: executor_mainPgExecutor,
  name: "c_compound_key",
  identifier: "main.c.compound_key",
  from: registryConfig_pgCodecs_cCompoundKey_cCompoundKey.sqlType,
  codec: registryConfig_pgCodecs_cCompoundKey_cCompoundKey,
  uniques: uniques16,
  isVirtual: false,
  description: undefined,
  extensions: extensions142
};
const extensions143 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "similar_table_1"
  },
  tags: {}
};
const uniques17 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions144 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "similar_table_2"
  },
  tags: {}
};
const uniques18 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions145 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "null_test_record"
  },
  tags: {}
};
const uniques19 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions146 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "edge_case_computed"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts114 = ["c", "edge_case_computed"];
const sqlIdent114 = sql.identifier(...parts114);
const fromCallback64 = (...args) => sql`${sqlIdent114}(${sqlFromArgDigests(args)})`;
const parameters64 = [{
  name: "edge_case",
  required: true,
  notNull: false,
  codec: registryConfig_pgCodecs_cEdgeCase_cEdgeCase
}];
const parts115 = ["c", "return_table_without_grants"];
const sqlIdent115 = sql.identifier(...parts115);
const options_c_return_table_without_grants = {
  name: "c_return_table_without_grants",
  identifier: "main.c.return_table_without_grants()",
  from(...args) {
    return sql`${sqlIdent115}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "return_table_without_grants"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const extensions147 = {
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "list_bde_mutation"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts116 = ["b", "list_bde_mutation"];
const sqlIdent116 = sql.identifier(...parts116);
const fromCallback65 = (...args) => sql`${sqlIdent116}(${sqlFromArgDigests(args)})`;
const parameters65 = [{
  name: "b",
  required: true,
  notNull: false,
  codec: registryConfig_pgCodecs_pgCatalogTextArray_pgCatalogTextArray
}, {
  name: "d",
  required: true,
  notNull: false,
  codec: TYPES.text
}, {
  name: "e",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions148 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "edge_case"
  },
  tags: {}
};
const uniques20 = [];
const extensions149 = {
  description: "Tracks metadata about the left arms of various people",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "left_arm"
  },
  tags: {}
};
const uniques21 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}, {
  isPrimary: false,
  attributes: ["person_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_c_left_arm_c_left_arm = {
  executor: executor_mainPgExecutor,
  name: "c_left_arm",
  identifier: "main.c.left_arm",
  from: registryConfig_pgCodecs_cLeftArm_cLeftArm.sqlType,
  codec: registryConfig_pgCodecs_cLeftArm_cLeftArm,
  uniques: uniques21,
  isVirtual: false,
  description: "Tracks metadata about the left arms of various people",
  extensions: extensions149
};
const parts117 = ["b", "authenticate_fail"];
const sqlIdent117 = sql.identifier(...parts117);
const options_b_authenticate_fail = {
  name: "b_authenticate_fail",
  identifier: "main.b.authenticate_fail()",
  from(...args) {
    return sql`${sqlIdent117}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "authenticate_fail"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const extensions150 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "jwt_token"
  },
  tags: {
    behavior: ["-insert", "-update", "-delete"]
  }
};
const uniques22 = [];
const resourceConfig_b_jwt_token = {
  executor: executor_mainPgExecutor,
  name: "b_jwt_token",
  identifier: "main.b.jwt_token",
  from: registryConfig_pgCodecs_bJwtToken_bJwtToken.sqlType,
  codec: registryConfig_pgCodecs_bJwtToken_bJwtToken,
  uniques: uniques22,
  isVirtual: true,
  description: undefined,
  extensions: extensions150
};
const parts118 = ["b", "authenticate"];
const sqlIdent118 = sql.identifier(...parts118);
const options_b_authenticate = {
  name: "b_authenticate",
  identifier: "main.b.authenticate(int4,numeric,int8)",
  from(...args) {
    return sql`${sqlIdent118}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "a",
    required: true,
    notNull: false,
    codec: TYPES.int
  }, {
    name: "b",
    required: true,
    notNull: false,
    codec: TYPES.numeric
  }, {
    name: "c",
    required: true,
    notNull: false,
    codec: TYPES.bigint
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "authenticate"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const extensions151 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "issue756"
  },
  tags: {}
};
const uniques23 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_c_issue756_c_issue756 = {
  executor: executor_mainPgExecutor,
  name: "c_issue756",
  identifier: "main.c.issue756",
  from: registryConfig_pgCodecs_cIssue756_cIssue756.sqlType,
  codec: registryConfig_pgCodecs_cIssue756_cIssue756,
  uniques: uniques23,
  isVirtual: false,
  description: undefined,
  extensions: extensions151
};
const parts119 = ["c", "left_arm_identity"];
const sqlIdent119 = sql.identifier(...parts119);
const options_c_left_arm_identity = {
  name: "c_left_arm_identity",
  identifier: "main.c.left_arm_identity(c.left_arm)",
  from(...args) {
    return sql`${sqlIdent119}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "left_arm",
    required: true,
    notNull: false,
    codec: registryConfig_pgCodecs_cLeftArm_cLeftArm,
    extensions: {
      variant: "base"
    }
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "left_arm_identity"
    },
    tags: {
      arg0variant: "base",
      resultFieldName: "leftArm",
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts120 = ["c", "issue756_mutation"];
const sqlIdent120 = sql.identifier(...parts120);
const options_c_issue756_mutation = {
  name: "c_issue756_mutation",
  identifier: "main.c.issue756_mutation()",
  from(...args) {
    return sql`${sqlIdent120}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "issue756_mutation"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts121 = ["c", "issue756_set_mutation"];
const sqlIdent121 = sql.identifier(...parts121);
const options_c_issue756_set_mutation = {
  name: "c_issue756_set_mutation",
  identifier: "main.c.issue756_set_mutation()",
  from(...args) {
    return sql`${sqlIdent121}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "issue756_set_mutation"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts122 = ["b", "authenticate_many"];
const sqlIdent122 = sql.identifier(...parts122);
const options_b_authenticate_many = {
  name: "b_authenticate_many",
  identifier: "main.b.authenticate_many(int4,numeric,int8)",
  from(...args) {
    return sql`${sqlIdent122}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "a",
    required: true,
    notNull: false,
    codec: TYPES.int
  }, {
    name: "b",
    required: true,
    notNull: false,
    codec: TYPES.numeric
  }, {
    name: "c",
    required: true,
    notNull: false,
    codec: TYPES.bigint
  }],
  returnsArray: true,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "authenticate_many"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts123 = ["b", "authenticate_payload"];
const sqlIdent123 = sql.identifier(...parts123);
const options_b_authenticate_payload = {
  name: "b_authenticate_payload",
  identifier: "main.b.authenticate_payload(int4,numeric,int8)",
  from(...args) {
    return sql`${sqlIdent123}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "a",
    required: true,
    notNull: false,
    codec: TYPES.int
  }, {
    name: "b",
    required: true,
    notNull: false,
    codec: TYPES.numeric
  }, {
    name: "c",
    required: true,
    notNull: false,
    codec: TYPES.bigint
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "authenticate_payload"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const extensions152 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "auth_payload"
  },
  tags: {
    foreignKey: "(id) references c.person",
    behavior: ["-insert", "-update", "-delete"]
  }
};
const uniques24 = [];
const resourceConfig_b_auth_payload = {
  executor: executor_mainPgExecutor,
  name: "b_auth_payload",
  identifier: "main.b.auth_payload",
  from: registryConfig_pgCodecs_bAuthPayload_bAuthPayload.sqlType,
  codec: registryConfig_pgCodecs_bAuthPayload_bAuthPayload,
  uniques: uniques24,
  isVirtual: true,
  description: undefined,
  extensions: extensions152
};
const extensions153 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "types_mutation"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts124 = ["c", "types_mutation"];
const sqlIdent124 = sql.identifier(...parts124);
const fromCallback66 = (...args) => sql`${sqlIdent124}(${sqlFromArgDigests(args)})`;
const parameters66 = [{
  name: "a",
  required: true,
  notNull: true,
  codec: TYPES.bigint
}, {
  name: "b",
  required: true,
  notNull: true,
  codec: TYPES.boolean
}, {
  name: "c",
  required: true,
  notNull: true,
  codec: TYPES.varchar
}, {
  name: "d",
  required: true,
  notNull: true,
  codec: registryConfig_pgCodecs_pgCatalogInt4Array_pgCatalogInt4Array
}, {
  name: "e",
  required: true,
  notNull: true,
  codec: TYPES.json
}, {
  name: "f",
  required: true,
  notNull: true,
  codec: registryConfig_pgCodecs_cFloatrange_cFloatrange
}];
const extensions154 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "types_query"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts125 = ["c", "types_query"];
const sqlIdent125 = sql.identifier(...parts125);
const fromCallback67 = (...args) => sql`${sqlIdent125}(${sqlFromArgDigests(args)})`;
const parameters67 = [{
  name: "a",
  required: true,
  notNull: true,
  codec: TYPES.bigint
}, {
  name: "b",
  required: true,
  notNull: true,
  codec: TYPES.boolean
}, {
  name: "c",
  required: true,
  notNull: true,
  codec: TYPES.varchar
}, {
  name: "d",
  required: true,
  notNull: true,
  codec: registryConfig_pgCodecs_pgCatalogInt4Array_pgCatalogInt4Array
}, {
  name: "e",
  required: true,
  notNull: true,
  codec: TYPES.json
}, {
  name: "f",
  required: true,
  notNull: true,
  codec: registryConfig_pgCodecs_cFloatrange_cFloatrange
}];
const extensions155 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "compound_type_computed_field"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts126 = ["c", "compound_type_computed_field"];
const sqlIdent126 = sql.identifier(...parts126);
const fromCallback68 = (...args) => sql`${sqlIdent126}(${sqlFromArgDigests(args)})`;
const parameters68 = [{
  name: "compound_type",
  required: true,
  notNull: false,
  codec: attributes_o2_codec_cCompoundType
}];
const extensions156 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post_computed_interval_set"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts127 = ["a", "post_computed_interval_set"];
const sqlIdent127 = sql.identifier(...parts127);
const fromCallback69 = (...args) => sql`${sqlIdent127}(${sqlFromArgDigests(args)})`;
const parameters69 = [{
  name: "post",
  required: true,
  notNull: false,
  codec: attributes_post_codec_post
}];
const extensions157 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post_computed_interval_array"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts128 = ["a", "post_computed_interval_array"];
const sqlIdent128 = sql.identifier(...parts128);
const fromCallback70 = (...args) => sql`${sqlIdent128}(${sqlFromArgDigests(args)})`;
const parameters70 = [{
  name: "post",
  required: true,
  notNull: false,
  codec: attributes_post_codec_post
}];
const extensions158 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post_computed_text_array"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts129 = ["a", "post_computed_text_array"];
const sqlIdent129 = sql.identifier(...parts129);
const fromCallback71 = (...args) => sql`${sqlIdent129}(${sqlFromArgDigests(args)})`;
const parameters71 = [{
  name: "post",
  required: true,
  notNull: false,
  codec: attributes_post_codec_post
}];
const extensions159 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post_computed_with_optional_arg"
  },
  tags: {
    sortable: true,
    filterable: true,
    behavior: ["-filter -order"]
  }
};
const parts130 = ["a", "post_computed_with_optional_arg"];
const sqlIdent130 = sql.identifier(...parts130);
const fromCallback72 = (...args) => sql`${sqlIdent130}(${sqlFromArgDigests(args)})`;
const parameters72 = [{
  name: "post",
  required: true,
  notNull: true,
  codec: attributes_post_codec_post
}, {
  name: "i",
  required: false,
  notNull: true,
  codec: TYPES.int
}];
const extensions160 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post_computed_with_required_arg"
  },
  tags: {
    sortable: true,
    filterable: true,
    behavior: ["-filter -order"]
  }
};
const parts131 = ["a", "post_computed_with_required_arg"];
const sqlIdent131 = sql.identifier(...parts131);
const fromCallback73 = (...args) => sql`${sqlIdent131}(${sqlFromArgDigests(args)})`;
const parameters73 = [{
  name: "post",
  required: true,
  notNull: true,
  codec: attributes_post_codec_post
}, {
  name: "i",
  required: true,
  notNull: true,
  codec: TYPES.int
}];
const extensions161 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_out_compound_type"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts132 = ["c", "func_out_out_compound_type"];
const sqlIdent132 = sql.identifier(...parts132);
const fromCallback74 = (...args) => sql`${sqlIdent132}(${sqlFromArgDigests(args)})`;
const parameters74 = [{
  name: "i1",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions162 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_out_compound_type"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts133 = ["c", "mutation_out_out_compound_type"];
const sqlIdent133 = sql.identifier(...parts133);
const fromCallback75 = (...args) => sql`${sqlIdent133}(${sqlFromArgDigests(args)})`;
const parameters75 = [{
  name: "i1",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions163 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post_headline_trimmed"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts134 = ["a", "post_headline_trimmed"];
const sqlIdent134 = sql.identifier(...parts134);
const fromCallback76 = (...args) => sql`${sqlIdent134}(${sqlFromArgDigests(args)})`;
const parameters76 = [{
  name: "post",
  required: true,
  notNull: false,
  codec: attributes_post_codec_post
}, {
  name: "length",
  required: false,
  notNull: false,
  codec: TYPES.int
}, {
  name: "omission",
  required: false,
  notNull: false,
  codec: TYPES.text
}];
const extensions164 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post_headline_trimmed_no_defaults"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts135 = ["a", "post_headline_trimmed_no_defaults"];
const sqlIdent135 = sql.identifier(...parts135);
const fromCallback77 = (...args) => sql`${sqlIdent135}(${sqlFromArgDigests(args)})`;
const parameters77 = [{
  name: "post",
  required: true,
  notNull: false,
  codec: attributes_post_codec_post
}, {
  name: "length",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "omission",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions165 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post_headline_trimmed_strict"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts136 = ["a", "post_headline_trimmed_strict"];
const sqlIdent136 = sql.identifier(...parts136);
const fromCallback78 = (...args) => sql`${sqlIdent136}(${sqlFromArgDigests(args)})`;
const parameters78 = [{
  name: "post",
  required: true,
  notNull: true,
  codec: attributes_post_codec_post
}, {
  name: "length",
  required: false,
  notNull: true,
  codec: TYPES.int
}, {
  name: "omission",
  required: false,
  notNull: true,
  codec: TYPES.text
}];
const extensions166 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "query_output_two_rows"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts137 = ["c", "query_output_two_rows"];
const sqlIdent137 = sql.identifier(...parts137);
const fromCallback79 = (...args) => sql`${sqlIdent137}(${sqlFromArgDigests(args)})`;
const parameters79 = [{
  name: "left_arm_id",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "post_id",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "txt",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions167 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post"
  },
  tags: {}
};
const uniques25 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_post_post = {
  executor: executor_mainPgExecutor,
  name: "post",
  identifier: "main.a.post",
  from: attributes_post_codec_post.sqlType,
  codec: attributes_post_codec_post,
  uniques: uniques25,
  isVirtual: false,
  description: undefined,
  extensions: extensions167
};
const parts138 = ["c", "compound_type_set_query"];
const sqlIdent138 = sql.identifier(...parts138);
const options_c_compound_type_set_query = {
  name: "c_compound_type_set_query",
  identifier: "main.c.compound_type_set_query()",
  from(...args) {
    return sql`${sqlIdent138}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "compound_type_set_query"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const extensions168 = {
  description: "Awesome feature!",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "compound_type"
  },
  tags: {
    behavior: ["-insert", "-update", "-delete"]
  }
};
const uniques26 = [];
const resourceConfig_c_compound_type = {
  executor: executor_mainPgExecutor,
  name: "c_compound_type",
  identifier: "main.c.compound_type",
  from: attributes_o2_codec_cCompoundType.sqlType,
  codec: attributes_o2_codec_cCompoundType,
  uniques: uniques26,
  isVirtual: true,
  description: "Awesome feature!",
  extensions: extensions168
};
const parts139 = ["b", "compound_type_mutation"];
const sqlIdent139 = sql.identifier(...parts139);
const options_b_compound_type_mutation = {
  name: "b_compound_type_mutation",
  identifier: "main.b.compound_type_mutation(c.compound_type)",
  from(...args) {
    return sql`${sqlIdent139}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "object",
    required: true,
    notNull: false,
    codec: attributes_o2_codec_cCompoundType
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "compound_type_mutation"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts140 = ["b", "compound_type_query"];
const sqlIdent140 = sql.identifier(...parts140);
const options_b_compound_type_query = {
  name: "b_compound_type_query",
  identifier: "main.b.compound_type_query(c.compound_type)",
  from(...args) {
    return sql`${sqlIdent140}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "object",
    required: true,
    notNull: false,
    codec: attributes_o2_codec_cCompoundType
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "compound_type_query"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts141 = ["b", "compound_type_set_mutation"];
const sqlIdent141 = sql.identifier(...parts141);
const options_b_compound_type_set_mutation = {
  name: "b_compound_type_set_mutation",
  identifier: "main.b.compound_type_set_mutation(c.compound_type)",
  from(...args) {
    return sql`${sqlIdent141}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "object",
    required: true,
    notNull: false,
    codec: attributes_o2_codec_cCompoundType
  }],
  returnsArray: false,
  returnsSetof: true,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "compound_type_set_mutation"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts142 = ["c", "table_mutation"];
const sqlIdent142 = sql.identifier(...parts142);
const options_c_table_mutation = {
  name: "c_table_mutation",
  identifier: "main.c.table_mutation(int4)",
  from(...args) {
    return sql`${sqlIdent142}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "id",
    required: true,
    notNull: false,
    codec: TYPES.int
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "table_mutation"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts143 = ["c", "table_query"];
const sqlIdent143 = sql.identifier(...parts143);
const options_c_table_query = {
  name: "c_table_query",
  identifier: "main.c.table_query(int4)",
  from(...args) {
    return sql`${sqlIdent143}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "id",
    required: true,
    notNull: false,
    codec: TYPES.int
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "table_query"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts144 = ["a", "post_with_suffix"];
const sqlIdent144 = sql.identifier(...parts144);
const options_post_with_suffix = {
  name: "post_with_suffix",
  identifier: "main.a.post_with_suffix(a.post,text)",
  from(...args) {
    return sql`${sqlIdent144}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "post",
    required: true,
    notNull: false,
    codec: attributes_post_codec_post
  }, {
    name: "suffix",
    required: true,
    notNull: false,
    codec: TYPES.text
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "a",
      name: "post_with_suffix"
    },
    tags: {
      deprecated: "This is deprecated (comment on function a.post_with_suffix).",
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts145 = ["a", "mutation_compound_type_array"];
const sqlIdent145 = sql.identifier(...parts145);
const options_mutation_compound_type_array = {
  name: "mutation_compound_type_array",
  identifier: "main.a.mutation_compound_type_array(c.compound_type)",
  from(...args) {
    return sql`${sqlIdent145}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "object",
    required: true,
    notNull: false,
    codec: attributes_o2_codec_cCompoundType
  }],
  returnsArray: true,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "a",
      name: "mutation_compound_type_array"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts146 = ["a", "query_compound_type_array"];
const sqlIdent146 = sql.identifier(...parts146);
const options_query_compound_type_array = {
  name: "query_compound_type_array",
  identifier: "main.a.query_compound_type_array(c.compound_type)",
  from(...args) {
    return sql`${sqlIdent146}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "object",
    required: true,
    notNull: false,
    codec: attributes_o2_codec_cCompoundType
  }],
  returnsArray: true,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "a",
      name: "query_compound_type_array"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts147 = ["b", "compound_type_array_mutation"];
const sqlIdent147 = sql.identifier(...parts147);
const options_b_compound_type_array_mutation = {
  name: "b_compound_type_array_mutation",
  identifier: "main.b.compound_type_array_mutation(c.compound_type)",
  from(...args) {
    return sql`${sqlIdent147}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "object",
    required: true,
    notNull: false,
    codec: attributes_o2_codec_cCompoundType
  }],
  returnsArray: true,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "compound_type_array_mutation"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts148 = ["b", "compound_type_array_query"];
const sqlIdent148 = sql.identifier(...parts148);
const options_b_compound_type_array_query = {
  name: "b_compound_type_array_query",
  identifier: "main.b.compound_type_array_query(c.compound_type)",
  from(...args) {
    return sql`${sqlIdent148}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "object",
    required: true,
    notNull: false,
    codec: attributes_o2_codec_cCompoundType
  }],
  returnsArray: true,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "compound_type_array_query"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts149 = ["a", "post_computed_compound_type_array"];
const sqlIdent149 = sql.identifier(...parts149);
const options_post_computed_compound_type_array = {
  name: "post_computed_compound_type_array",
  identifier: "main.a.post_computed_compound_type_array(a.post,c.compound_type)",
  from(...args) {
    return sql`${sqlIdent149}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "post",
    required: true,
    notNull: false,
    codec: attributes_post_codec_post
  }, {
    name: "object",
    required: true,
    notNull: false,
    codec: attributes_o2_codec_cCompoundType
  }],
  returnsArray: true,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "a",
      name: "post_computed_compound_type_array"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts150 = ["a", "post_many"];
const sqlIdent150 = sql.identifier(...parts150);
const options_post_many = {
  name: "post_many",
  identifier: "main.a.post_many(a._post)",
  from(...args) {
    return sql`${sqlIdent150}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "posts",
    required: true,
    notNull: false,
    codec: registryConfig_pgCodecs_postArray_postArray
  }],
  returnsArray: false,
  returnsSetof: true,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "a",
      name: "post_many"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const extensions169 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_computed_out"
  },
  tags: {
    notNull: true,
    sortable: true,
    filterable: true,
    behavior: ["-filter -order"]
  },
  singleOutputParameterName: "o1"
};
const parts151 = ["c", "person_computed_out"];
const sqlIdent151 = sql.identifier(...parts151);
const fromCallback80 = (...args) => sql`${sqlIdent151}(${sqlFromArgDigests(args)})`;
const parameters80 = [{
  name: "person",
  required: true,
  notNull: false,
  codec: attributes_person_codec_cPerson
}];
const extensions170 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_first_name"
  },
  tags: {
    sortable: true,
    behavior: ["-filter -order"]
  }
};
const parts152 = ["c", "person_first_name"];
const sqlIdent152 = sql.identifier(...parts152);
const fromCallback81 = (...args) => sql`${sqlIdent152}(${sqlFromArgDigests(args)})`;
const parameters81 = [{
  name: "person",
  required: true,
  notNull: false,
  codec: attributes_person_codec_cPerson
}];
const extensions171 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_computed_out_out"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts153 = ["c", "person_computed_out_out"];
const sqlIdent153 = sql.identifier(...parts153);
const fromCallback82 = (...args) => sql`${sqlIdent153}(${sqlFromArgDigests(args)})`;
const parameters82 = [{
  name: "person",
  required: true,
  notNull: false,
  codec: attributes_person_codec_cPerson
}];
const extensions172 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_computed_inout"
  },
  tags: {
    behavior: ["-filter -order"]
  },
  singleOutputParameterName: "ino"
};
const parts154 = ["c", "person_computed_inout"];
const sqlIdent154 = sql.identifier(...parts154);
const fromCallback83 = (...args) => sql`${sqlIdent154}(${sqlFromArgDigests(args)})`;
const parameters83 = [{
  name: "person",
  required: true,
  notNull: false,
  codec: attributes_person_codec_cPerson
}, {
  name: "ino",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions173 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_computed_inout_out"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts155 = ["c", "person_computed_inout_out"];
const sqlIdent155 = sql.identifier(...parts155);
const fromCallback84 = (...args) => sql`${sqlIdent155}(${sqlFromArgDigests(args)})`;
const parameters84 = [{
  name: "person",
  required: true,
  notNull: false,
  codec: attributes_person_codec_cPerson
}, {
  name: "ino",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions174 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_exists"
  },
  tags: {
    deprecated: "This is deprecated (comment on function c.person_exists).",
    behavior: ["-filter -order"]
  }
};
const parts156 = ["c", "person_exists"];
const sqlIdent156 = sql.identifier(...parts156);
const fromCallback85 = (...args) => sql`${sqlIdent156}(${sqlFromArgDigests(args)})`;
const parameters85 = [{
  name: "person",
  required: true,
  notNull: false,
  codec: attributes_person_codec_cPerson
}, {
  name: "email",
  required: true,
  notNull: false,
  codec: attributes_email_codec_bEmail
}];
const extensions175 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_computed_first_arg_inout_out"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts157 = ["c", "person_computed_first_arg_inout_out"];
const sqlIdent157 = sql.identifier(...parts157);
const fromCallback86 = (...args) => sql`${sqlIdent157}(${sqlFromArgDigests(args)})`;
const parameters86 = [{
  name: "person",
  required: true,
  notNull: false,
  codec: attributes_person_codec_cPerson
}];
const extensions176 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_complex"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts158 = ["c", "func_out_complex"];
const sqlIdent158 = sql.identifier(...parts158);
const fromCallback87 = (...args) => sql`${sqlIdent158}(${sqlFromArgDigests(args)})`;
const parameters87 = [{
  name: "a",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "b",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions177 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_complex_setof"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts159 = ["c", "func_out_complex_setof"];
const sqlIdent159 = sql.identifier(...parts159);
const fromCallback88 = (...args) => sql`${sqlIdent159}(${sqlFromArgDigests(args)})`;
const parameters88 = [{
  name: "a",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "b",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions178 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_complex"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts160 = ["c", "mutation_out_complex"];
const sqlIdent160 = sql.identifier(...parts160);
const fromCallback89 = (...args) => sql`${sqlIdent160}(${sqlFromArgDigests(args)})`;
const parameters89 = [{
  name: "a",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "b",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions179 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_complex_setof"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts161 = ["c", "mutation_out_complex_setof"];
const sqlIdent161 = sql.identifier(...parts161);
const fromCallback90 = (...args) => sql`${sqlIdent161}(${sqlFromArgDigests(args)})`;
const parameters90 = [{
  name: "a",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "b",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions180 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_computed_complex"
  },
  tags: {
    behavior: ["-filter -order"]
  }
};
const parts162 = ["c", "person_computed_complex"];
const sqlIdent162 = sql.identifier(...parts162);
const fromCallback91 = (...args) => sql`${sqlIdent162}(${sqlFromArgDigests(args)})`;
const parameters91 = [{
  name: "person",
  required: true,
  notNull: false,
  codec: attributes_person_codec_cPerson
}, {
  name: "a",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "b",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const parts163 = ["c", "person_first_post"];
const sqlIdent163 = sql.identifier(...parts163);
const options_c_person_first_post = {
  name: "c_person_first_post",
  identifier: "main.c.person_first_post(c.person)",
  from(...args) {
    return sql`${sqlIdent163}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "person",
    required: true,
    notNull: false,
    codec: attributes_person_codec_cPerson
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "person_first_post"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: "The first post by the person."
};
const extensions181 = {
  description: "Person test comment",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person"
  },
  tags: {}
};
const uniques27 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}, {
  isPrimary: false,
  attributes: ["email"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_c_person_c_person = {
  executor: executor_mainPgExecutor,
  name: "c_person",
  identifier: "main.c.person",
  from: attributes_person_codec_cPerson.sqlType,
  codec: attributes_person_codec_cPerson,
  uniques: uniques27,
  isVirtual: false,
  description: "Person test comment",
  extensions: extensions181
};
const parts164 = ["c", "badly_behaved_function"];
const sqlIdent164 = sql.identifier(...parts164);
const options_c_badly_behaved_function = {
  name: "c_badly_behaved_function",
  identifier: "main.c.badly_behaved_function()",
  from(...args) {
    return sql`${sqlIdent164}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "badly_behaved_function"
    },
    tags: {
      deprecated: "This is deprecated (comment on function c.badly_behaved_function).",
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts165 = ["c", "func_out_table"];
const sqlIdent165 = sql.identifier(...parts165);
const options_c_func_out_table = {
  name: "c_func_out_table",
  identifier: "main.c.func_out_table(c.person)",
  from(...args) {
    return sql`${sqlIdent165}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "func_out_table"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts166 = ["c", "func_out_table_setof"];
const sqlIdent166 = sql.identifier(...parts166);
const options_c_func_out_table_setof = {
  name: "c_func_out_table_setof",
  identifier: "main.c.func_out_table_setof(c.person)",
  from(...args) {
    return sql`${sqlIdent166}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "func_out_table_setof"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts167 = ["c", "mutation_out_table"];
const sqlIdent167 = sql.identifier(...parts167);
const options_c_mutation_out_table = {
  name: "c_mutation_out_table",
  identifier: "main.c.mutation_out_table(c.person)",
  from(...args) {
    return sql`${sqlIdent167}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "mutation_out_table"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts168 = ["c", "mutation_out_table_setof"];
const sqlIdent168 = sql.identifier(...parts168);
const options_c_mutation_out_table_setof = {
  name: "c_mutation_out_table_setof",
  identifier: "main.c.mutation_out_table_setof(c.person)",
  from(...args) {
    return sql`${sqlIdent168}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "mutation_out_table_setof"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts169 = ["c", "table_set_mutation"];
const sqlIdent169 = sql.identifier(...parts169);
const options_c_table_set_mutation = {
  name: "c_table_set_mutation",
  identifier: "main.c.table_set_mutation()",
  from(...args) {
    return sql`${sqlIdent169}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "table_set_mutation"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts170 = ["c", "table_set_query"];
const sqlIdent170 = sql.identifier(...parts170);
const options_c_table_set_query = {
  name: "c_table_set_query",
  identifier: "main.c.table_set_query()",
  from(...args) {
    return sql`${sqlIdent170}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "table_set_query"
    },
    tags: {
      sortable: true,
      filterable: true,
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts171 = ["c", "table_set_query_plpgsql"];
const sqlIdent171 = sql.identifier(...parts171);
const options_c_table_set_query_plpgsql = {
  name: "c_table_set_query_plpgsql",
  identifier: "main.c.table_set_query_plpgsql()",
  from(...args) {
    return sql`${sqlIdent171}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "table_set_query_plpgsql"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts172 = ["c", "person_computed_first_arg_inout"];
const sqlIdent172 = sql.identifier(...parts172);
const options_c_person_computed_first_arg_inout = {
  name: "c_person_computed_first_arg_inout",
  identifier: "main.c.person_computed_first_arg_inout(c.person)",
  from(...args) {
    return sql`${sqlIdent172}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "person",
    required: true,
    notNull: false,
    codec: attributes_person_codec_cPerson
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "person_computed_first_arg_inout"
    },
    tags: {
      behavior: ["-filter -order"]
    },
    singleOutputParameterName: "person"
  },
  description: undefined
};
const parts173 = ["c", "person_friends"];
const sqlIdent173 = sql.identifier(...parts173);
const options_c_person_friends = {
  name: "c_person_friends",
  identifier: "main.c.person_friends(c.person)",
  from(...args) {
    return sql`${sqlIdent173}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "person",
    required: true,
    notNull: false,
    codec: attributes_person_codec_cPerson
  }],
  returnsArray: false,
  returnsSetof: true,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "person_friends"
    },
    tags: {
      sortable: true,
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const extensions182 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "types"
  },
  tags: {
    foreignKey: extensions54.tags.foreignKey
  }
};
const uniques28 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_b_types_b_types = {
  executor: executor_mainPgExecutor,
  name: "b_types",
  identifier: "main.b.types",
  from: registryConfig_pgCodecs_bTypes_bTypes.sqlType,
  codec: registryConfig_pgCodecs_bTypes_bTypes,
  uniques: uniques28,
  isVirtual: false,
  description: undefined,
  extensions: extensions182
};
const parts174 = ["b", "type_function_connection"];
const sqlIdent174 = sql.identifier(...parts174);
const options_b_type_function_connection = {
  name: "b_type_function_connection",
  identifier: "main.b.type_function_connection()",
  from(...args) {
    return sql`${sqlIdent174}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "type_function_connection"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts175 = ["b", "type_function_connection_mutation"];
const sqlIdent175 = sql.identifier(...parts175);
const options_b_type_function_connection_mutation = {
  name: "b_type_function_connection_mutation",
  identifier: "main.b.type_function_connection_mutation()",
  from(...args) {
    return sql`${sqlIdent175}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "type_function_connection_mutation"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts176 = ["b", "type_function"];
const sqlIdent176 = sql.identifier(...parts176);
const options_b_type_function = {
  name: "b_type_function",
  identifier: "main.b.type_function(int4)",
  from(...args) {
    return sql`${sqlIdent176}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "id",
    required: true,
    notNull: false,
    codec: TYPES.int
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "type_function"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts177 = ["b", "type_function_mutation"];
const sqlIdent177 = sql.identifier(...parts177);
const options_b_type_function_mutation = {
  name: "b_type_function_mutation",
  identifier: "main.b.type_function_mutation(int4)",
  from(...args) {
    return sql`${sqlIdent177}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "id",
    required: true,
    notNull: false,
    codec: TYPES.int
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "type_function_mutation"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts178 = ["c", "person_type_function_connection"];
const sqlIdent178 = sql.identifier(...parts178);
const options_c_person_type_function_connection = {
  name: "c_person_type_function_connection",
  identifier: "main.c.person_type_function_connection(c.person)",
  from(...args) {
    return sql`${sqlIdent178}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "p",
    required: true,
    notNull: false,
    codec: attributes_person_codec_cPerson
  }],
  returnsArray: false,
  returnsSetof: true,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "person_type_function_connection"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts179 = ["c", "person_type_function"];
const sqlIdent179 = sql.identifier(...parts179);
const options_c_person_type_function = {
  name: "c_person_type_function",
  identifier: "main.c.person_type_function(c.person,int4)",
  from(...args) {
    return sql`${sqlIdent179}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "p",
    required: true,
    notNull: false,
    codec: attributes_person_codec_cPerson
  }, {
    name: "id",
    required: true,
    notNull: false,
    codec: TYPES.int
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "person_type_function"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts180 = ["b", "type_function_list"];
const sqlIdent180 = sql.identifier(...parts180);
const options_b_type_function_list = {
  name: "b_type_function_list",
  identifier: "main.b.type_function_list()",
  from(...args) {
    return sql`${sqlIdent180}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: true,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "type_function_list"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts181 = ["b", "type_function_list_mutation"];
const sqlIdent181 = sql.identifier(...parts181);
const options_b_type_function_list_mutation = {
  name: "b_type_function_list_mutation",
  identifier: "main.b.type_function_list_mutation()",
  from(...args) {
    return sql`${sqlIdent181}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: true,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "type_function_list_mutation"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const parts182 = ["c", "person_type_function_list"];
const sqlIdent182 = sql.identifier(...parts182);
const options_c_person_type_function_list = {
  name: "c_person_type_function_list",
  identifier: "main.c.person_type_function_list(c.person)",
  from(...args) {
    return sql`${sqlIdent182}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "p",
    required: true,
    notNull: false,
    codec: attributes_person_codec_cPerson
  }],
  returnsArray: true,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "person_type_function_list"
    },
    tags: {
      behavior: ["-filter -order"]
    }
  },
  description: undefined
};
const registry = makeRegistry({
  pgCodecs: Object.assign(Object.create(null), {
    int4: TYPES.int,
    void: TYPES.void,
    interval: TYPES.interval,
    int8: TYPES.bigint,
    json: TYPES.json,
    jsonb: TYPES.jsonb,
    CFuncOutOutRecord: registryConfig_pgCodecs_CFuncOutOutRecord_CFuncOutOutRecord,
    text: TYPES.text,
    CFuncOutOutSetofRecord: registryConfig_pgCodecs_CFuncOutOutSetofRecord_CFuncOutOutSetofRecord,
    CFuncOutOutUnnamedRecord: registryConfig_pgCodecs_CFuncOutOutUnnamedRecord_CFuncOutOutUnnamedRecord,
    CMutationOutOutRecord: registryConfig_pgCodecs_CMutationOutOutRecord_CMutationOutOutRecord,
    CMutationOutOutSetofRecord: registryConfig_pgCodecs_CMutationOutOutSetofRecord_CMutationOutOutSetofRecord,
    CMutationOutOutUnnamedRecord: registryConfig_pgCodecs_CMutationOutOutUnnamedRecord_CMutationOutOutUnnamedRecord,
    CSearchTestSummariesRecord: registryConfig_pgCodecs_CSearchTestSummariesRecord_CSearchTestSummariesRecord,
    CFuncOutUnnamedOutOutUnnamedRecord: registryConfig_pgCodecs_CFuncOutUnnamedOutOutUnnamedRecord_CFuncOutUnnamedOutOutUnnamedRecord,
    CFuncReturnsTableMultiColRecord: registryConfig_pgCodecs_CFuncReturnsTableMultiColRecord_CFuncReturnsTableMultiColRecord,
    CMutationOutUnnamedOutOutUnnamedRecord: registryConfig_pgCodecs_CMutationOutUnnamedOutOutUnnamedRecord_CMutationOutUnnamedOutOutUnnamedRecord,
    CMutationReturnsTableMultiColRecord: registryConfig_pgCodecs_CMutationReturnsTableMultiColRecord_CMutationReturnsTableMultiColRecord,
    bGuid: registryConfig_pgCodecs_bGuid_bGuid,
    varchar: TYPES.varchar,
    pgCatalogIntervalArray: registryConfig_pgCodecs_pgCatalogIntervalArray_pgCatalogIntervalArray,
    pgCatalogTextArray: registryConfig_pgCodecs_pgCatalogTextArray_pgCatalogTextArray,
    nonUpdatableView: registryConfig_pgCodecs_nonUpdatableView_nonUpdatableView,
    inputs: registryConfig_pgCodecs_inputs_inputs,
    patchs: registryConfig_pgCodecs_patchs_patchs,
    reserved: registryConfig_pgCodecs_reserved_reserved,
    reservedPatchs: registryConfig_pgCodecs_reservedPatchs_reservedPatchs,
    reservedInput: registryConfig_pgCodecs_reservedInput_reservedInput,
    defaultValue: registryConfig_pgCodecs_defaultValue_defaultValue,
    foreignKey: registryConfig_pgCodecs_foreignKey_foreignKey,
    noPrimaryKey: registryConfig_pgCodecs_noPrimaryKey_noPrimaryKey,
    testview: registryConfig_pgCodecs_testview_testview,
    uniqueForeignKey: registryConfig_pgCodecs_uniqueForeignKey_uniqueForeignKey,
    cMyTable: registryConfig_pgCodecs_cMyTable_cMyTable,
    cPersonSecret: registryConfig_pgCodecs_cPersonSecret_cPersonSecret,
    viewTable: registryConfig_pgCodecs_viewTable_viewTable,
    bUpdatableView: registryConfig_pgCodecs_bUpdatableView_bUpdatableView,
    cCompoundKey: registryConfig_pgCodecs_cCompoundKey_cCompoundKey,
    bool: TYPES.boolean,
    similarTable1: registryConfig_pgCodecs_similarTable1_similarTable1,
    similarTable2: registryConfig_pgCodecs_similarTable2_similarTable2,
    cNullTestRecord: registryConfig_pgCodecs_cNullTestRecord_cNullTestRecord,
    pgCatalogUuidArray: registryConfig_pgCodecs_pgCatalogUuidArray_pgCatalogUuidArray,
    uuid: TYPES.uuid,
    cEdgeCase: registryConfig_pgCodecs_cEdgeCase_cEdgeCase,
    int2: TYPES.int2,
    cLeftArm: registryConfig_pgCodecs_cLeftArm_cLeftArm,
    float8: TYPES.float,
    bJwtToken: registryConfig_pgCodecs_bJwtToken_bJwtToken,
    numeric: TYPES.numeric,
    cIssue756: registryConfig_pgCodecs_cIssue756_cIssue756,
    cNotNullTimestamp: attributes_ts_codec_cNotNullTimestamp,
    timestamptz: TYPES.timestamptz,
    bAuthPayload: registryConfig_pgCodecs_bAuthPayload_bAuthPayload,
    CFuncOutOutCompoundTypeRecord: registryConfig_pgCodecs_CFuncOutOutCompoundTypeRecord_CFuncOutOutCompoundTypeRecord,
    cCompoundType: attributes_o2_codec_cCompoundType,
    bColor: attributes_c_codec_bColor,
    bEnumCaps: attributes_e_codec_bEnumCaps,
    bEnumWithEmptyString: attributes_f_codec_bEnumWithEmptyString,
    CMutationOutOutCompoundTypeRecord: registryConfig_pgCodecs_CMutationOutOutCompoundTypeRecord_CMutationOutOutCompoundTypeRecord,
    CQueryOutputTwoRowsRecord: registryConfig_pgCodecs_CQueryOutputTwoRowsRecord_CQueryOutputTwoRowsRecord,
    post: attributes_post_codec_post,
    anEnumArray: attributes_enums_codec_anEnumArray,
    anEnum: innerCodec_anEnum,
    comptypeArray: attributes_comptypes_codec_comptypeArray,
    comptype: innerCodec_comptype,
    CPersonComputedOutOutRecord: registryConfig_pgCodecs_CPersonComputedOutOutRecord_CPersonComputedOutOutRecord,
    CPersonComputedInoutOutRecord: registryConfig_pgCodecs_CPersonComputedInoutOutRecord_CPersonComputedInoutOutRecord,
    CPersonComputedFirstArgInoutOutRecord: registryConfig_pgCodecs_CPersonComputedFirstArgInoutOutRecord_CPersonComputedFirstArgInoutOutRecord,
    cPerson: attributes_person_codec_cPerson,
    bEmail: attributes_email_codec_bEmail,
    bWrappedUrl: attributes_site_codec_bWrappedUrl,
    bNotNullUrl: attributes_url_codec_bNotNullUrl,
    hstore: TYPES.hstore,
    inet: TYPES.inet,
    cidr: TYPES.cidr,
    macaddr: TYPES.macaddr,
    timestamp: TYPES.timestamp,
    CFuncOutComplexRecord: registryConfig_pgCodecs_CFuncOutComplexRecord_CFuncOutComplexRecord,
    CFuncOutComplexSetofRecord: registryConfig_pgCodecs_CFuncOutComplexSetofRecord_CFuncOutComplexSetofRecord,
    CMutationOutComplexRecord: registryConfig_pgCodecs_CMutationOutComplexRecord_CMutationOutComplexRecord,
    CMutationOutComplexSetofRecord: registryConfig_pgCodecs_CMutationOutComplexSetofRecord_CMutationOutComplexSetofRecord,
    CPersonComputedComplexRecord: registryConfig_pgCodecs_CPersonComputedComplexRecord_CPersonComputedComplexRecord,
    bTypes: registryConfig_pgCodecs_bTypes_bTypes,
    bColorArray: attributes_enum_array_codec_bColorArray,
    anInt: attributes_domain_codec_anInt,
    bAnotherInt: attributes_domain2_codec_bAnotherInt,
    pgCatalogNumrange: attributes_nullable_range_codec_pgCatalogNumrange,
    pgCatalogDaterange: attributes_daterange_codec_pgCatalogDaterange,
    date: TYPES.date,
    anIntRange: attributes_an_int_range_codec_anIntRange,
    time: TYPES.time,
    timetz: TYPES.timetz,
    money: TYPES.money,
    bNestedCompoundType: attributes_nested_compound_type_codec_bNestedCompoundType,
    point: TYPES.point,
    regproc: TYPES.regproc,
    regprocedure: TYPES.regprocedure,
    regoper: TYPES.regoper,
    regoperator: TYPES.regoperator,
    regclass: TYPES.regclass,
    regtype: TYPES.regtype,
    regconfig: TYPES.regconfig,
    regdictionary: TYPES.regdictionary,
    cTextArrayDomain: attributes_text_array_domain_codec_cTextArrayDomain,
    cInt8ArrayDomain: attributes_int8_array_domain_codec_cInt8ArrayDomain,
    bytea: TYPES.bytea,
    pgCatalogByteaArray: attributes_bytea_array_codec_pgCatalogByteaArray,
    ltree: attributes_ltree_codec_ltree,
    "ltree[]": attributes_ltree_array_codec_ltree_,
    bpchar: TYPES.bpchar,
    cCompoundTypeArray: listOfCodec(attributes_o2_codec_cCompoundType, {
      extensions: extensions55,
      typeDelim: ",",
      description: undefined,
      name: "cCompoundTypeArray"
    }),
    bJwtTokenArray: listOfCodec(registryConfig_pgCodecs_bJwtToken_bJwtToken, {
      extensions: extensions56,
      typeDelim: ",",
      description: undefined,
      name: "bJwtTokenArray"
    }),
    bTypesArray: listOfCodec(registryConfig_pgCodecs_bTypes_bTypes, {
      extensions: extensions57,
      typeDelim: ",",
      description: undefined,
      name: "bTypesArray"
    }),
    pgCatalogInt4Array: registryConfig_pgCodecs_pgCatalogInt4Array_pgCatalogInt4Array,
    cFloatrange: registryConfig_pgCodecs_cFloatrange_cFloatrange,
    postArray: registryConfig_pgCodecs_postArray_postArray,
    pgCatalogInt8Array: innerCodec_pgCatalogInt8Array,
    tablefuncCrosstab2: recordCodec(spec_tablefuncCrosstab2),
    tablefuncCrosstab3: recordCodec(spec_tablefuncCrosstab3),
    tablefuncCrosstab4: recordCodec(spec_tablefuncCrosstab4)
  }),
  pgResources: Object.assign(Object.create(null), {
    c_current_user_id: {
      executor: executor_mainPgExecutor,
      name: "c_current_user_id",
      identifier: "main.c.current_user_id()",
      from(...args) {
        return sql`${sqlIdent51}(${sqlFromArgDigests(args)})`;
      },
      parameters: [],
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions64,
      description: undefined
    },
    c_func_out: {
      executor: executor_mainPgExecutor,
      name: "c_func_out",
      identifier: "main.c.func_out(int4)",
      from: fromCallback2,
      parameters: parameters2,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions65,
      description: undefined
    },
    c_func_out_setof: {
      executor: executor_mainPgExecutor,
      name: "c_func_out_setof",
      identifier: "main.c.func_out_setof(int4)",
      from: fromCallback3,
      parameters: parameters3,
      isUnique: !true,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions66,
      description: undefined
    },
    c_func_out_unnamed: {
      executor: executor_mainPgExecutor,
      name: "c_func_out_unnamed",
      identifier: "main.c.func_out_unnamed(int4)",
      from: fromCallback4,
      parameters: parameters4,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions67,
      description: undefined
    },
    c_mutation_out: {
      executor: executor_mainPgExecutor,
      name: "c_mutation_out",
      identifier: "main.c.mutation_out(int4)",
      from: fromCallback5,
      parameters: parameters5,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions68,
      description: undefined
    },
    c_mutation_out_setof: {
      executor: executor_mainPgExecutor,
      name: "c_mutation_out_setof",
      identifier: "main.c.mutation_out_setof(int4)",
      from: fromCallback6,
      parameters: parameters6,
      isUnique: !true,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions69,
      description: undefined
    },
    c_mutation_out_unnamed: {
      executor: executor_mainPgExecutor,
      name: "c_mutation_out_unnamed",
      identifier: "main.c.mutation_out_unnamed(int4)",
      from: fromCallback7,
      parameters: parameters7,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions70,
      description: undefined
    },
    c_no_args_mutation: {
      executor: executor_mainPgExecutor,
      name: "c_no_args_mutation",
      identifier: "main.c.no_args_mutation()",
      from: fromCallback8,
      parameters: parameters8,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions71,
      description: undefined
    },
    c_no_args_query: {
      executor: executor_mainPgExecutor,
      name: "c_no_args_query",
      identifier: "main.c.no_args_query()",
      from: fromCallback9,
      parameters: parameters9,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions72,
      description: undefined
    },
    return_void_mutation: {
      executor: executor_mainPgExecutor,
      name: "return_void_mutation",
      identifier: "main.a.return_void_mutation()",
      from: fromCallback10,
      parameters: parameters10,
      isUnique: !false,
      codec: TYPES.void,
      uniques: [],
      isMutation: true,
      extensions: extensions73,
      description: undefined
    },
    mutation_interval_set: {
      executor: executor_mainPgExecutor,
      name: "mutation_interval_set",
      identifier: "main.a.mutation_interval_set()",
      from: fromCallback11,
      parameters: parameters11,
      isUnique: !true,
      codec: TYPES.interval,
      uniques: [],
      isMutation: true,
      extensions: extensions74,
      description: undefined
    },
    query_interval_set: {
      executor: executor_mainPgExecutor,
      name: "query_interval_set",
      identifier: "main.a.query_interval_set()",
      from: fromCallback12,
      parameters: parameters12,
      isUnique: !true,
      codec: TYPES.interval,
      uniques: [],
      isMutation: false,
      extensions: extensions75,
      description: undefined
    },
    static_big_integer: {
      executor: executor_mainPgExecutor,
      name: "static_big_integer",
      identifier: "main.a.static_big_integer()",
      from: fromCallback13,
      parameters: parameters13,
      isUnique: !true,
      codec: TYPES.bigint,
      uniques: [],
      isMutation: false,
      extensions: extensions76,
      description: undefined
    },
    c_func_in_out: {
      executor: executor_mainPgExecutor,
      name: "c_func_in_out",
      identifier: "main.c.func_in_out(int4,int4)",
      from: fromCallback14,
      parameters: parameters14,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions77,
      description: undefined
    },
    c_func_returns_table_one_col: {
      executor: executor_mainPgExecutor,
      name: "c_func_returns_table_one_col",
      identifier: "main.c.func_returns_table_one_col(int4,int4)",
      from: fromCallback15,
      parameters: parameters15,
      isUnique: !true,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions78,
      description: undefined
    },
    c_mutation_in_out: {
      executor: executor_mainPgExecutor,
      name: "c_mutation_in_out",
      identifier: "main.c.mutation_in_out(int4,int4)",
      from: fromCallback16,
      parameters: parameters16,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions79,
      description: undefined
    },
    c_mutation_returns_table_one_col: {
      executor: executor_mainPgExecutor,
      name: "c_mutation_returns_table_one_col",
      identifier: "main.c.mutation_returns_table_one_col(int4,int4)",
      from: fromCallback17,
      parameters: parameters17,
      isUnique: !true,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions80,
      description: undefined
    },
    assert_something: {
      executor: executor_mainPgExecutor,
      name: "assert_something",
      identifier: "main.a.assert_something(text)",
      from: fromCallback18,
      parameters: parameters18,
      isUnique: !false,
      codec: TYPES.void,
      uniques: [],
      isMutation: false,
      extensions: extensions81,
      description: undefined
    },
    assert_something_nx: {
      executor: executor_mainPgExecutor,
      name: "assert_something_nx",
      identifier: "main.a.assert_something_nx(text)",
      from: fromCallback19,
      parameters: parameters19,
      isUnique: !false,
      codec: TYPES.void,
      uniques: [],
      isMutation: false,
      extensions: extensions82,
      description: undefined
    },
    c_json_identity: {
      executor: executor_mainPgExecutor,
      name: "c_json_identity",
      identifier: "main.c.json_identity(json)",
      from: fromCallback20,
      parameters: parameters20,
      isUnique: !false,
      codec: TYPES.json,
      uniques: [],
      isMutation: false,
      extensions: extensions83,
      description: undefined
    },
    c_json_identity_mutation: {
      executor: executor_mainPgExecutor,
      name: "c_json_identity_mutation",
      identifier: "main.c.json_identity_mutation(json)",
      from: fromCallback21,
      parameters: parameters21,
      isUnique: !false,
      codec: TYPES.json,
      uniques: [],
      isMutation: true,
      extensions: extensions84,
      description: undefined
    },
    c_jsonb_identity: {
      executor: executor_mainPgExecutor,
      name: "c_jsonb_identity",
      identifier: "main.c.jsonb_identity(jsonb)",
      from: fromCallback22,
      parameters: parameters22,
      isUnique: !false,
      codec: TYPES.jsonb,
      uniques: [],
      isMutation: false,
      extensions: extensions85,
      description: undefined
    },
    c_jsonb_identity_mutation: {
      executor: executor_mainPgExecutor,
      name: "c_jsonb_identity_mutation",
      identifier: "main.c.jsonb_identity_mutation(jsonb)",
      from: fromCallback23,
      parameters: parameters23,
      isUnique: !false,
      codec: TYPES.jsonb,
      uniques: [],
      isMutation: true,
      extensions: extensions86,
      description: undefined
    },
    c_jsonb_identity_mutation_plpgsql: {
      executor: executor_mainPgExecutor,
      name: "c_jsonb_identity_mutation_plpgsql",
      identifier: "main.c.jsonb_identity_mutation_plpgsql(jsonb)",
      from: fromCallback24,
      parameters: parameters24,
      isUnique: !false,
      codec: TYPES.jsonb,
      uniques: [],
      isMutation: true,
      extensions: extensions87,
      description: undefined
    },
    c_jsonb_identity_mutation_plpgsql_with_default: {
      executor: executor_mainPgExecutor,
      name: "c_jsonb_identity_mutation_plpgsql_with_default",
      identifier: "main.c.jsonb_identity_mutation_plpgsql_with_default(jsonb)",
      from: fromCallback25,
      parameters: parameters25,
      isUnique: !false,
      codec: TYPES.jsonb,
      uniques: [],
      isMutation: true,
      extensions: extensions88,
      description: undefined
    },
    add_1_mutation: {
      executor: executor_mainPgExecutor,
      name: "add_1_mutation",
      identifier: "main.a.add_1_mutation(int4,int4)",
      from: fromCallback26,
      parameters: parameters26,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions89,
      description: "lol, add some stuff 1 mutation"
    },
    add_1_query: {
      executor: executor_mainPgExecutor,
      name: "add_1_query",
      identifier: "main.a.add_1_query(int4,int4)",
      from: fromCallback27,
      parameters: parameters27,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions90,
      description: "lol, add some stuff 1 query"
    },
    add_2_mutation: {
      executor: executor_mainPgExecutor,
      name: "add_2_mutation",
      identifier: "main.a.add_2_mutation(int4,int4)",
      from: fromCallback28,
      parameters: parameters28,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions91,
      description: "lol, add some stuff 2 mutation"
    },
    add_2_query: {
      executor: executor_mainPgExecutor,
      name: "add_2_query",
      identifier: "main.a.add_2_query(int4,int4)",
      from: fromCallback29,
      parameters: parameters29,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions92,
      description: "lol, add some stuff 2 query"
    },
    add_3_mutation: {
      executor: executor_mainPgExecutor,
      name: "add_3_mutation",
      identifier: "main.a.add_3_mutation(int4,int4)",
      from: fromCallback30,
      parameters: parameters30,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions93,
      description: "lol, add some stuff 3 mutation"
    },
    add_3_query: {
      executor: executor_mainPgExecutor,
      name: "add_3_query",
      identifier: "main.a.add_3_query(int4,int4)",
      from: fromCallback31,
      parameters: parameters31,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions94,
      description: "lol, add some stuff 3 query"
    },
    add_4_mutation: {
      executor: executor_mainPgExecutor,
      name: "add_4_mutation",
      identifier: "main.a.add_4_mutation(int4,int4)",
      from: fromCallback32,
      parameters: parameters32,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions95,
      description: "lol, add some stuff 4 mutation"
    },
    add_4_mutation_error: {
      executor: executor_mainPgExecutor,
      name: "add_4_mutation_error",
      identifier: "main.a.add_4_mutation_error(int4,int4)",
      from: fromCallback33,
      parameters: parameters33,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions96,
      description: undefined
    },
    add_4_query: {
      executor: executor_mainPgExecutor,
      name: "add_4_query",
      identifier: "main.a.add_4_query(int4,int4)",
      from: fromCallback34,
      parameters: parameters34,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions97,
      description: "lol, add some stuff 4 query"
    },
    b_mult_1: {
      executor: executor_mainPgExecutor,
      name: "b_mult_1",
      identifier: "main.b.mult_1(int4,int4)",
      from: fromCallback35,
      parameters: parameters35,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions98,
      description: undefined
    },
    b_mult_2: {
      executor: executor_mainPgExecutor,
      name: "b_mult_2",
      identifier: "main.b.mult_2(int4,int4)",
      from: fromCallback36,
      parameters: parameters36,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions99,
      description: undefined
    },
    b_mult_3: {
      executor: executor_mainPgExecutor,
      name: "b_mult_3",
      identifier: "main.b.mult_3(int4,int4)",
      from: fromCallback37,
      parameters: parameters37,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions100,
      description: undefined
    },
    b_mult_4: {
      executor: executor_mainPgExecutor,
      name: "b_mult_4",
      identifier: "main.b.mult_4(int4,int4)",
      from: fromCallback38,
      parameters: parameters38,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions101,
      description: undefined
    },
    c_func_in_inout: {
      executor: executor_mainPgExecutor,
      name: "c_func_in_inout",
      identifier: "main.c.func_in_inout(int4,int4)",
      from: fromCallback39,
      parameters: parameters39,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions102,
      description: undefined
    },
    c_func_out_out: {
      executor: executor_mainPgExecutor,
      name: "c_func_out_out",
      identifier: "main.c.func_out_out(int4,text)",
      from: fromCallback40,
      parameters: parameters40,
      isUnique: !false,
      codec: registryConfig_pgCodecs_CFuncOutOutRecord_CFuncOutOutRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions103,
      description: undefined
    },
    c_func_out_out_setof: {
      executor: executor_mainPgExecutor,
      name: "c_func_out_out_setof",
      identifier: "main.c.func_out_out_setof(int4,text)",
      from: fromCallback41,
      parameters: parameters41,
      isUnique: !true,
      codec: registryConfig_pgCodecs_CFuncOutOutSetofRecord_CFuncOutOutSetofRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions104,
      description: undefined
    },
    c_func_out_out_unnamed: {
      executor: executor_mainPgExecutor,
      name: "c_func_out_out_unnamed",
      identifier: "main.c.func_out_out_unnamed(int4,text)",
      from: fromCallback42,
      parameters: parameters42,
      isUnique: !false,
      codec: registryConfig_pgCodecs_CFuncOutOutUnnamedRecord_CFuncOutOutUnnamedRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions105,
      description: undefined
    },
    c_mutation_in_inout: {
      executor: executor_mainPgExecutor,
      name: "c_mutation_in_inout",
      identifier: "main.c.mutation_in_inout(int4,int4)",
      from: fromCallback43,
      parameters: parameters43,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions106,
      description: undefined
    },
    c_mutation_out_out: {
      executor: executor_mainPgExecutor,
      name: "c_mutation_out_out",
      identifier: "main.c.mutation_out_out(int4,text)",
      from: fromCallback44,
      parameters: parameters44,
      isUnique: !false,
      codec: registryConfig_pgCodecs_CMutationOutOutRecord_CMutationOutOutRecord,
      uniques: [],
      isMutation: true,
      extensions: extensions107,
      description: undefined
    },
    c_mutation_out_out_setof: {
      executor: executor_mainPgExecutor,
      name: "c_mutation_out_out_setof",
      identifier: "main.c.mutation_out_out_setof(int4,text)",
      from: fromCallback45,
      parameters: parameters45,
      isUnique: !true,
      codec: registryConfig_pgCodecs_CMutationOutOutSetofRecord_CMutationOutOutSetofRecord,
      uniques: [],
      isMutation: true,
      extensions: extensions108,
      description: undefined
    },
    c_mutation_out_out_unnamed: {
      executor: executor_mainPgExecutor,
      name: "c_mutation_out_out_unnamed",
      identifier: "main.c.mutation_out_out_unnamed(int4,text)",
      from: fromCallback46,
      parameters: parameters46,
      isUnique: !false,
      codec: registryConfig_pgCodecs_CMutationOutOutUnnamedRecord_CMutationOutOutUnnamedRecord,
      uniques: [],
      isMutation: true,
      extensions: extensions109,
      description: undefined
    },
    c_search_test_summaries: {
      executor: executor_mainPgExecutor,
      name: "c_search_test_summaries",
      identifier: "main.c.search_test_summaries(int4,interval)",
      from: fromCallback47,
      parameters: parameters47,
      isUnique: !true,
      codec: registryConfig_pgCodecs_CSearchTestSummariesRecord_CSearchTestSummariesRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions110,
      description: undefined
    },
    optional_missing_middle_1: {
      executor: executor_mainPgExecutor,
      name: "optional_missing_middle_1",
      identifier: "main.a.optional_missing_middle_1(int4,int4,int4)",
      from: fromCallback48,
      parameters: parameters48,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions111,
      description: undefined
    },
    optional_missing_middle_2: {
      executor: executor_mainPgExecutor,
      name: "optional_missing_middle_2",
      identifier: "main.a.optional_missing_middle_2(int4,int4,int4)",
      from: fromCallback49,
      parameters: parameters49,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions112,
      description: undefined
    },
    optional_missing_middle_3: {
      executor: executor_mainPgExecutor,
      name: "optional_missing_middle_3",
      identifier: "main.a.optional_missing_middle_3(int4,int4,int4)",
      from: fromCallback50,
      parameters: parameters50,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions113,
      description: undefined
    },
    optional_missing_middle_4: {
      executor: executor_mainPgExecutor,
      name: "optional_missing_middle_4",
      identifier: "main.a.optional_missing_middle_4(int4,int4,int4)",
      from: fromCallback51,
      parameters: parameters51,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions114,
      description: undefined
    },
    optional_missing_middle_5: {
      executor: executor_mainPgExecutor,
      name: "optional_missing_middle_5",
      identifier: "main.a.optional_missing_middle_5(int4,int4,int4)",
      from: fromCallback52,
      parameters: parameters52,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions115,
      description: undefined
    },
    c_func_out_unnamed_out_out_unnamed: {
      executor: executor_mainPgExecutor,
      name: "c_func_out_unnamed_out_out_unnamed",
      identifier: "main.c.func_out_unnamed_out_out_unnamed(int4,text,int4)",
      from: fromCallback53,
      parameters: parameters53,
      isUnique: !false,
      codec: registryConfig_pgCodecs_CFuncOutUnnamedOutOutUnnamedRecord_CFuncOutUnnamedOutOutUnnamedRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions116,
      description: undefined
    },
    c_func_returns_table_multi_col: {
      executor: executor_mainPgExecutor,
      name: "c_func_returns_table_multi_col",
      identifier: "main.c.func_returns_table_multi_col(int4,int4,text)",
      from: fromCallback54,
      parameters: parameters54,
      isUnique: !true,
      codec: registryConfig_pgCodecs_CFuncReturnsTableMultiColRecord_CFuncReturnsTableMultiColRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions117,
      description: undefined
    },
    c_int_set_mutation: {
      executor: executor_mainPgExecutor,
      name: "c_int_set_mutation",
      identifier: "main.c.int_set_mutation(int4,int4,int4)",
      from: fromCallback55,
      parameters: parameters55,
      isUnique: !true,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions118,
      description: undefined
    },
    c_int_set_query: {
      executor: executor_mainPgExecutor,
      name: "c_int_set_query",
      identifier: "main.c.int_set_query(int4,int4,int4)",
      from: fromCallback56,
      parameters: parameters56,
      isUnique: !true,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions119,
      description: undefined
    },
    c_mutation_out_unnamed_out_out_unnamed: {
      executor: executor_mainPgExecutor,
      name: "c_mutation_out_unnamed_out_out_unnamed",
      identifier: "main.c.mutation_out_unnamed_out_out_unnamed(int4,text,int4)",
      from: fromCallback57,
      parameters: parameters57,
      isUnique: !false,
      codec: registryConfig_pgCodecs_CMutationOutUnnamedOutOutUnnamedRecord_CMutationOutUnnamedOutOutUnnamedRecord,
      uniques: [],
      isMutation: true,
      extensions: extensions120,
      description: undefined
    },
    c_mutation_returns_table_multi_col: {
      executor: executor_mainPgExecutor,
      name: "c_mutation_returns_table_multi_col",
      identifier: "main.c.mutation_returns_table_multi_col(int4,int4,text)",
      from: fromCallback58,
      parameters: parameters58,
      isUnique: !true,
      codec: registryConfig_pgCodecs_CMutationReturnsTableMultiColRecord_CMutationReturnsTableMultiColRecord,
      uniques: [],
      isMutation: true,
      extensions: extensions121,
      description: undefined
    },
    b_guid_fn: {
      executor: executor_mainPgExecutor,
      name: "b_guid_fn",
      identifier: "main.b.guid_fn(b.guid)",
      from: fromCallback59,
      parameters: parameters59,
      isUnique: !false,
      codec: registryConfig_pgCodecs_bGuid_bGuid,
      uniques: [],
      isMutation: true,
      extensions: extensions122,
      description: undefined
    },
    mutation_interval_array: {
      executor: executor_mainPgExecutor,
      name: "mutation_interval_array",
      identifier: "main.a.mutation_interval_array()",
      from: fromCallback60,
      parameters: parameters60,
      isUnique: !false,
      codec: registryConfig_pgCodecs_pgCatalogIntervalArray_pgCatalogIntervalArray,
      uniques: [],
      isMutation: true,
      extensions: extensions123,
      description: undefined
    },
    query_interval_array: {
      executor: executor_mainPgExecutor,
      name: "query_interval_array",
      identifier: "main.a.query_interval_array()",
      from: fromCallback61,
      parameters: parameters61,
      isUnique: !false,
      codec: registryConfig_pgCodecs_pgCatalogIntervalArray_pgCatalogIntervalArray,
      uniques: [],
      isMutation: false,
      extensions: extensions124,
      description: undefined
    },
    mutation_text_array: {
      executor: executor_mainPgExecutor,
      name: "mutation_text_array",
      identifier: "main.a.mutation_text_array()",
      from: fromCallback62,
      parameters: parameters62,
      isUnique: !false,
      codec: registryConfig_pgCodecs_pgCatalogTextArray_pgCatalogTextArray,
      uniques: [],
      isMutation: true,
      extensions: extensions125,
      description: undefined
    },
    query_text_array: {
      executor: executor_mainPgExecutor,
      name: "query_text_array",
      identifier: "main.a.query_text_array()",
      from: fromCallback63,
      parameters: parameters63,
      isUnique: !false,
      codec: registryConfig_pgCodecs_pgCatalogTextArray_pgCatalogTextArray,
      uniques: [],
      isMutation: false,
      extensions: extensions126,
      description: undefined
    },
    non_updatable_view: {
      executor: executor_mainPgExecutor,
      name: "non_updatable_view",
      identifier: "main.a.non_updatable_view",
      from: registryConfig_pgCodecs_nonUpdatableView_nonUpdatableView.sqlType,
      codec: registryConfig_pgCodecs_nonUpdatableView_nonUpdatableView,
      uniques: [],
      isVirtual: false,
      description: undefined,
      extensions: extensions127
    },
    inputs: {
      executor: executor_mainPgExecutor,
      name: "inputs",
      identifier: "main.a.inputs",
      from: registryConfig_pgCodecs_inputs_inputs.sqlType,
      codec: registryConfig_pgCodecs_inputs_inputs,
      uniques: uniques2,
      isVirtual: false,
      description: "Should output as Input",
      extensions: extensions128
    },
    patchs: {
      executor: executor_mainPgExecutor,
      name: "patchs",
      identifier: "main.a.patchs",
      from: registryConfig_pgCodecs_patchs_patchs.sqlType,
      codec: registryConfig_pgCodecs_patchs_patchs,
      uniques: uniques3,
      isVirtual: false,
      description: "Should output as Patch",
      extensions: extensions129
    },
    reserved: {
      executor: executor_mainPgExecutor,
      name: "reserved",
      identifier: "main.a.reserved",
      from: registryConfig_pgCodecs_reserved_reserved.sqlType,
      codec: registryConfig_pgCodecs_reserved_reserved,
      uniques: uniques4,
      isVirtual: false,
      description: undefined,
      extensions: extensions130
    },
    reservedPatchs: {
      executor: executor_mainPgExecutor,
      name: "reservedPatchs",
      identifier: "main.a.reservedPatchs",
      from: registryConfig_pgCodecs_reservedPatchs_reservedPatchs.sqlType,
      codec: registryConfig_pgCodecs_reservedPatchs_reservedPatchs,
      uniques: uniques5,
      isVirtual: false,
      description: "`reservedPatchs` table should get renamed to ReservedPatchRecord to prevent clashes with ReservedPatch from `reserved` table",
      extensions: extensions131
    },
    reserved_input: {
      executor: executor_mainPgExecutor,
      name: "reserved_input",
      identifier: "main.a.reserved_input",
      from: registryConfig_pgCodecs_reservedInput_reservedInput.sqlType,
      codec: registryConfig_pgCodecs_reservedInput_reservedInput,
      uniques: uniques6,
      isVirtual: false,
      description: "`reserved_input` table should get renamed to ReservedInputRecord to prevent clashes with ReservedInput from `reserved` table",
      extensions: extensions132
    },
    default_value: {
      executor: executor_mainPgExecutor,
      name: "default_value",
      identifier: "main.a.default_value",
      from: registryConfig_pgCodecs_defaultValue_defaultValue.sqlType,
      codec: registryConfig_pgCodecs_defaultValue_defaultValue,
      uniques: uniques7,
      isVirtual: false,
      description: undefined,
      extensions: extensions133
    },
    foreign_key: registryConfig_pgResources_foreign_key_foreign_key,
    no_primary_key: {
      executor: executor_mainPgExecutor,
      name: "no_primary_key",
      identifier: "main.a.no_primary_key",
      from: registryConfig_pgCodecs_noPrimaryKey_noPrimaryKey.sqlType,
      codec: registryConfig_pgCodecs_noPrimaryKey_noPrimaryKey,
      uniques: uniques9,
      isVirtual: false,
      description: undefined,
      extensions: extensions135
    },
    testview: {
      executor: executor_mainPgExecutor,
      name: "testview",
      identifier: "main.a.testview",
      from: registryConfig_pgCodecs_testview_testview.sqlType,
      codec: registryConfig_pgCodecs_testview_testview,
      uniques: uniques10,
      isVirtual: false,
      description: undefined,
      extensions: extensions136
    },
    unique_foreign_key: registryConfig_pgResources_unique_foreign_key_unique_foreign_key,
    c_my_table: {
      executor: executor_mainPgExecutor,
      name: "c_my_table",
      identifier: "main.c.my_table",
      from: registryConfig_pgCodecs_cMyTable_cMyTable.sqlType,
      codec: registryConfig_pgCodecs_cMyTable_cMyTable,
      uniques: uniques12,
      isVirtual: false,
      description: undefined,
      extensions: extensions138
    },
    c_person_secret: registryConfig_pgResources_c_person_secret_c_person_secret,
    view_table: {
      executor: executor_mainPgExecutor,
      name: "view_table",
      identifier: "main.a.view_table",
      from: registryConfig_pgCodecs_viewTable_viewTable.sqlType,
      codec: registryConfig_pgCodecs_viewTable_viewTable,
      uniques: uniques14,
      isVirtual: false,
      description: undefined,
      extensions: extensions140
    },
    b_updatable_view: {
      executor: executor_mainPgExecutor,
      name: "b_updatable_view",
      identifier: "main.b.updatable_view",
      from: registryConfig_pgCodecs_bUpdatableView_bUpdatableView.sqlType,
      codec: registryConfig_pgCodecs_bUpdatableView_bUpdatableView,
      uniques: uniques15,
      isVirtual: false,
      description: "YOYOYO!!",
      extensions: extensions141
    },
    c_compound_key: registryConfig_pgResources_c_compound_key_c_compound_key,
    similar_table_1: {
      executor: executor_mainPgExecutor,
      name: "similar_table_1",
      identifier: "main.a.similar_table_1",
      from: registryConfig_pgCodecs_similarTable1_similarTable1.sqlType,
      codec: registryConfig_pgCodecs_similarTable1_similarTable1,
      uniques: uniques17,
      isVirtual: false,
      description: undefined,
      extensions: extensions143
    },
    similar_table_2: {
      executor: executor_mainPgExecutor,
      name: "similar_table_2",
      identifier: "main.a.similar_table_2",
      from: registryConfig_pgCodecs_similarTable2_similarTable2.sqlType,
      codec: registryConfig_pgCodecs_similarTable2_similarTable2,
      uniques: uniques18,
      isVirtual: false,
      description: undefined,
      extensions: extensions144
    },
    c_null_test_record: {
      executor: executor_mainPgExecutor,
      name: "c_null_test_record",
      identifier: "main.c.null_test_record",
      from: registryConfig_pgCodecs_cNullTestRecord_cNullTestRecord.sqlType,
      codec: registryConfig_pgCodecs_cNullTestRecord_cNullTestRecord,
      uniques: uniques19,
      isVirtual: false,
      description: undefined,
      extensions: extensions145
    },
    c_edge_case_computed: {
      executor: executor_mainPgExecutor,
      name: "c_edge_case_computed",
      identifier: "main.c.edge_case_computed(c.edge_case)",
      from: fromCallback64,
      parameters: parameters64,
      isUnique: !false,
      codec: TYPES.text,
      uniques: [],
      isMutation: false,
      extensions: extensions146,
      description: undefined
    },
    c_return_table_without_grants: PgResource.functionResourceOptions(registryConfig_pgResources_c_compound_key_c_compound_key, options_c_return_table_without_grants),
    b_list_bde_mutation: {
      executor: executor_mainPgExecutor,
      name: "b_list_bde_mutation",
      identifier: "main.b.list_bde_mutation(_text,text,text)",
      from: fromCallback65,
      parameters: parameters65,
      isUnique: !false,
      codec: registryConfig_pgCodecs_pgCatalogUuidArray_pgCatalogUuidArray,
      uniques: [],
      isMutation: true,
      extensions: extensions147,
      description: undefined
    },
    c_edge_case: {
      executor: executor_mainPgExecutor,
      name: "c_edge_case",
      identifier: "main.c.edge_case",
      from: registryConfig_pgCodecs_cEdgeCase_cEdgeCase.sqlType,
      codec: registryConfig_pgCodecs_cEdgeCase_cEdgeCase,
      uniques: uniques20,
      isVirtual: false,
      description: undefined,
      extensions: extensions148
    },
    c_left_arm: registryConfig_pgResources_c_left_arm_c_left_arm,
    b_authenticate_fail: PgResource.functionResourceOptions(resourceConfig_b_jwt_token, options_b_authenticate_fail),
    b_authenticate: PgResource.functionResourceOptions(resourceConfig_b_jwt_token, options_b_authenticate),
    c_issue756: registryConfig_pgResources_c_issue756_c_issue756,
    c_left_arm_identity: PgResource.functionResourceOptions(registryConfig_pgResources_c_left_arm_c_left_arm, options_c_left_arm_identity),
    c_issue756_mutation: PgResource.functionResourceOptions(registryConfig_pgResources_c_issue756_c_issue756, options_c_issue756_mutation),
    c_issue756_set_mutation: PgResource.functionResourceOptions(registryConfig_pgResources_c_issue756_c_issue756, options_c_issue756_set_mutation),
    b_authenticate_many: PgResource.functionResourceOptions(resourceConfig_b_jwt_token, options_b_authenticate_many),
    b_authenticate_payload: PgResource.functionResourceOptions(resourceConfig_b_auth_payload, options_b_authenticate_payload),
    c_types_mutation: {
      executor: executor_mainPgExecutor,
      name: "c_types_mutation",
      identifier: "main.c.types_mutation(int8,bool,varchar,_int4,json,c.floatrange)",
      from: fromCallback66,
      parameters: parameters66,
      isUnique: !false,
      codec: TYPES.boolean,
      uniques: [],
      isMutation: true,
      extensions: extensions153,
      description: undefined
    },
    c_types_query: {
      executor: executor_mainPgExecutor,
      name: "c_types_query",
      identifier: "main.c.types_query(int8,bool,varchar,_int4,json,c.floatrange)",
      from: fromCallback67,
      parameters: parameters67,
      isUnique: !false,
      codec: TYPES.boolean,
      uniques: [],
      isMutation: false,
      extensions: extensions154,
      description: undefined
    },
    c_compound_type_computed_field: {
      executor: executor_mainPgExecutor,
      name: "c_compound_type_computed_field",
      identifier: "main.c.compound_type_computed_field(c.compound_type)",
      from: fromCallback68,
      parameters: parameters68,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions155,
      description: undefined
    },
    post_computed_interval_set: {
      executor: executor_mainPgExecutor,
      name: "post_computed_interval_set",
      identifier: "main.a.post_computed_interval_set(a.post)",
      from: fromCallback69,
      parameters: parameters69,
      isUnique: !true,
      codec: TYPES.interval,
      uniques: [],
      isMutation: false,
      extensions: extensions156,
      description: undefined
    },
    post_computed_interval_array: {
      executor: executor_mainPgExecutor,
      name: "post_computed_interval_array",
      identifier: "main.a.post_computed_interval_array(a.post)",
      from: fromCallback70,
      parameters: parameters70,
      isUnique: !false,
      codec: registryConfig_pgCodecs_pgCatalogIntervalArray_pgCatalogIntervalArray,
      uniques: [],
      isMutation: false,
      extensions: extensions157,
      description: undefined
    },
    post_computed_text_array: {
      executor: executor_mainPgExecutor,
      name: "post_computed_text_array",
      identifier: "main.a.post_computed_text_array(a.post)",
      from: fromCallback71,
      parameters: parameters71,
      isUnique: !false,
      codec: registryConfig_pgCodecs_pgCatalogTextArray_pgCatalogTextArray,
      uniques: [],
      isMutation: false,
      extensions: extensions158,
      description: undefined
    },
    post_computed_with_optional_arg: {
      executor: executor_mainPgExecutor,
      name: "post_computed_with_optional_arg",
      identifier: "main.a.post_computed_with_optional_arg(a.post,int4)",
      from: fromCallback72,
      parameters: parameters72,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions159,
      description: undefined
    },
    post_computed_with_required_arg: {
      executor: executor_mainPgExecutor,
      name: "post_computed_with_required_arg",
      identifier: "main.a.post_computed_with_required_arg(a.post,int4)",
      from: fromCallback73,
      parameters: parameters73,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions160,
      description: undefined
    },
    c_func_out_out_compound_type: {
      executor: executor_mainPgExecutor,
      name: "c_func_out_out_compound_type",
      identifier: "main.c.func_out_out_compound_type(int4,int4,c.compound_type)",
      from: fromCallback74,
      parameters: parameters74,
      isUnique: !false,
      codec: registryConfig_pgCodecs_CFuncOutOutCompoundTypeRecord_CFuncOutOutCompoundTypeRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions161,
      description: undefined
    },
    c_mutation_out_out_compound_type: {
      executor: executor_mainPgExecutor,
      name: "c_mutation_out_out_compound_type",
      identifier: "main.c.mutation_out_out_compound_type(int4,int4,c.compound_type)",
      from: fromCallback75,
      parameters: parameters75,
      isUnique: !false,
      codec: registryConfig_pgCodecs_CMutationOutOutCompoundTypeRecord_CMutationOutOutCompoundTypeRecord,
      uniques: [],
      isMutation: true,
      extensions: extensions162,
      description: undefined
    },
    post_headline_trimmed: {
      executor: executor_mainPgExecutor,
      name: "post_headline_trimmed",
      identifier: "main.a.post_headline_trimmed(a.post,int4,text)",
      from: fromCallback76,
      parameters: parameters76,
      isUnique: !false,
      codec: TYPES.text,
      uniques: [],
      isMutation: false,
      extensions: extensions163,
      description: undefined
    },
    post_headline_trimmed_no_defaults: {
      executor: executor_mainPgExecutor,
      name: "post_headline_trimmed_no_defaults",
      identifier: "main.a.post_headline_trimmed_no_defaults(a.post,int4,text)",
      from: fromCallback77,
      parameters: parameters77,
      isUnique: !false,
      codec: TYPES.text,
      uniques: [],
      isMutation: false,
      extensions: extensions164,
      description: undefined
    },
    post_headline_trimmed_strict: {
      executor: executor_mainPgExecutor,
      name: "post_headline_trimmed_strict",
      identifier: "main.a.post_headline_trimmed_strict(a.post,int4,text)",
      from: fromCallback78,
      parameters: parameters78,
      isUnique: !false,
      codec: TYPES.text,
      uniques: [],
      isMutation: false,
      extensions: extensions165,
      description: undefined
    },
    c_query_output_two_rows: {
      executor: executor_mainPgExecutor,
      name: "c_query_output_two_rows",
      identifier: "main.c.query_output_two_rows(int4,int4,text,c.left_arm,a.post)",
      from: fromCallback79,
      parameters: parameters79,
      isUnique: !false,
      codec: registryConfig_pgCodecs_CQueryOutputTwoRowsRecord_CQueryOutputTwoRowsRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions166,
      description: undefined
    },
    post: registryConfig_pgResources_post_post,
    c_compound_type_set_query: PgResource.functionResourceOptions(resourceConfig_c_compound_type, options_c_compound_type_set_query),
    b_compound_type_mutation: PgResource.functionResourceOptions(resourceConfig_c_compound_type, options_b_compound_type_mutation),
    b_compound_type_query: PgResource.functionResourceOptions(resourceConfig_c_compound_type, options_b_compound_type_query),
    b_compound_type_set_mutation: PgResource.functionResourceOptions(resourceConfig_c_compound_type, options_b_compound_type_set_mutation),
    c_table_mutation: PgResource.functionResourceOptions(registryConfig_pgResources_post_post, options_c_table_mutation),
    c_table_query: PgResource.functionResourceOptions(registryConfig_pgResources_post_post, options_c_table_query),
    post_with_suffix: PgResource.functionResourceOptions(registryConfig_pgResources_post_post, options_post_with_suffix),
    mutation_compound_type_array: PgResource.functionResourceOptions(resourceConfig_c_compound_type, options_mutation_compound_type_array),
    query_compound_type_array: PgResource.functionResourceOptions(resourceConfig_c_compound_type, options_query_compound_type_array),
    b_compound_type_array_mutation: PgResource.functionResourceOptions(resourceConfig_c_compound_type, options_b_compound_type_array_mutation),
    b_compound_type_array_query: PgResource.functionResourceOptions(resourceConfig_c_compound_type, options_b_compound_type_array_query),
    post_computed_compound_type_array: PgResource.functionResourceOptions(resourceConfig_c_compound_type, options_post_computed_compound_type_array),
    post_many: PgResource.functionResourceOptions(registryConfig_pgResources_post_post, options_post_many),
    c_person_computed_out: {
      executor: executor_mainPgExecutor,
      name: "c_person_computed_out",
      identifier: "main.c.person_computed_out(c.person,text)",
      from: fromCallback80,
      parameters: parameters80,
      isUnique: !false,
      codec: TYPES.text,
      uniques: [],
      isMutation: false,
      extensions: extensions169,
      description: undefined
    },
    c_person_first_name: {
      executor: executor_mainPgExecutor,
      name: "c_person_first_name",
      identifier: "main.c.person_first_name(c.person)",
      from: fromCallback81,
      parameters: parameters81,
      isUnique: !false,
      codec: TYPES.text,
      uniques: [],
      isMutation: false,
      extensions: extensions170,
      description: "The first name of the person."
    },
    c_person_computed_out_out: {
      executor: executor_mainPgExecutor,
      name: "c_person_computed_out_out",
      identifier: "main.c.person_computed_out_out(c.person,text,text)",
      from: fromCallback82,
      parameters: parameters82,
      isUnique: !false,
      codec: registryConfig_pgCodecs_CPersonComputedOutOutRecord_CPersonComputedOutOutRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions171,
      description: undefined
    },
    c_person_computed_inout: {
      executor: executor_mainPgExecutor,
      name: "c_person_computed_inout",
      identifier: "main.c.person_computed_inout(c.person,text)",
      from: fromCallback83,
      parameters: parameters83,
      isUnique: !false,
      codec: TYPES.text,
      uniques: [],
      isMutation: false,
      extensions: extensions172,
      description: undefined
    },
    c_person_computed_inout_out: {
      executor: executor_mainPgExecutor,
      name: "c_person_computed_inout_out",
      identifier: "main.c.person_computed_inout_out(c.person,text,text)",
      from: fromCallback84,
      parameters: parameters84,
      isUnique: !false,
      codec: registryConfig_pgCodecs_CPersonComputedInoutOutRecord_CPersonComputedInoutOutRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions173,
      description: undefined
    },
    c_person_exists: {
      executor: executor_mainPgExecutor,
      name: "c_person_exists",
      identifier: "main.c.person_exists(c.person,b.email)",
      from: fromCallback85,
      parameters: parameters85,
      isUnique: !false,
      codec: TYPES.boolean,
      uniques: [],
      isMutation: false,
      extensions: extensions174,
      description: undefined
    },
    c_person_computed_first_arg_inout_out: {
      executor: executor_mainPgExecutor,
      name: "c_person_computed_first_arg_inout_out",
      identifier: "main.c.person_computed_first_arg_inout_out(c.person,int4)",
      from: fromCallback86,
      parameters: parameters86,
      isUnique: !false,
      codec: registryConfig_pgCodecs_CPersonComputedFirstArgInoutOutRecord_CPersonComputedFirstArgInoutOutRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions175,
      description: undefined
    },
    c_func_out_complex: {
      executor: executor_mainPgExecutor,
      name: "c_func_out_complex",
      identifier: "main.c.func_out_complex(int4,text,int4,c.compound_type,c.person)",
      from: fromCallback87,
      parameters: parameters87,
      isUnique: !false,
      codec: registryConfig_pgCodecs_CFuncOutComplexRecord_CFuncOutComplexRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions176,
      description: undefined
    },
    c_func_out_complex_setof: {
      executor: executor_mainPgExecutor,
      name: "c_func_out_complex_setof",
      identifier: "main.c.func_out_complex_setof(int4,text,int4,c.compound_type,c.person)",
      from: fromCallback88,
      parameters: parameters88,
      isUnique: !true,
      codec: registryConfig_pgCodecs_CFuncOutComplexSetofRecord_CFuncOutComplexSetofRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions177,
      description: undefined
    },
    c_mutation_out_complex: {
      executor: executor_mainPgExecutor,
      name: "c_mutation_out_complex",
      identifier: "main.c.mutation_out_complex(int4,text,int4,c.compound_type,c.person)",
      from: fromCallback89,
      parameters: parameters89,
      isUnique: !false,
      codec: registryConfig_pgCodecs_CMutationOutComplexRecord_CMutationOutComplexRecord,
      uniques: [],
      isMutation: true,
      extensions: extensions178,
      description: undefined
    },
    c_mutation_out_complex_setof: {
      executor: executor_mainPgExecutor,
      name: "c_mutation_out_complex_setof",
      identifier: "main.c.mutation_out_complex_setof(int4,text,int4,c.compound_type,c.person)",
      from: fromCallback90,
      parameters: parameters90,
      isUnique: !true,
      codec: registryConfig_pgCodecs_CMutationOutComplexSetofRecord_CMutationOutComplexSetofRecord,
      uniques: [],
      isMutation: true,
      extensions: extensions179,
      description: undefined
    },
    c_person_computed_complex: {
      executor: executor_mainPgExecutor,
      name: "c_person_computed_complex",
      identifier: "main.c.person_computed_complex(c.person,int4,text,int4,c.compound_type,c.person)",
      from: fromCallback91,
      parameters: parameters91,
      isUnique: !false,
      codec: registryConfig_pgCodecs_CPersonComputedComplexRecord_CPersonComputedComplexRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions180,
      description: undefined
    },
    c_person_first_post: PgResource.functionResourceOptions(registryConfig_pgResources_post_post, options_c_person_first_post),
    c_person: registryConfig_pgResources_c_person_c_person,
    c_badly_behaved_function: PgResource.functionResourceOptions(registryConfig_pgResources_c_person_c_person, options_c_badly_behaved_function),
    c_func_out_table: PgResource.functionResourceOptions(registryConfig_pgResources_c_person_c_person, options_c_func_out_table),
    c_func_out_table_setof: PgResource.functionResourceOptions(registryConfig_pgResources_c_person_c_person, options_c_func_out_table_setof),
    c_mutation_out_table: PgResource.functionResourceOptions(registryConfig_pgResources_c_person_c_person, options_c_mutation_out_table),
    c_mutation_out_table_setof: PgResource.functionResourceOptions(registryConfig_pgResources_c_person_c_person, options_c_mutation_out_table_setof),
    c_table_set_mutation: PgResource.functionResourceOptions(registryConfig_pgResources_c_person_c_person, options_c_table_set_mutation),
    c_table_set_query: PgResource.functionResourceOptions(registryConfig_pgResources_c_person_c_person, options_c_table_set_query),
    c_table_set_query_plpgsql: PgResource.functionResourceOptions(registryConfig_pgResources_c_person_c_person, options_c_table_set_query_plpgsql),
    c_person_computed_first_arg_inout: PgResource.functionResourceOptions(registryConfig_pgResources_c_person_c_person, options_c_person_computed_first_arg_inout),
    c_person_friends: PgResource.functionResourceOptions(registryConfig_pgResources_c_person_c_person, options_c_person_friends),
    b_types: registryConfig_pgResources_b_types_b_types,
    b_type_function_connection: PgResource.functionResourceOptions(registryConfig_pgResources_b_types_b_types, options_b_type_function_connection),
    b_type_function_connection_mutation: PgResource.functionResourceOptions(registryConfig_pgResources_b_types_b_types, options_b_type_function_connection_mutation),
    b_type_function: PgResource.functionResourceOptions(registryConfig_pgResources_b_types_b_types, options_b_type_function),
    b_type_function_mutation: PgResource.functionResourceOptions(registryConfig_pgResources_b_types_b_types, options_b_type_function_mutation),
    c_person_type_function_connection: PgResource.functionResourceOptions(registryConfig_pgResources_b_types_b_types, options_c_person_type_function_connection),
    c_person_type_function: PgResource.functionResourceOptions(registryConfig_pgResources_b_types_b_types, options_c_person_type_function),
    b_type_function_list: PgResource.functionResourceOptions(registryConfig_pgResources_b_types_b_types, options_b_type_function_list),
    b_type_function_list_mutation: PgResource.functionResourceOptions(registryConfig_pgResources_b_types_b_types, options_b_type_function_list_mutation),
    c_person_type_function_list: PgResource.functionResourceOptions(registryConfig_pgResources_b_types_b_types, options_c_person_type_function_list)
  }),
  pgRelations: Object.assign(Object.create(null), {
    foreignKey: Object.assign(Object.create(null), {
      cCompoundKeyByMyCompoundKey1AndCompoundKey2: {
        localCodec: registryConfig_pgCodecs_foreignKey_foreignKey,
        remoteResourceOptions: registryConfig_pgResources_c_compound_key_c_compound_key,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["compound_key_1", "compound_key_2"],
        remoteAttributes: ["person_id_1", "person_id_2"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      cPersonByMyPersonId: {
        localCodec: registryConfig_pgCodecs_foreignKey_foreignKey,
        remoteResourceOptions: registryConfig_pgResources_c_person_c_person,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    post: Object.assign(Object.create(null), {
      cPersonByMyAuthorId: {
        localCodec: attributes_post_codec_post,
        remoteResourceOptions: registryConfig_pgResources_c_person_c_person,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["author_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      bTypesByTheirSmallint: {
        localCodec: attributes_post_codec_post,
        remoteResourceOptions: registryConfig_pgResources_b_types_b_types,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["smallint"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      bTypesByTheirId: {
        localCodec: attributes_post_codec_post,
        remoteResourceOptions: registryConfig_pgResources_b_types_b_types,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    uniqueForeignKey: Object.assign(Object.create(null), {
      cCompoundKeyByMyCompoundKey1AndCompoundKey2: {
        localCodec: registryConfig_pgCodecs_uniqueForeignKey_uniqueForeignKey,
        remoteResourceOptions: registryConfig_pgResources_c_compound_key_c_compound_key,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["compound_key_1", "compound_key_2"],
        remoteAttributes: ["person_id_1", "person_id_2"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    bAuthPayload: Object.assign(Object.create(null), {
      cPersonByMyId: {
        localCodec: registryConfig_pgCodecs_bAuthPayload_bAuthPayload,
        remoteResourceOptions: registryConfig_pgResources_c_person_c_person,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    bTypes: Object.assign(Object.create(null), {
      postByMySmallint: {
        localCodec: registryConfig_pgCodecs_bTypes_bTypes,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["smallint"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      postByMyId: {
        localCodec: registryConfig_pgCodecs_bTypes_bTypes,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    cCompoundKey: Object.assign(Object.create(null), {
      cPersonByMyPersonId1: {
        localCodec: registryConfig_pgCodecs_cCompoundKey_cCompoundKey,
        remoteResourceOptions: registryConfig_pgResources_c_person_c_person,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id_1"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      cPersonByMyPersonId2: {
        localCodec: registryConfig_pgCodecs_cCompoundKey_cCompoundKey,
        remoteResourceOptions: registryConfig_pgResources_c_person_c_person,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id_2"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      foreignKeysByTheirCompoundKey1AndCompoundKey2: {
        localCodec: registryConfig_pgCodecs_cCompoundKey_cCompoundKey,
        remoteResourceOptions: registryConfig_pgResources_foreign_key_foreign_key,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id_1", "person_id_2"],
        remoteAttributes: ["compound_key_1", "compound_key_2"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      uniqueForeignKeyByTheirCompoundKey1AndCompoundKey2: {
        localCodec: registryConfig_pgCodecs_cCompoundKey_cCompoundKey,
        remoteResourceOptions: registryConfig_pgResources_unique_foreign_key_unique_foreign_key,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id_1", "person_id_2"],
        remoteAttributes: ["compound_key_1", "compound_key_2"],
        isUnique: true,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    cLeftArm: Object.assign(Object.create(null), {
      cPersonByMyPersonId: {
        localCodec: registryConfig_pgCodecs_cLeftArm_cLeftArm,
        remoteResourceOptions: registryConfig_pgResources_c_person_c_person,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    cPerson: Object.assign(Object.create(null), {
      postsByTheirAuthorId: {
        localCodec: attributes_person_codec_cPerson,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["author_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      foreignKeysByTheirPersonId: {
        localCodec: attributes_person_codec_cPerson,
        remoteResourceOptions: registryConfig_pgResources_foreign_key_foreign_key,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["person_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      cPersonSecretByTheirPersonId: {
        localCodec: attributes_person_codec_cPerson,
        remoteResourceOptions: registryConfig_pgResources_c_person_secret_c_person_secret,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["person_id"],
        isUnique: true,
        isReferencee: true,
        description: "This `Person`'s `PersonSecret`.",
        extensions: {
          tags: {
            forwardDescription: "The `Person` this `PersonSecret` belongs to.",
            backwardDescription: "This `Person`'s `PersonSecret`.",
            behavior: []
          }
        }
      },
      cLeftArmByTheirPersonId: {
        localCodec: attributes_person_codec_cPerson,
        remoteResourceOptions: registryConfig_pgResources_c_left_arm_c_left_arm,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["person_id"],
        isUnique: true,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      cCompoundKeysByTheirPersonId1: {
        localCodec: attributes_person_codec_cPerson,
        remoteResourceOptions: registryConfig_pgResources_c_compound_key_c_compound_key,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["person_id_1"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      cCompoundKeysByTheirPersonId2: {
        localCodec: attributes_person_codec_cPerson,
        remoteResourceOptions: registryConfig_pgResources_c_compound_key_c_compound_key,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["person_id_2"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    cPersonSecret: Object.assign(Object.create(null), {
      cPersonByMyPersonId: {
        localCodec: registryConfig_pgCodecs_cPersonSecret_cPersonSecret,
        remoteResourceOptions: registryConfig_pgResources_c_person_c_person,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: "The `Person` this `PersonSecret` belongs to.",
        extensions: {
          tags: {
            forwardDescription: "The `Person` this `PersonSecret` belongs to.",
            backwardDescription: "This `Person`'s `PersonSecret`.",
            behavior: []
          }
        }
      }
    })
  })
});
const resource_inputsPgResource = registry.pgResources["inputs"];
const resource_patchsPgResource = registry.pgResources["patchs"];
const resource_reservedPgResource = registry.pgResources["reserved"];
const resource_reservedPatchsPgResource = registry.pgResources["reservedPatchs"];
const resource_reserved_inputPgResource = registry.pgResources["reserved_input"];
const resource_default_valuePgResource = registry.pgResources["default_value"];
const resource_no_primary_keyPgResource = registry.pgResources["no_primary_key"];
const resource_unique_foreign_keyPgResource = registry.pgResources["unique_foreign_key"];
const resource_c_my_tablePgResource = registry.pgResources["c_my_table"];
const resource_c_person_secretPgResource = registry.pgResources["c_person_secret"];
const resource_view_tablePgResource = registry.pgResources["view_table"];
const resource_c_compound_keyPgResource = registry.pgResources["c_compound_key"];
const resource_similar_table_1PgResource = registry.pgResources["similar_table_1"];
const resource_similar_table_2PgResource = registry.pgResources["similar_table_2"];
const resource_c_null_test_recordPgResource = registry.pgResources["c_null_test_record"];
const resource_c_left_armPgResource = registry.pgResources["c_left_arm"];
const resource_c_issue756PgResource = registry.pgResources["c_issue756"];
const resource_postPgResource = registry.pgResources["post"];
const resource_c_personPgResource = registry.pgResources["c_person"];
const resource_b_typesPgResource = registry.pgResources["b_types"];
const argDetailsSimple = [];
const makeArgs = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_current_user_idPgResource = registry.pgResources["c_current_user_id"];
const argDetailsSimple2 = [];
const makeArgs2 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple2[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_func_outPgResource = registry.pgResources["c_func_out"];
const argDetailsSimple3 = [];
const makeArgs3 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple3[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_func_out_setofPgResource = registry.pgResources["c_func_out_setof"];
const getSelectPlanFromParentAndArgs = ($root, args, _info) => {
  const selectArgs = makeArgs3(args);
  return resource_c_func_out_setofPgResource.execute(selectArgs);
};
function Query_cFuncOutSetofPlan($parent, args, info) {
  const $select = getSelectPlanFromParentAndArgs($parent, args, info);
  return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
}
function Query_cFuncOutSetof_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_cFuncOutSetof_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_cFuncOutSetof_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_cFuncOutSetof_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_cFuncOutSetof_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple4 = [];
const makeArgs4 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple4[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_func_out_unnamedPgResource = registry.pgResources["c_func_out_unnamed"];
const argDetailsSimple5 = [];
const makeArgs5 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple5[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_no_args_queryPgResource = registry.pgResources["c_no_args_query"];
const argDetailsSimple6 = [];
const makeArgs6 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple6[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_query_interval_setPgResource = registry.pgResources["query_interval_set"];
const getSelectPlanFromParentAndArgs2 = ($root, args, _info) => {
  const selectArgs = makeArgs6(args);
  return resource_query_interval_setPgResource.execute(selectArgs);
};
function Query_queryIntervalSet_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_queryIntervalSet_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_queryIntervalSet_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_queryIntervalSet_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_queryIntervalSet_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple7 = [];
const makeArgs7 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple7[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_static_big_integerPgResource = registry.pgResources["static_big_integer"];
const getSelectPlanFromParentAndArgs3 = ($root, args, _info) => {
  const selectArgs = makeArgs7(args);
  return resource_static_big_integerPgResource.execute(selectArgs);
};
function Query_staticBigInteger_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_staticBigInteger_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_staticBigInteger_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_staticBigInteger_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_staticBigInteger_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple8 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs8 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple8[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_func_in_outPgResource = registry.pgResources["c_func_in_out"];
const argDetailsSimple9 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs9 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple9[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_func_returns_table_one_colPgResource = registry.pgResources["c_func_returns_table_one_col"];
const getSelectPlanFromParentAndArgs4 = ($root, args, _info) => {
  const selectArgs = makeArgs9(args);
  return resource_c_func_returns_table_one_colPgResource.execute(selectArgs);
};
function Query_cFuncReturnsTableOneCol_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_cFuncReturnsTableOneCol_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_cFuncReturnsTableOneCol_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_cFuncReturnsTableOneCol_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_cFuncReturnsTableOneCol_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple10 = [{
  graphqlArgName: "json",
  postgresArgName: "json",
  pgCodec: TYPES.json,
  required: true,
  fetcher: null
}];
const makeArgs10 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple10[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_json_identityPgResource = registry.pgResources["c_json_identity"];
const argDetailsSimple11 = [{
  graphqlArgName: "json",
  postgresArgName: "json",
  pgCodec: TYPES.jsonb,
  required: true,
  fetcher: null
}];
const makeArgs11 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple11[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_jsonb_identityPgResource = registry.pgResources["c_jsonb_identity"];
const argDetailsSimple12 = [{
  graphqlArgName: "arg0",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs12 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple12[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_1_queryPgResource = registry.pgResources["add_1_query"];
const argDetailsSimple13 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs13 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple13[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_2_queryPgResource = registry.pgResources["add_2_query"];
const argDetailsSimple14 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs14 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple14[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_3_queryPgResource = registry.pgResources["add_3_query"];
const argDetailsSimple15 = [{
  graphqlArgName: "arg0",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs15 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple15[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 1 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_4_queryPgResource = registry.pgResources["add_4_query"];
const argDetailsSimple16 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "ino",
  postgresArgName: "ino",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs16 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple16[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_func_in_inoutPgResource = registry.pgResources["c_func_in_inout"];
const argDetailsSimple17 = [];
const makeArgs17 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple17[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_func_out_outPgResource = registry.pgResources["c_func_out_out"];
const argDetailsSimple18 = [];
const makeArgs18 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple18[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_func_out_out_setofPgResource = registry.pgResources["c_func_out_out_setof"];
const getSelectPlanFromParentAndArgs5 = ($root, args, _info) => {
  const selectArgs = makeArgs18(args);
  return resource_c_func_out_out_setofPgResource.execute(selectArgs);
};
function Query_cFuncOutOutSetof_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_cFuncOutOutSetof_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_cFuncOutOutSetof_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_cFuncOutOutSetof_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_cFuncOutOutSetof_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple19 = [];
const makeArgs19 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple19[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_func_out_out_unnamedPgResource = registry.pgResources["c_func_out_out_unnamed"];
const argDetailsSimple20 = [];
const makeArgs20 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple20[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_search_test_summariesPgResource = registry.pgResources["c_search_test_summaries"];
const getSelectPlanFromParentAndArgs6 = ($root, args, _info) => {
  const selectArgs = makeArgs20(args);
  return resource_c_search_test_summariesPgResource.execute(selectArgs);
};
function Query_cSearchTestSummaries_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_cSearchTestSummaries_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_cSearchTestSummaries_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_cSearchTestSummaries_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_cSearchTestSummaries_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple21 = [{
  graphqlArgName: "arg0",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}, {
  graphqlArgName: "c",
  postgresArgName: "c",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs21 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple21[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 1 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_optional_missing_middle_1PgResource = registry.pgResources["optional_missing_middle_1"];
const argDetailsSimple22 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}, {
  graphqlArgName: "c",
  postgresArgName: "c",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs22 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple22[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_optional_missing_middle_2PgResource = registry.pgResources["optional_missing_middle_2"];
const argDetailsSimple23 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}, {
  graphqlArgName: "c",
  postgresArgName: "c",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs23 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple23[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_optional_missing_middle_3PgResource = registry.pgResources["optional_missing_middle_3"];
const argDetailsSimple24 = [{
  graphqlArgName: "arg0",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}, {
  graphqlArgName: "arg2",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs24 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple24[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 3 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_optional_missing_middle_4PgResource = registry.pgResources["optional_missing_middle_4"];
const argDetailsSimple25 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}, {
  graphqlArgName: "arg2",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs25 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple25[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 3 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_optional_missing_middle_5PgResource = registry.pgResources["optional_missing_middle_5"];
const argDetailsSimple26 = [];
const makeArgs26 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple26[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_func_out_unnamed_out_out_unnamedPgResource = registry.pgResources["c_func_out_unnamed_out_out_unnamed"];
const argDetailsSimple27 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs27 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple27[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_func_returns_table_multi_colPgResource = registry.pgResources["c_func_returns_table_multi_col"];
const getSelectPlanFromParentAndArgs7 = ($root, args, _info) => {
  const selectArgs = makeArgs27(args);
  return resource_c_func_returns_table_multi_colPgResource.execute(selectArgs);
};
function Query_cFuncReturnsTableMultiCol_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_cFuncReturnsTableMultiCol_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_cFuncReturnsTableMultiCol_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_cFuncReturnsTableMultiCol_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_cFuncReturnsTableMultiCol_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple28 = [{
  graphqlArgName: "x",
  postgresArgName: "x",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "y",
  postgresArgName: "y",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "z",
  postgresArgName: "z",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs28 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple28[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_int_set_queryPgResource = registry.pgResources["c_int_set_query"];
const getSelectPlanFromParentAndArgs8 = ($root, args, _info) => {
  const selectArgs = makeArgs28(args);
  return resource_c_int_set_queryPgResource.execute(selectArgs);
};
function Query_cIntSetQuery_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_cIntSetQuery_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_cIntSetQuery_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_cIntSetQuery_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_cIntSetQuery_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple29 = [];
const makeArgs29 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple29[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_query_interval_arrayPgResource = registry.pgResources["query_interval_array"];
const argDetailsSimple30 = [];
const makeArgs30 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple30[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_query_text_arrayPgResource = registry.pgResources["query_text_array"];
const argDetailsSimple31 = [];
const makeArgs31 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple31[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_return_table_without_grantsPgResource = registry.pgResources["c_return_table_without_grants"];
const argDetailsSimple32 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.bigint,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.boolean,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "c",
  postgresArgName: "c",
  pgCodec: TYPES.varchar,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "d",
  postgresArgName: "d",
  pgCodec: registryConfig_pgCodecs_pgCatalogInt4Array_pgCatalogInt4Array,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "e",
  postgresArgName: "e",
  pgCodec: TYPES.json,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "f",
  postgresArgName: "f",
  pgCodec: registryConfig_pgCodecs_cFloatrange_cFloatrange,
  required: true,
  fetcher: null
}];
const makeArgs32 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 6; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple32[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_types_queryPgResource = registry.pgResources["c_types_query"];
const argDetailsSimple33 = [{
  graphqlArgName: "compoundType",
  postgresArgName: "compound_type",
  pgCodec: attributes_o2_codec_cCompoundType,
  required: true,
  fetcher: null
}];
const makeArgs33 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple33[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_compound_type_computed_fieldPgResource = registry.pgResources["c_compound_type_computed_field"];
const argDetailsSimple34 = [{
  graphqlArgName: "i1",
  postgresArgName: "i1",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs34 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple34[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_func_out_out_compound_typePgResource = registry.pgResources["c_func_out_out_compound_type"];
const argDetailsSimple35 = [{
  graphqlArgName: "leftArmId",
  postgresArgName: "left_arm_id",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "postId",
  postgresArgName: "post_id",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "txt",
  postgresArgName: "txt",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs35 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple35[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_query_output_two_rowsPgResource = registry.pgResources["c_query_output_two_rows"];
const argDetailsSimple36 = [];
const makeArgs36 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple36[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_compound_type_set_queryPgResource = registry.pgResources["c_compound_type_set_query"];
const getSelectPlanFromParentAndArgs9 = ($root, args, _info) => {
  const selectArgs = makeArgs36(args);
  return resource_c_compound_type_set_queryPgResource.execute(selectArgs);
};
function Query_cCompoundTypeSetQuery_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_cCompoundTypeSetQuery_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_cCompoundTypeSetQuery_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_cCompoundTypeSetQuery_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_cCompoundTypeSetQuery_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple37 = [{
  graphqlArgName: "object",
  postgresArgName: "object",
  pgCodec: attributes_o2_codec_cCompoundType,
  required: true,
  fetcher: null
}];
const makeArgs37 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple37[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_compound_type_queryPgResource = registry.pgResources["b_compound_type_query"];
const argDetailsSimple38 = [{
  graphqlArgName: "id",
  postgresArgName: "id",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs38 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple38[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_table_queryPgResource = registry.pgResources["c_table_query"];
const argDetailsSimple39 = [{
  graphqlArgName: "object",
  postgresArgName: "object",
  pgCodec: attributes_o2_codec_cCompoundType,
  required: true,
  fetcher: null
}];
const makeArgs39 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple39[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_query_compound_type_arrayPgResource = registry.pgResources["query_compound_type_array"];
const argDetailsSimple40 = [{
  graphqlArgName: "object",
  postgresArgName: "object",
  pgCodec: attributes_o2_codec_cCompoundType,
  required: true,
  fetcher: null
}];
const makeArgs40 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple40[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_compound_type_array_queryPgResource = registry.pgResources["b_compound_type_array_query"];
const argDetailsSimple41 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs41 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple41[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_func_out_complexPgResource = registry.pgResources["c_func_out_complex"];
const argDetailsSimple42 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs42 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple42[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_func_out_complex_setofPgResource = registry.pgResources["c_func_out_complex_setof"];
const getSelectPlanFromParentAndArgs10 = ($root, args, _info) => {
  const selectArgs = makeArgs42(args);
  return resource_c_func_out_complex_setofPgResource.execute(selectArgs);
};
function Query_cFuncOutComplexSetof_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_cFuncOutComplexSetof_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_cFuncOutComplexSetof_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_cFuncOutComplexSetof_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_cFuncOutComplexSetof_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple43 = [];
const makeArgs43 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple43[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_badly_behaved_functionPgResource = registry.pgResources["c_badly_behaved_function"];
const getSelectPlanFromParentAndArgs11 = ($root, args, _info) => {
  const selectArgs = makeArgs43(args);
  return resource_c_badly_behaved_functionPgResource.execute(selectArgs);
};
function Query_cBadlyBehavedFunction_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_cBadlyBehavedFunction_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_cBadlyBehavedFunction_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_cBadlyBehavedFunction_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_cBadlyBehavedFunction_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple44 = [];
const makeArgs44 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple44[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_func_out_tablePgResource = registry.pgResources["c_func_out_table"];
const argDetailsSimple45 = [];
const makeArgs45 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple45[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_func_out_table_setofPgResource = registry.pgResources["c_func_out_table_setof"];
const getSelectPlanFromParentAndArgs12 = ($root, args, _info) => {
  const selectArgs = makeArgs45(args);
  return resource_c_func_out_table_setofPgResource.execute(selectArgs);
};
function Query_cFuncOutTableSetof_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_cFuncOutTableSetof_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_cFuncOutTableSetof_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_cFuncOutTableSetof_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_cFuncOutTableSetof_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple46 = [];
const makeArgs46 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple46[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_table_set_queryPgResource = registry.pgResources["c_table_set_query"];
const getSelectPlanFromParentAndArgs13 = ($root, args, _info) => {
  const selectArgs = makeArgs46(args);
  return resource_c_table_set_queryPgResource.execute(selectArgs);
};
function Query_cTableSetQuery_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_cTableSetQuery_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_cTableSetQuery_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_cTableSetQuery_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_cTableSetQuery_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple47 = [];
const makeArgs47 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple47[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_table_set_query_plpgsqlPgResource = registry.pgResources["c_table_set_query_plpgsql"];
const getSelectPlanFromParentAndArgs14 = ($root, args, _info) => {
  const selectArgs = makeArgs47(args);
  return resource_c_table_set_query_plpgsqlPgResource.execute(selectArgs);
};
function Query_cTableSetQueryPlpgsql_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_cTableSetQueryPlpgsql_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_cTableSetQueryPlpgsql_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_cTableSetQueryPlpgsql_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_cTableSetQueryPlpgsql_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple48 = [];
const makeArgs48 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple48[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_type_function_connectionPgResource = registry.pgResources["b_type_function_connection"];
const getSelectPlanFromParentAndArgs15 = ($root, args, _info) => {
  const selectArgs = makeArgs48(args);
  return resource_b_type_function_connectionPgResource.execute(selectArgs);
};
function Query_bTypeFunctionConnection_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_bTypeFunctionConnection_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_bTypeFunctionConnection_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_bTypeFunctionConnection_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_bTypeFunctionConnection_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple49 = [{
  graphqlArgName: "id",
  postgresArgName: "id",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs49 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple49[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_type_functionPgResource = registry.pgResources["b_type_function"];
const argDetailsSimple50 = [];
const makeArgs50 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple50[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_type_function_listPgResource = registry.pgResources["b_type_function_list"];
const resource_non_updatable_viewPgResource = registry.pgResources["non_updatable_view"];
function Query_allNonUpdatableViews_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allNonUpdatableViews_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allNonUpdatableViews_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allNonUpdatableViews_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allNonUpdatableViews_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const applyOrderToPlan = ($select, $value, TableOrderByType) => {
  const val = $value.eval();
  if (val == null) {
    return;
  }
  if (!Array.isArray(val)) {
    throw new Error("Invalid!");
  }
  val.forEach(order => {
    const config = getEnumValueConfig(TableOrderByType, order);
    const plan = config?.extensions?.grafast?.applyPlan;
    if (typeof plan !== "function") {
      console.error(`Internal server error: invalid orderBy configuration: expected function, but received ${inspect(plan)}`);
      throw new SafeError("Internal server error: invalid orderBy configuration");
    }
    plan($select);
  });
};
function Query_allInputs_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allInputs_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allInputs_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allInputs_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allInputs_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allPatches_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allPatches_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allPatches_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allPatches_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allPatches_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allReserveds_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allReserveds_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allReserveds_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allReserveds_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allReserveds_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allReservedPatchRecords_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allReservedPatchRecords_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allReservedPatchRecords_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allReservedPatchRecords_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allReservedPatchRecords_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allReservedInputRecords_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allReservedInputRecords_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allReservedInputRecords_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allReservedInputRecords_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allReservedInputRecords_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allDefaultValues_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allDefaultValues_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allDefaultValues_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allDefaultValues_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allDefaultValues_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const resource_foreign_keyPgResource = registry.pgResources["foreign_key"];
function Query_allForeignKeys_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allForeignKeys_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allForeignKeys_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allForeignKeys_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allForeignKeys_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allNoPrimaryKeys_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allNoPrimaryKeys_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allNoPrimaryKeys_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allNoPrimaryKeys_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allNoPrimaryKeys_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const resource_testviewPgResource = registry.pgResources["testview"];
function Query_allTestviews_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allTestviews_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allTestviews_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allTestviews_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allTestviews_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allUniqueForeignKeys_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allUniqueForeignKeys_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allUniqueForeignKeys_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allUniqueForeignKeys_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allUniqueForeignKeys_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allCMyTables_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allCMyTables_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allCMyTables_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allCMyTables_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allCMyTables_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allCPersonSecrets_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allCPersonSecrets_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allCPersonSecrets_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allCPersonSecrets_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allCPersonSecrets_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allViewTables_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allViewTables_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allViewTables_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allViewTables_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allViewTables_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const resource_b_updatable_viewPgResource = registry.pgResources["b_updatable_view"];
function Query_allBUpdatableViews_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allBUpdatableViews_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allBUpdatableViews_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allBUpdatableViews_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allBUpdatableViews_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allCCompoundKeys_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allCCompoundKeys_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allCCompoundKeys_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allCCompoundKeys_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allCCompoundKeys_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allSimilarTable1S_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allSimilarTable1S_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allSimilarTable1S_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allSimilarTable1S_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allSimilarTable1S_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allSimilarTable2S_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allSimilarTable2S_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allSimilarTable2S_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allSimilarTable2S_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allSimilarTable2S_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allCNullTestRecords_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allCNullTestRecords_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allCNullTestRecords_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allCNullTestRecords_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allCNullTestRecords_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const resource_c_edge_casePgResource = registry.pgResources["c_edge_case"];
function Query_allCEdgeCases_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allCEdgeCases_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allCEdgeCases_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allCEdgeCases_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allCEdgeCases_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allCLeftArms_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allCLeftArms_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allCLeftArms_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allCLeftArms_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allCLeftArms_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allCIssue756S_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allCIssue756S_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allCIssue756S_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allCIssue756S_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allCIssue756S_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allPosts_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allPosts_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allPosts_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allPosts_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allPosts_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allCPeople_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allCPeople_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allCPeople_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allCPeople_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allCPeople_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allBTypes_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allBTypes_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allBTypes_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allBTypes_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allBTypes_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function CCompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function CCompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function CCompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function CCompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function CCompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function hasRecord($row) {
  return "record" in $row && typeof $row.record === "function";
}
const argDetailsSimple51 = [];
const makeArgs51 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple51[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_person_computed_outPgResource = registry.pgResources["c_person_computed_out"];
const argDetailsSimple52 = [];
const makeArgs52 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple52[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_person_first_namePgResource = registry.pgResources["c_person_first_name"];
const argDetailsSimple53 = [];
const makeArgs53 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple53[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_person_computed_out_outPgResource = registry.pgResources["c_person_computed_out_out"];
const argDetailsSimple54 = [{
  graphqlArgName: "ino",
  postgresArgName: "ino",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs54 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple54[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_person_computed_inoutPgResource = registry.pgResources["c_person_computed_inout"];
const argDetailsSimple55 = [{
  graphqlArgName: "ino",
  postgresArgName: "ino",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs55 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple55[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_person_computed_inout_outPgResource = registry.pgResources["c_person_computed_inout_out"];
const argDetailsSimple56 = [{
  graphqlArgName: "email",
  postgresArgName: "email",
  pgCodec: attributes_email_codec_bEmail,
  required: true,
  fetcher: null
}];
const makeArgs56 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple56[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_person_existsPgResource = registry.pgResources["c_person_exists"];
const argDetailsSimple57 = [];
const makeArgs57 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple57[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_person_computed_first_arg_inout_outPgResource = registry.pgResources["c_person_computed_first_arg_inout_out"];
const argDetailsSimple58 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs58 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple58[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_person_computed_complexPgResource = registry.pgResources["c_person_computed_complex"];
const argDetailsSimple59 = [];
const makeArgs59 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple59[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_person_first_postPgResource = registry.pgResources["c_person_first_post"];
const argDetailsSimple60 = [];
const makeArgs60 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple60[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_person_computed_first_arg_inoutPgResource = registry.pgResources["c_person_computed_first_arg_inout"];
const argDetailsSimple61 = [];
const makeArgs61 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple61[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_person_friendsPgResource = registry.pgResources["c_person_friends"];
const getSelectPlanFromParentAndArgs16 = ($in, args, _info) => {
  if (!hasRecord($in)) {
    throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
  }
  const extraSelectArgs = makeArgs61(args);
  /**
   * An optimisation - if all our dependencies are
   * compatible with the expression's class plan then we
   * can inline ourselves into that, otherwise we must
   * issue the query separately.
   */
  const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
  const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
  const selectArgs = [{
    step: $row.record()
  }, ...extraSelectArgs];
  if (resource_c_person_friendsPgResource.isUnique && !resource_c_person_friendsPgResource.codec.attributes && typeof resource_c_person_friendsPgResource.from === "function") {
    // This is a scalar computed attribute, let's inline the expression
    const placeholders = selectArgs.map((arg, i) => {
      if (i === 0) {
        return $row.getClassStep().alias;
      } else if ("pgCodec" in arg && arg.pgCodec) {
        return $row.placeholder(arg.step, arg.pgCodec);
      } else {
        return $row.placeholder(arg.step);
      }
    });
    return pgClassExpression($row, resource_c_person_friendsPgResource.codec)`${resource_c_person_friendsPgResource.from(...placeholders.map(placeholder => ({
      placeholder
    })))}`;
  }
  // PERF: or here, if scalar add select to `$row`?
  return resource_c_person_friendsPgResource.execute(selectArgs);
};
function CPerson_friends_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function CPerson_friends_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function CPerson_friends_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function CPerson_friends_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function CPerson_friends_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple62 = [];
const makeArgs62 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple62[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_person_type_function_connectionPgResource = registry.pgResources["c_person_type_function_connection"];
const getSelectPlanFromParentAndArgs17 = ($in, args, _info) => {
  if (!hasRecord($in)) {
    throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
  }
  const extraSelectArgs = makeArgs62(args);
  /**
   * An optimisation - if all our dependencies are
   * compatible with the expression's class plan then we
   * can inline ourselves into that, otherwise we must
   * issue the query separately.
   */
  const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
  const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
  const selectArgs = [{
    step: $row.record()
  }, ...extraSelectArgs];
  if (resource_c_person_type_function_connectionPgResource.isUnique && !resource_c_person_type_function_connectionPgResource.codec.attributes && typeof resource_c_person_type_function_connectionPgResource.from === "function") {
    // This is a scalar computed attribute, let's inline the expression
    const placeholders = selectArgs.map((arg, i) => {
      if (i === 0) {
        return $row.getClassStep().alias;
      } else if ("pgCodec" in arg && arg.pgCodec) {
        return $row.placeholder(arg.step, arg.pgCodec);
      } else {
        return $row.placeholder(arg.step);
      }
    });
    return pgClassExpression($row, resource_c_person_type_function_connectionPgResource.codec)`${resource_c_person_type_function_connectionPgResource.from(...placeholders.map(placeholder => ({
      placeholder
    })))}`;
  }
  // PERF: or here, if scalar add select to `$row`?
  return resource_c_person_type_function_connectionPgResource.execute(selectArgs);
};
function CPerson_typeFunctionConnection_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function CPerson_typeFunctionConnection_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function CPerson_typeFunctionConnection_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function CPerson_typeFunctionConnection_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function CPerson_typeFunctionConnection_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple63 = [{
  graphqlArgName: "id",
  postgresArgName: "id",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs63 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple63[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_person_type_functionPgResource = registry.pgResources["c_person_type_function"];
const argDetailsSimple64 = [];
const makeArgs64 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple64[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_person_type_function_listPgResource = registry.pgResources["c_person_type_function_list"];
const resource_frmcdc_bWrappedUrlPgResource = registry.pgResources["frmcdc_bWrappedUrl"];
function CPerson_postsByAuthorId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function CPerson_postsByAuthorId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function CPerson_postsByAuthorId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function CPerson_postsByAuthorId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function CPerson_postsByAuthorId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function CPerson_foreignKeysByPersonId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function CPerson_foreignKeysByPersonId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function CPerson_foreignKeysByPersonId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function CPerson_foreignKeysByPersonId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function CPerson_foreignKeysByPersonId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function CPerson_cCompoundKeysByPersonId1_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function CPerson_cCompoundKeysByPersonId1_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function CPerson_cCompoundKeysByPersonId1_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function CPerson_cCompoundKeysByPersonId1_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function CPerson_cCompoundKeysByPersonId1_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function CPerson_cCompoundKeysByPersonId2_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function CPerson_cCompoundKeysByPersonId2_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function CPerson_cCompoundKeysByPersonId2_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function CPerson_cCompoundKeysByPersonId2_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function CPerson_cCompoundKeysByPersonId2_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const resource_frmcdc_cCompoundTypePgResource = registry.pgResources["frmcdc_cCompoundType"];
const argDetailsSimple65 = [];
const makeArgs65 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple65[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const argDetailsSimple66 = [];
const makeArgs66 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple66[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const argDetailsSimple67 = [];
const makeArgs67 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple67[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const argDetailsSimple68 = [];
const makeArgs68 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple68[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
function Interval_secondsPlan($r) {
  return access($r, ["seconds"]);
}
function Interval_minutesPlan($r) {
  return access($r, ["minutes"]);
}
function Interval_hoursPlan($r) {
  return access($r, ["hours"]);
}
function Interval_daysPlan($r) {
  return access($r, ["days"]);
}
function Interval_monthsPlan($r) {
  return access($r, ["months"]);
}
function Interval_yearsPlan($r) {
  return access($r, ["years"]);
}
const argDetailsSimple69 = [];
const makeArgs69 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple69[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_computed_interval_setPgResource = registry.pgResources["post_computed_interval_set"];
const getSelectPlanFromParentAndArgs18 = ($in, args, _info) => {
  if (!hasRecord($in)) {
    throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
  }
  const extraSelectArgs = makeArgs69(args);
  /**
   * An optimisation - if all our dependencies are
   * compatible with the expression's class plan then we
   * can inline ourselves into that, otherwise we must
   * issue the query separately.
   */
  const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
  const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
  const selectArgs = [{
    step: $row.record()
  }, ...extraSelectArgs];
  if (resource_post_computed_interval_setPgResource.isUnique && !resource_post_computed_interval_setPgResource.codec.attributes && typeof resource_post_computed_interval_setPgResource.from === "function") {
    // This is a scalar computed attribute, let's inline the expression
    const placeholders = selectArgs.map((arg, i) => {
      if (i === 0) {
        return $row.getClassStep().alias;
      } else if ("pgCodec" in arg && arg.pgCodec) {
        return $row.placeholder(arg.step, arg.pgCodec);
      } else {
        return $row.placeholder(arg.step);
      }
    });
    return pgClassExpression($row, resource_post_computed_interval_setPgResource.codec)`${resource_post_computed_interval_setPgResource.from(...placeholders.map(placeholder => ({
      placeholder
    })))}`;
  }
  // PERF: or here, if scalar add select to `$row`?
  return resource_post_computed_interval_setPgResource.execute(selectArgs);
};
function Post_computedIntervalSet_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Post_computedIntervalSet_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Post_computedIntervalSet_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Post_computedIntervalSet_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Post_computedIntervalSet_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple70 = [];
const makeArgs70 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple70[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_computed_interval_arrayPgResource = registry.pgResources["post_computed_interval_array"];
const argDetailsSimple71 = [];
const makeArgs71 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple71[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_computed_text_arrayPgResource = registry.pgResources["post_computed_text_array"];
const argDetailsSimple72 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs72 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple72[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_computed_with_optional_argPgResource = registry.pgResources["post_computed_with_optional_arg"];
const argDetailsSimple73 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs73 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple73[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_computed_with_required_argPgResource = registry.pgResources["post_computed_with_required_arg"];
const argDetailsSimple74 = [{
  graphqlArgName: "length",
  postgresArgName: "length",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}, {
  graphqlArgName: "omission",
  postgresArgName: "omission",
  pgCodec: TYPES.text,
  required: false,
  fetcher: null
}];
const makeArgs74 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple74[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_headline_trimmedPgResource = registry.pgResources["post_headline_trimmed"];
const argDetailsSimple75 = [{
  graphqlArgName: "length",
  postgresArgName: "length",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "omission",
  postgresArgName: "omission",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs75 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple75[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_headline_trimmed_no_defaultsPgResource = registry.pgResources["post_headline_trimmed_no_defaults"];
const argDetailsSimple76 = [{
  graphqlArgName: "length",
  postgresArgName: "length",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}, {
  graphqlArgName: "omission",
  postgresArgName: "omission",
  pgCodec: TYPES.text,
  required: false,
  fetcher: null
}];
const makeArgs76 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple76[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_headline_trimmed_strictPgResource = registry.pgResources["post_headline_trimmed_strict"];
const argDetailsSimple77 = [{
  graphqlArgName: "object",
  postgresArgName: "object",
  pgCodec: attributes_o2_codec_cCompoundType,
  required: true,
  fetcher: null
}];
const makeArgs77 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple77[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_computed_compound_type_arrayPgResource = registry.pgResources["post_computed_compound_type_array"];
const resource_frmcdc_comptypePgResource = registry.pgResources["frmcdc_comptype"];
function Post_bTypesBySmallint_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Post_bTypesBySmallint_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Post_bTypesBySmallint_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Post_bTypesBySmallint_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Post_bTypesBySmallint_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function PostComputedIntervalSetConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function PostComputedIntervalSetConnection_edgesPlan($connection) {
  return $connection.edges();
}
function PostComputedIntervalSetConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function PageInfo_hasNextPagePlan($pageInfo) {
  return $pageInfo.hasNextPage();
}
function PageInfo_hasPreviousPagePlan($pageInfo) {
  return $pageInfo.hasPreviousPage();
}
function BTypeConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function BTypeConnection_edgesPlan($connection) {
  return $connection.edges();
}
function BTypeConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
const resource_frmcdc_bNestedCompoundTypePgResource = registry.pgResources["frmcdc_bNestedCompoundType"];
function CPersonConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function CPersonConnection_edgesPlan($connection) {
  return $connection.edges();
}
function CPersonConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function PostConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function PostConnection_edgesPlan($connection) {
  return $connection.edges();
}
function PostConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function ForeignKeyConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function ForeignKeyConnection_edgesPlan($connection) {
  return $connection.edges();
}
function ForeignKeyConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function CCompoundKeyConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function CCompoundKeyConnection_edgesPlan($connection) {
  return $connection.edges();
}
function CCompoundKeyConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function CFuncOutSetofConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function CFuncOutSetofConnection_edgesPlan($connection) {
  return $connection.edges();
}
function CFuncOutSetofConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function QueryIntervalSetConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function QueryIntervalSetConnection_edgesPlan($connection) {
  return $connection.edges();
}
function QueryIntervalSetConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function StaticBigIntegerConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function StaticBigIntegerConnection_edgesPlan($connection) {
  return $connection.edges();
}
function StaticBigIntegerConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function CFuncReturnsTableOneColConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function CFuncReturnsTableOneColConnection_edgesPlan($connection) {
  return $connection.edges();
}
function CFuncReturnsTableOneColConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function CFuncOutOutSetofConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function CFuncOutOutSetofConnection_edgesPlan($connection) {
  return $connection.edges();
}
function CFuncOutOutSetofConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function CSearchTestSummariesConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function CSearchTestSummariesConnection_edgesPlan($connection) {
  return $connection.edges();
}
function CSearchTestSummariesConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function CFuncReturnsTableMultiColConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function CFuncReturnsTableMultiColConnection_edgesPlan($connection) {
  return $connection.edges();
}
function CFuncReturnsTableMultiColConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function CIntSetQueryConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function CIntSetQueryConnection_edgesPlan($connection) {
  return $connection.edges();
}
function CIntSetQueryConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function CCompoundTypeConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function CCompoundTypeConnection_edgesPlan($connection) {
  return $connection.edges();
}
function CCompoundTypeConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function CFuncOutComplexSetofConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function CFuncOutComplexSetofConnection_edgesPlan($connection) {
  return $connection.edges();
}
function CFuncOutComplexSetofConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function NonUpdatableViewConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function NonUpdatableViewConnection_edgesPlan($connection) {
  return $connection.edges();
}
function NonUpdatableViewConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function InputConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function InputConnection_edgesPlan($connection) {
  return $connection.edges();
}
function InputConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function PatchConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function PatchConnection_edgesPlan($connection) {
  return $connection.edges();
}
function PatchConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function ReservedConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function ReservedConnection_edgesPlan($connection) {
  return $connection.edges();
}
function ReservedConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function ReservedPatchRecordConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function ReservedPatchRecordConnection_edgesPlan($connection) {
  return $connection.edges();
}
function ReservedPatchRecordConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function ReservedInputRecordConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function ReservedInputRecordConnection_edgesPlan($connection) {
  return $connection.edges();
}
function ReservedInputRecordConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function DefaultValueConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function DefaultValueConnection_edgesPlan($connection) {
  return $connection.edges();
}
function DefaultValueConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function NoPrimaryKeyConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function NoPrimaryKeyConnection_edgesPlan($connection) {
  return $connection.edges();
}
function NoPrimaryKeyConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function TestviewConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function TestviewConnection_edgesPlan($connection) {
  return $connection.edges();
}
function TestviewConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function UniqueForeignKeyConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function UniqueForeignKeyConnection_edgesPlan($connection) {
  return $connection.edges();
}
function UniqueForeignKeyConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function CMyTableConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function CMyTableConnection_edgesPlan($connection) {
  return $connection.edges();
}
function CMyTableConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function CPersonSecretConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function CPersonSecretConnection_edgesPlan($connection) {
  return $connection.edges();
}
function CPersonSecretConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function ViewTableConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function ViewTableConnection_edgesPlan($connection) {
  return $connection.edges();
}
function ViewTableConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function BUpdatableViewConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function BUpdatableViewConnection_edgesPlan($connection) {
  return $connection.edges();
}
function BUpdatableViewConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function SimilarTable1Connection_nodesPlan($connection) {
  return $connection.nodes();
}
function SimilarTable1Connection_edgesPlan($connection) {
  return $connection.edges();
}
function SimilarTable1Connection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function SimilarTable2Connection_nodesPlan($connection) {
  return $connection.nodes();
}
function SimilarTable2Connection_edgesPlan($connection) {
  return $connection.edges();
}
function SimilarTable2Connection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function CNullTestRecordConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function CNullTestRecordConnection_edgesPlan($connection) {
  return $connection.edges();
}
function CNullTestRecordConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function CEdgeCaseConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function CEdgeCaseConnection_edgesPlan($connection) {
  return $connection.edges();
}
function CEdgeCaseConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
const argDetailsSimple78 = [];
const makeArgs78 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple78[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_edge_case_computedPgResource = registry.pgResources["c_edge_case_computed"];
function CLeftArmConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function CLeftArmConnection_edgesPlan($connection) {
  return $connection.edges();
}
function CLeftArmConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function CIssue756Connection_nodesPlan($connection) {
  return $connection.nodes();
}
function CIssue756Connection_edgesPlan($connection) {
  return $connection.edges();
}
function CIssue756Connection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
const argDetailsSimple79 = [];
const makeArgs79 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple79[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_mutation_outPgResource = registry.pgResources["c_mutation_out"];
function Mutation_cMutationOut_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple80 = [];
const makeArgs80 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple80[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_mutation_out_setofPgResource = registry.pgResources["c_mutation_out_setof"];
function Mutation_cMutationOutSetof_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple81 = [];
const makeArgs81 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple81[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_mutation_out_unnamedPgResource = registry.pgResources["c_mutation_out_unnamed"];
function Mutation_cMutationOutUnnamed_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple82 = [];
const makeArgs82 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple82[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_no_args_mutationPgResource = registry.pgResources["c_no_args_mutation"];
function Mutation_cNoArgsMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple83 = [];
const makeArgs83 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple83[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_return_void_mutationPgResource = registry.pgResources["return_void_mutation"];
function Mutation_returnVoidMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple84 = [];
const makeArgs84 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple84[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_interval_setPgResource = registry.pgResources["mutation_interval_set"];
function Mutation_mutationIntervalSet_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple85 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs85 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple85[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_mutation_in_outPgResource = registry.pgResources["c_mutation_in_out"];
function Mutation_cMutationInOut_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple86 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs86 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple86[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_mutation_returns_table_one_colPgResource = registry.pgResources["c_mutation_returns_table_one_col"];
function Mutation_cMutationReturnsTableOneCol_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple87 = [{
  graphqlArgName: "json",
  postgresArgName: "json",
  pgCodec: TYPES.json,
  required: true,
  fetcher: null
}];
const makeArgs87 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple87[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_json_identity_mutationPgResource = registry.pgResources["c_json_identity_mutation"];
function Mutation_cJsonIdentityMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple88 = [{
  graphqlArgName: "json",
  postgresArgName: "json",
  pgCodec: TYPES.jsonb,
  required: true,
  fetcher: null
}];
const makeArgs88 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple88[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_jsonb_identity_mutationPgResource = registry.pgResources["c_jsonb_identity_mutation"];
function Mutation_cJsonbIdentityMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple89 = [{
  graphqlArgName: "_theJson",
  postgresArgName: "_the_json",
  pgCodec: TYPES.jsonb,
  required: true,
  fetcher: null
}];
const makeArgs89 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple89[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_jsonb_identity_mutation_plpgsqlPgResource = registry.pgResources["c_jsonb_identity_mutation_plpgsql"];
function Mutation_cJsonbIdentityMutationPlpgsql_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple90 = [{
  graphqlArgName: "_theJson",
  postgresArgName: "_the_json",
  pgCodec: TYPES.jsonb,
  required: false,
  fetcher: null
}];
const makeArgs90 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple90[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_jsonb_identity_mutation_plpgsql_with_defaultPgResource = registry.pgResources["c_jsonb_identity_mutation_plpgsql_with_default"];
function Mutation_cJsonbIdentityMutationPlpgsqlWithDefault_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple91 = [{
  graphqlArgName: "arg0",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs91 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple91[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_1_mutationPgResource = registry.pgResources["add_1_mutation"];
function Mutation_add1Mutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple92 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs92 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple92[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_2_mutationPgResource = registry.pgResources["add_2_mutation"];
function Mutation_add2Mutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple93 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs93 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple93[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_3_mutationPgResource = registry.pgResources["add_3_mutation"];
function Mutation_add3Mutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple94 = [{
  graphqlArgName: "arg0",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs94 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple94[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 1 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_4_mutationPgResource = registry.pgResources["add_4_mutation"];
function Mutation_add4Mutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple95 = [{
  graphqlArgName: "arg0",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs95 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple95[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 1 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_4_mutation_errorPgResource = registry.pgResources["add_4_mutation_error"];
function Mutation_add4MutationError_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple96 = [{
  graphqlArgName: "arg0",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs96 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple96[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_mult_1PgResource = registry.pgResources["b_mult_1"];
function Mutation_bMult1_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple97 = [{
  graphqlArgName: "arg0",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs97 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple97[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_mult_2PgResource = registry.pgResources["b_mult_2"];
function Mutation_bMult2_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple98 = [{
  graphqlArgName: "arg0",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs98 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple98[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_mult_3PgResource = registry.pgResources["b_mult_3"];
function Mutation_bMult3_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple99 = [{
  graphqlArgName: "arg0",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs99 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple99[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_mult_4PgResource = registry.pgResources["b_mult_4"];
function Mutation_bMult4_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple100 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "ino",
  postgresArgName: "ino",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs100 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple100[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_mutation_in_inoutPgResource = registry.pgResources["c_mutation_in_inout"];
function Mutation_cMutationInInout_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple101 = [];
const makeArgs101 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple101[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_mutation_out_outPgResource = registry.pgResources["c_mutation_out_out"];
function Mutation_cMutationOutOut_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple102 = [];
const makeArgs102 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple102[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_mutation_out_out_setofPgResource = registry.pgResources["c_mutation_out_out_setof"];
function Mutation_cMutationOutOutSetof_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple103 = [];
const makeArgs103 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple103[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_mutation_out_out_unnamedPgResource = registry.pgResources["c_mutation_out_out_unnamed"];
function Mutation_cMutationOutOutUnnamed_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple104 = [{
  graphqlArgName: "x",
  postgresArgName: "x",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "y",
  postgresArgName: "y",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "z",
  postgresArgName: "z",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs104 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple104[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_int_set_mutationPgResource = registry.pgResources["c_int_set_mutation"];
function Mutation_cIntSetMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple105 = [];
const makeArgs105 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple105[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_mutation_out_unnamed_out_out_unnamedPgResource = registry.pgResources["c_mutation_out_unnamed_out_out_unnamed"];
function Mutation_cMutationOutUnnamedOutOutUnnamed_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple106 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs106 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple106[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_mutation_returns_table_multi_colPgResource = registry.pgResources["c_mutation_returns_table_multi_col"];
function Mutation_cMutationReturnsTableMultiCol_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple107 = [{
  graphqlArgName: "g",
  postgresArgName: "g",
  pgCodec: registryConfig_pgCodecs_bGuid_bGuid,
  required: true,
  fetcher: null
}];
const makeArgs107 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple107[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_guid_fnPgResource = registry.pgResources["b_guid_fn"];
function Mutation_bGuidFn_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple108 = [];
const makeArgs108 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple108[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_interval_arrayPgResource = registry.pgResources["mutation_interval_array"];
function Mutation_mutationIntervalArray_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple109 = [];
const makeArgs109 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple109[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_text_arrayPgResource = registry.pgResources["mutation_text_array"];
function Mutation_mutationTextArray_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple110 = [{
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: registryConfig_pgCodecs_pgCatalogTextArray_pgCatalogTextArray,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "d",
  postgresArgName: "d",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "e",
  postgresArgName: "e",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs110 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple110[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_list_bde_mutationPgResource = registry.pgResources["b_list_bde_mutation"];
function Mutation_bListBdeMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple111 = [];
const makeArgs111 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple111[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_authenticate_failPgResource = registry.pgResources["b_authenticate_fail"];
function Mutation_bAuthenticateFail_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple112 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.numeric,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "c",
  postgresArgName: "c",
  pgCodec: TYPES.bigint,
  required: true,
  fetcher: null
}];
const makeArgs112 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple112[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_authenticatePgResource = registry.pgResources["b_authenticate"];
function Mutation_bAuthenticate_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple113 = [{
  graphqlArgName: "leftArm",
  postgresArgName: "left_arm",
  pgCodec: registryConfig_pgCodecs_cLeftArm_cLeftArm,
  required: true,
  fetcher: null
}];
const makeArgs113 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple113[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_left_arm_identityPgResource = registry.pgResources["c_left_arm_identity"];
function Mutation_cLeftArmIdentity_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple114 = [];
const makeArgs114 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple114[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_issue756_mutationPgResource = registry.pgResources["c_issue756_mutation"];
function Mutation_cIssue756Mutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple115 = [];
const makeArgs115 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple115[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_issue756_set_mutationPgResource = registry.pgResources["c_issue756_set_mutation"];
function Mutation_cIssue756SetMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple116 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.numeric,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "c",
  postgresArgName: "c",
  pgCodec: TYPES.bigint,
  required: true,
  fetcher: null
}];
const makeArgs116 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple116[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_authenticate_manyPgResource = registry.pgResources["b_authenticate_many"];
function Mutation_bAuthenticateMany_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple117 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.numeric,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "c",
  postgresArgName: "c",
  pgCodec: TYPES.bigint,
  required: true,
  fetcher: null
}];
const makeArgs117 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple117[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_authenticate_payloadPgResource = registry.pgResources["b_authenticate_payload"];
function Mutation_bAuthenticatePayload_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple118 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.bigint,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.boolean,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "c",
  postgresArgName: "c",
  pgCodec: TYPES.varchar,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "d",
  postgresArgName: "d",
  pgCodec: registryConfig_pgCodecs_pgCatalogInt4Array_pgCatalogInt4Array,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "e",
  postgresArgName: "e",
  pgCodec: TYPES.json,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "f",
  postgresArgName: "f",
  pgCodec: registryConfig_pgCodecs_cFloatrange_cFloatrange,
  required: true,
  fetcher: null
}];
const makeArgs118 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 6; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple118[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_types_mutationPgResource = registry.pgResources["c_types_mutation"];
function Mutation_cTypesMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple119 = [{
  graphqlArgName: "i1",
  postgresArgName: "i1",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs119 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple119[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_mutation_out_out_compound_typePgResource = registry.pgResources["c_mutation_out_out_compound_type"];
function Mutation_cMutationOutOutCompoundType_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple120 = [{
  graphqlArgName: "object",
  postgresArgName: "object",
  pgCodec: attributes_o2_codec_cCompoundType,
  required: true,
  fetcher: null
}];
const makeArgs120 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple120[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_compound_type_mutationPgResource = registry.pgResources["b_compound_type_mutation"];
function Mutation_bCompoundTypeMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple121 = [{
  graphqlArgName: "object",
  postgresArgName: "object",
  pgCodec: attributes_o2_codec_cCompoundType,
  required: true,
  fetcher: null
}];
const makeArgs121 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple121[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_compound_type_set_mutationPgResource = registry.pgResources["b_compound_type_set_mutation"];
function Mutation_bCompoundTypeSetMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple122 = [{
  graphqlArgName: "id",
  postgresArgName: "id",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs122 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple122[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_table_mutationPgResource = registry.pgResources["c_table_mutation"];
function Mutation_cTableMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple123 = [{
  graphqlArgName: "post",
  postgresArgName: "post",
  pgCodec: attributes_post_codec_post,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "suffix",
  postgresArgName: "suffix",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs123 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple123[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_with_suffixPgResource = registry.pgResources["post_with_suffix"];
function Mutation_postWithSuffix_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple124 = [{
  graphqlArgName: "object",
  postgresArgName: "object",
  pgCodec: attributes_o2_codec_cCompoundType,
  required: true,
  fetcher: null
}];
const makeArgs124 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple124[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_compound_type_arrayPgResource = registry.pgResources["mutation_compound_type_array"];
function Mutation_mutationCompoundTypeArray_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple125 = [{
  graphqlArgName: "object",
  postgresArgName: "object",
  pgCodec: attributes_o2_codec_cCompoundType,
  required: true,
  fetcher: null
}];
const makeArgs125 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple125[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_compound_type_array_mutationPgResource = registry.pgResources["b_compound_type_array_mutation"];
function Mutation_bCompoundTypeArrayMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple126 = [{
  graphqlArgName: "posts",
  postgresArgName: "posts",
  pgCodec: registryConfig_pgCodecs_postArray_postArray,
  required: true,
  fetcher: null
}];
const makeArgs126 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple126[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_manyPgResource = registry.pgResources["post_many"];
function Mutation_postMany_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple127 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs127 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple127[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_mutation_out_complexPgResource = registry.pgResources["c_mutation_out_complex"];
function Mutation_cMutationOutComplex_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple128 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs128 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple128[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_mutation_out_complex_setofPgResource = registry.pgResources["c_mutation_out_complex_setof"];
function Mutation_cMutationOutComplexSetof_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple129 = [];
const makeArgs129 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple129[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_mutation_out_tablePgResource = registry.pgResources["c_mutation_out_table"];
function Mutation_cMutationOutTable_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple130 = [];
const makeArgs130 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple130[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_mutation_out_table_setofPgResource = registry.pgResources["c_mutation_out_table_setof"];
function Mutation_cMutationOutTableSetof_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple131 = [];
const makeArgs131 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple131[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_c_table_set_mutationPgResource = registry.pgResources["c_table_set_mutation"];
function Mutation_cTableSetMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple132 = [];
const makeArgs132 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple132[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_type_function_connection_mutationPgResource = registry.pgResources["b_type_function_connection_mutation"];
function Mutation_bTypeFunctionConnectionMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple133 = [{
  graphqlArgName: "id",
  postgresArgName: "id",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs133 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple133[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_type_function_mutationPgResource = registry.pgResources["b_type_function_mutation"];
function Mutation_bTypeFunctionMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple134 = [];
const makeArgs134 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple134[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_b_type_function_list_mutationPgResource = registry.pgResources["b_type_function_list_mutation"];
function Mutation_bTypeFunctionListMutation_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createInput_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createPatch_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createReserved_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createReservedPatchRecord_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createReservedInputRecord_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createDefaultValue_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createForeignKey_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createNoPrimaryKey_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createTestview_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createUniqueForeignKey_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createCMyTable_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createCPersonSecret_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createViewTable_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createBUpdatableView_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createCCompoundKey_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createSimilarTable1_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createSimilarTable2_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createCNullTestRecord_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createCEdgeCase_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createCLeftArm_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createCIssue756_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createPost_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createCPerson_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createBType_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateInputByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updatePatchByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateReservedByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateReservedPatchRecordByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateReservedInputRecordByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateDefaultValueByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateNoPrimaryKeyByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateUniqueForeignKeyByCompoundKey1AndCompoundKey2_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateCMyTableByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateCPersonSecretByPersonId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateViewTableByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateCCompoundKeyByPersonId1AndPersonId2_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateSimilarTable1ByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateSimilarTable2ByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateCNullTestRecordByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateCLeftArmByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateCLeftArmByPersonId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateCIssue756ByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updatePostByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateCPersonByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateCPersonByEmail_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateBTypeByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteInputByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deletePatchByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteReservedByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteReservedPatchRecordByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteReservedInputRecordByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteDefaultValueByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteNoPrimaryKeyByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteUniqueForeignKeyByCompoundKey1AndCompoundKey2_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteCMyTableByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteCPersonSecretByPersonId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteViewTableByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteCCompoundKeyByPersonId1AndPersonId2_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteSimilarTable1ByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteSimilarTable2ByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteCNullTestRecordByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteCLeftArmByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteCLeftArmByPersonId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteCIssue756ByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deletePostByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteCPersonByRowId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteCPersonByEmail_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteBTypeByRowId_input_applyPlan(_, $object) {
  return $object;
}
function CMutationOutPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CMutationOutPayload_queryPlan() {
  return rootValue();
}
function CMutationOutInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CMutationOutSetofPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CMutationOutSetofPayload_queryPlan() {
  return rootValue();
}
function CMutationOutSetofInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CMutationOutUnnamedPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CMutationOutUnnamedPayload_queryPlan() {
  return rootValue();
}
function CMutationOutUnnamedInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CNoArgsMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CNoArgsMutationPayload_queryPlan() {
  return rootValue();
}
function CNoArgsMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function ReturnVoidMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function ReturnVoidMutationPayload_queryPlan() {
  return rootValue();
}
function ReturnVoidMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationIntervalSetPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationIntervalSetPayload_queryPlan() {
  return rootValue();
}
function MutationIntervalSetInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CMutationInOutPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CMutationInOutPayload_queryPlan() {
  return rootValue();
}
function CMutationInOutInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CMutationReturnsTableOneColPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CMutationReturnsTableOneColPayload_queryPlan() {
  return rootValue();
}
function CMutationReturnsTableOneColInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CJsonIdentityMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CJsonIdentityMutationPayload_queryPlan() {
  return rootValue();
}
function CJsonIdentityMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CJsonbIdentityMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CJsonbIdentityMutationPayload_queryPlan() {
  return rootValue();
}
function CJsonbIdentityMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CJsonbIdentityMutationPlpgsqlPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CJsonbIdentityMutationPlpgsqlPayload_queryPlan() {
  return rootValue();
}
function CJsonbIdentityMutationPlpgsqlInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CJsonbIdentityMutationPlpgsqlWithDefaultPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CJsonbIdentityMutationPlpgsqlWithDefaultPayload_queryPlan() {
  return rootValue();
}
function CJsonbIdentityMutationPlpgsqlWithDefaultInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function Add1MutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function Add1MutationPayload_queryPlan() {
  return rootValue();
}
function Add1MutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function Add2MutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function Add2MutationPayload_queryPlan() {
  return rootValue();
}
function Add2MutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function Add3MutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function Add3MutationPayload_queryPlan() {
  return rootValue();
}
function Add3MutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function Add4MutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function Add4MutationPayload_queryPlan() {
  return rootValue();
}
function Add4MutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function Add4MutationErrorPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function Add4MutationErrorPayload_queryPlan() {
  return rootValue();
}
function Add4MutationErrorInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function BMult1Payload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function BMult1Payload_queryPlan() {
  return rootValue();
}
function BMult1Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function BMult2Payload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function BMult2Payload_queryPlan() {
  return rootValue();
}
function BMult2Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function BMult3Payload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function BMult3Payload_queryPlan() {
  return rootValue();
}
function BMult3Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function BMult4Payload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function BMult4Payload_queryPlan() {
  return rootValue();
}
function BMult4Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CMutationInInoutPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CMutationInInoutPayload_queryPlan() {
  return rootValue();
}
function CMutationInInoutInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CMutationOutOutPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CMutationOutOutPayload_queryPlan() {
  return rootValue();
}
function CMutationOutOutInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CMutationOutOutSetofPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CMutationOutOutSetofPayload_queryPlan() {
  return rootValue();
}
function CMutationOutOutSetofInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CMutationOutOutUnnamedPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CMutationOutOutUnnamedPayload_queryPlan() {
  return rootValue();
}
function CMutationOutOutUnnamedInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CIntSetMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CIntSetMutationPayload_queryPlan() {
  return rootValue();
}
function CIntSetMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CMutationOutUnnamedOutOutUnnamedPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CMutationOutUnnamedOutOutUnnamedPayload_queryPlan() {
  return rootValue();
}
function CMutationOutUnnamedOutOutUnnamedInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CMutationReturnsTableMultiColPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CMutationReturnsTableMultiColPayload_queryPlan() {
  return rootValue();
}
function CMutationReturnsTableMultiColInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function BGuidFnPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function BGuidFnPayload_queryPlan() {
  return rootValue();
}
function BGuidFnInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationIntervalArrayPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationIntervalArrayPayload_queryPlan() {
  return rootValue();
}
function MutationIntervalArrayInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationTextArrayPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationTextArrayPayload_queryPlan() {
  return rootValue();
}
function MutationTextArrayInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function BListBdeMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function BListBdeMutationPayload_queryPlan() {
  return rootValue();
}
function BListBdeMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function BAuthenticateFailPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function BAuthenticateFailPayload_queryPlan() {
  return rootValue();
}
function BAuthenticateFailInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function BAuthenticatePayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function BAuthenticatePayload_queryPlan() {
  return rootValue();
}
function BAuthenticateInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CLeftArmIdentityPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CLeftArmIdentityPayload_queryPlan() {
  return rootValue();
}
function CLeftArmIdentityInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CIssue756MutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CIssue756MutationPayload_queryPlan() {
  return rootValue();
}
function CIssue756MutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CIssue756SetMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CIssue756SetMutationPayload_queryPlan() {
  return rootValue();
}
function CIssue756SetMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function BAuthenticateManyPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function BAuthenticateManyPayload_queryPlan() {
  return rootValue();
}
function BAuthenticateManyInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function BAuthenticatePayloadPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function BAuthenticatePayloadPayload_queryPlan() {
  return rootValue();
}
const resource_frmcdc_bJwtTokenPgResource = registry.pgResources["frmcdc_bJwtToken"];
function BAuthenticatePayloadInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CTypesMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CTypesMutationPayload_queryPlan() {
  return rootValue();
}
function CTypesMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CMutationOutOutCompoundTypePayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CMutationOutOutCompoundTypePayload_queryPlan() {
  return rootValue();
}
function CMutationOutOutCompoundTypeInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function BCompoundTypeMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function BCompoundTypeMutationPayload_queryPlan() {
  return rootValue();
}
function BCompoundTypeMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function BCompoundTypeSetMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function BCompoundTypeSetMutationPayload_queryPlan() {
  return rootValue();
}
function BCompoundTypeSetMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CTableMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CTableMutationPayload_queryPlan() {
  return rootValue();
}
function CTableMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function PostWithSuffixPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function PostWithSuffixPayload_queryPlan() {
  return rootValue();
}
function PostWithSuffixInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationCompoundTypeArrayPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationCompoundTypeArrayPayload_queryPlan() {
  return rootValue();
}
function MutationCompoundTypeArrayInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function BCompoundTypeArrayMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function BCompoundTypeArrayMutationPayload_queryPlan() {
  return rootValue();
}
function BCompoundTypeArrayMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function PostManyPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function PostManyPayload_queryPlan() {
  return rootValue();
}
function PostManyInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CMutationOutComplexPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CMutationOutComplexPayload_queryPlan() {
  return rootValue();
}
function CMutationOutComplexInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CMutationOutComplexSetofPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CMutationOutComplexSetofPayload_queryPlan() {
  return rootValue();
}
function CMutationOutComplexSetofInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CMutationOutTablePayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CMutationOutTablePayload_queryPlan() {
  return rootValue();
}
function CMutationOutTableInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CMutationOutTableSetofPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CMutationOutTableSetofPayload_queryPlan() {
  return rootValue();
}
function CMutationOutTableSetofInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CTableSetMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CTableSetMutationPayload_queryPlan() {
  return rootValue();
}
function CTableSetMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function BTypeFunctionConnectionMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function BTypeFunctionConnectionMutationPayload_queryPlan() {
  return rootValue();
}
function BTypeFunctionConnectionMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function BTypeFunctionMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function BTypeFunctionMutationPayload_queryPlan() {
  return rootValue();
}
function BTypeFunctionMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function BTypeFunctionListMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function BTypeFunctionListMutationPayload_queryPlan() {
  return rootValue();
}
function BTypeFunctionListMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateInputPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateInputPayload_inputPlan($object) {
  return $object.get("result");
}
function CreateInputPayload_queryPlan() {
  return rootValue();
}
function CreateInputInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateInputInput_input_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreatePatchPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreatePatchPayload_patchPlan($object) {
  return $object.get("result");
}
function CreatePatchPayload_queryPlan() {
  return rootValue();
}
function CreatePatchInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreatePatchInput_patch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateReservedPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateReservedPayload_reservedPlan($object) {
  return $object.get("result");
}
function CreateReservedPayload_queryPlan() {
  return rootValue();
}
function CreateReservedInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateReservedInput_reserved_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateReservedPatchRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateReservedPatchRecordPayload_reservedPatchRecordPlan($object) {
  return $object.get("result");
}
function CreateReservedPatchRecordPayload_queryPlan() {
  return rootValue();
}
function CreateReservedPatchRecordInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateReservedPatchRecordInput_reservedPatchRecord_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateReservedInputRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateReservedInputRecordPayload_reservedInputRecordPlan($object) {
  return $object.get("result");
}
function CreateReservedInputRecordPayload_queryPlan() {
  return rootValue();
}
function CreateReservedInputRecordInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateReservedInputRecordInput_reservedInputRecord_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateDefaultValuePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateDefaultValuePayload_defaultValuePlan($object) {
  return $object.get("result");
}
function CreateDefaultValuePayload_queryPlan() {
  return rootValue();
}
function CreateDefaultValueInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateDefaultValueInput_defaultValue_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateForeignKeyPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateForeignKeyPayload_foreignKeyPlan($object) {
  return $object.get("result");
}
function CreateForeignKeyPayload_queryPlan() {
  return rootValue();
}
function CreateForeignKeyInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateForeignKeyInput_foreignKey_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateNoPrimaryKeyPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateNoPrimaryKeyPayload_noPrimaryKeyPlan($object) {
  return $object.get("result");
}
function CreateNoPrimaryKeyPayload_queryPlan() {
  return rootValue();
}
function CreateNoPrimaryKeyInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateNoPrimaryKeyInput_noPrimaryKey_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateTestviewPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateTestviewPayload_testviewPlan($object) {
  return $object.get("result");
}
function CreateTestviewPayload_queryPlan() {
  return rootValue();
}
function CreateTestviewInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateTestviewInput_testview_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateUniqueForeignKeyPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateUniqueForeignKeyPayload_uniqueForeignKeyPlan($object) {
  return $object.get("result");
}
function CreateUniqueForeignKeyPayload_queryPlan() {
  return rootValue();
}
function CreateUniqueForeignKeyInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateUniqueForeignKeyInput_uniqueForeignKey_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateCMyTablePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateCMyTablePayload_cMyTablePlan($object) {
  return $object.get("result");
}
function CreateCMyTablePayload_queryPlan() {
  return rootValue();
}
function CreateCMyTableInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateCMyTableInput_cMyTable_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateCPersonSecretPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateCPersonSecretPayload_cPersonSecretPlan($object) {
  return $object.get("result");
}
function CreateCPersonSecretPayload_queryPlan() {
  return rootValue();
}
function CreateCPersonSecretInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateCPersonSecretInput_cPersonSecret_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateViewTablePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateViewTablePayload_viewTablePlan($object) {
  return $object.get("result");
}
function CreateViewTablePayload_queryPlan() {
  return rootValue();
}
function CreateViewTableInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateViewTableInput_viewTable_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateBUpdatableViewPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateBUpdatableViewPayload_bUpdatableViewPlan($object) {
  return $object.get("result");
}
function CreateBUpdatableViewPayload_queryPlan() {
  return rootValue();
}
function CreateBUpdatableViewInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateBUpdatableViewInput_bUpdatableView_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateCCompoundKeyPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateCCompoundKeyPayload_cCompoundKeyPlan($object) {
  return $object.get("result");
}
function CreateCCompoundKeyPayload_queryPlan() {
  return rootValue();
}
function CreateCCompoundKeyInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateCCompoundKeyInput_cCompoundKey_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateSimilarTable1Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateSimilarTable1Payload_similarTable1Plan($object) {
  return $object.get("result");
}
function CreateSimilarTable1Payload_queryPlan() {
  return rootValue();
}
function CreateSimilarTable1Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateSimilarTable1Input_similarTable1_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateSimilarTable2Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateSimilarTable2Payload_similarTable2Plan($object) {
  return $object.get("result");
}
function CreateSimilarTable2Payload_queryPlan() {
  return rootValue();
}
function CreateSimilarTable2Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateSimilarTable2Input_similarTable2_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateCNullTestRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateCNullTestRecordPayload_cNullTestRecordPlan($object) {
  return $object.get("result");
}
function CreateCNullTestRecordPayload_queryPlan() {
  return rootValue();
}
function CreateCNullTestRecordInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateCNullTestRecordInput_cNullTestRecord_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateCEdgeCasePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateCEdgeCasePayload_cEdgeCasePlan($object) {
  return $object.get("result");
}
function CreateCEdgeCasePayload_queryPlan() {
  return rootValue();
}
function CreateCEdgeCaseInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateCEdgeCaseInput_cEdgeCase_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateCLeftArmPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateCLeftArmPayload_cLeftArmPlan($object) {
  return $object.get("result");
}
function CreateCLeftArmPayload_queryPlan() {
  return rootValue();
}
function CreateCLeftArmInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateCLeftArmInput_cLeftArm_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateCIssue756Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateCIssue756Payload_cIssue756Plan($object) {
  return $object.get("result");
}
function CreateCIssue756Payload_queryPlan() {
  return rootValue();
}
function CreateCIssue756Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateCIssue756Input_cIssue756_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreatePostPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreatePostPayload_postPlan($object) {
  return $object.get("result");
}
function CreatePostPayload_queryPlan() {
  return rootValue();
}
function CreatePostInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreatePostInput_post_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateCPersonPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateCPersonPayload_cPersonPlan($object) {
  return $object.get("result");
}
function CreateCPersonPayload_queryPlan() {
  return rootValue();
}
function CreateCPersonInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateCPersonInput_cPerson_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateBTypePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateBTypePayload_bTypePlan($object) {
  return $object.get("result");
}
function CreateBTypePayload_queryPlan() {
  return rootValue();
}
function CreateBTypeInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateBTypeInput_bType_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateInputPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateInputPayload_inputPlan($object) {
  return $object.get("result");
}
function UpdateInputPayload_queryPlan() {
  return rootValue();
}
function UpdateInputByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateInputByRowIdInput_inputPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdatePatchPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdatePatchPayload_patchPlan($object) {
  return $object.get("result");
}
function UpdatePatchPayload_queryPlan() {
  return rootValue();
}
function UpdatePatchByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdatePatchByRowIdInput_patchPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateReservedPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateReservedPayload_reservedPlan($object) {
  return $object.get("result");
}
function UpdateReservedPayload_queryPlan() {
  return rootValue();
}
function UpdateReservedByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateReservedByRowIdInput_reservedPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateReservedPatchRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateReservedPatchRecordPayload_reservedPatchRecordPlan($object) {
  return $object.get("result");
}
function UpdateReservedPatchRecordPayload_queryPlan() {
  return rootValue();
}
function UpdateReservedPatchRecordByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateReservedPatchRecordByRowIdInput_reservedPatchRecordPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateReservedInputRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateReservedInputRecordPayload_reservedInputRecordPlan($object) {
  return $object.get("result");
}
function UpdateReservedInputRecordPayload_queryPlan() {
  return rootValue();
}
function UpdateReservedInputRecordByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateReservedInputRecordByRowIdInput_reservedInputRecordPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateDefaultValuePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateDefaultValuePayload_defaultValuePlan($object) {
  return $object.get("result");
}
function UpdateDefaultValuePayload_queryPlan() {
  return rootValue();
}
function UpdateDefaultValueByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateDefaultValueByRowIdInput_defaultValuePatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateNoPrimaryKeyPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateNoPrimaryKeyPayload_noPrimaryKeyPlan($object) {
  return $object.get("result");
}
function UpdateNoPrimaryKeyPayload_queryPlan() {
  return rootValue();
}
function UpdateNoPrimaryKeyByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateNoPrimaryKeyByRowIdInput_noPrimaryKeyPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateUniqueForeignKeyPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateUniqueForeignKeyPayload_uniqueForeignKeyPlan($object) {
  return $object.get("result");
}
function UpdateUniqueForeignKeyPayload_queryPlan() {
  return rootValue();
}
function UpdateUniqueForeignKeyByCompoundKey1AndCompoundKey2Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateUniqueForeignKeyByCompoundKey1AndCompoundKey2Input_uniqueForeignKeyPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateCMyTablePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateCMyTablePayload_cMyTablePlan($object) {
  return $object.get("result");
}
function UpdateCMyTablePayload_queryPlan() {
  return rootValue();
}
function UpdateCMyTableByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateCMyTableByRowIdInput_cMyTablePatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateCPersonSecretPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateCPersonSecretPayload_cPersonSecretPlan($object) {
  return $object.get("result");
}
function UpdateCPersonSecretPayload_queryPlan() {
  return rootValue();
}
function UpdateCPersonSecretByPersonIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateCPersonSecretByPersonIdInput_cPersonSecretPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateViewTablePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateViewTablePayload_viewTablePlan($object) {
  return $object.get("result");
}
function UpdateViewTablePayload_queryPlan() {
  return rootValue();
}
function UpdateViewTableByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateViewTableByRowIdInput_viewTablePatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateCCompoundKeyPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateCCompoundKeyPayload_cCompoundKeyPlan($object) {
  return $object.get("result");
}
function UpdateCCompoundKeyPayload_queryPlan() {
  return rootValue();
}
function UpdateCCompoundKeyByPersonId1AndPersonId2Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateCCompoundKeyByPersonId1AndPersonId2Input_cCompoundKeyPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateSimilarTable1Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateSimilarTable1Payload_similarTable1Plan($object) {
  return $object.get("result");
}
function UpdateSimilarTable1Payload_queryPlan() {
  return rootValue();
}
function UpdateSimilarTable1ByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateSimilarTable1ByRowIdInput_similarTable1Patch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateSimilarTable2Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateSimilarTable2Payload_similarTable2Plan($object) {
  return $object.get("result");
}
function UpdateSimilarTable2Payload_queryPlan() {
  return rootValue();
}
function UpdateSimilarTable2ByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateSimilarTable2ByRowIdInput_similarTable2Patch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateCNullTestRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateCNullTestRecordPayload_cNullTestRecordPlan($object) {
  return $object.get("result");
}
function UpdateCNullTestRecordPayload_queryPlan() {
  return rootValue();
}
function UpdateCNullTestRecordByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateCNullTestRecordByRowIdInput_cNullTestRecordPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateCLeftArmPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateCLeftArmPayload_cLeftArmPlan($object) {
  return $object.get("result");
}
function UpdateCLeftArmPayload_queryPlan() {
  return rootValue();
}
function UpdateCLeftArmByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateCLeftArmByRowIdInput_cLeftArmPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateCLeftArmByPersonIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateCLeftArmByPersonIdInput_cLeftArmPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateCIssue756Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateCIssue756Payload_cIssue756Plan($object) {
  return $object.get("result");
}
function UpdateCIssue756Payload_queryPlan() {
  return rootValue();
}
function UpdateCIssue756ByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateCIssue756ByRowIdInput_cIssue756Patch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdatePostPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdatePostPayload_postPlan($object) {
  return $object.get("result");
}
function UpdatePostPayload_queryPlan() {
  return rootValue();
}
function UpdatePostByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdatePostByRowIdInput_postPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateCPersonPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateCPersonPayload_cPersonPlan($object) {
  return $object.get("result");
}
function UpdateCPersonPayload_queryPlan() {
  return rootValue();
}
function UpdateCPersonByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateCPersonByRowIdInput_cPersonPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateCPersonByEmailInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateCPersonByEmailInput_cPersonPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateBTypePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateBTypePayload_bTypePlan($object) {
  return $object.get("result");
}
function UpdateBTypePayload_queryPlan() {
  return rootValue();
}
function UpdateBTypeByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateBTypeByRowIdInput_bTypePatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function DeleteInputPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteInputPayload_inputPlan($object) {
  return $object.get("result");
}
function DeleteInputPayload_queryPlan() {
  return rootValue();
}
function DeleteInputByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeletePatchPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeletePatchPayload_patchPlan($object) {
  return $object.get("result");
}
function DeletePatchPayload_queryPlan() {
  return rootValue();
}
function DeletePatchByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteReservedPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteReservedPayload_reservedPlan($object) {
  return $object.get("result");
}
function DeleteReservedPayload_queryPlan() {
  return rootValue();
}
function DeleteReservedByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteReservedPatchRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteReservedPatchRecordPayload_reservedPatchRecordPlan($object) {
  return $object.get("result");
}
function DeleteReservedPatchRecordPayload_queryPlan() {
  return rootValue();
}
function DeleteReservedPatchRecordByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteReservedInputRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteReservedInputRecordPayload_reservedInputRecordPlan($object) {
  return $object.get("result");
}
function DeleteReservedInputRecordPayload_queryPlan() {
  return rootValue();
}
function DeleteReservedInputRecordByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteDefaultValuePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteDefaultValuePayload_defaultValuePlan($object) {
  return $object.get("result");
}
function DeleteDefaultValuePayload_queryPlan() {
  return rootValue();
}
function DeleteDefaultValueByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteNoPrimaryKeyPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteNoPrimaryKeyPayload_noPrimaryKeyPlan($object) {
  return $object.get("result");
}
function DeleteNoPrimaryKeyPayload_queryPlan() {
  return rootValue();
}
function DeleteNoPrimaryKeyByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteUniqueForeignKeyPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteUniqueForeignKeyPayload_uniqueForeignKeyPlan($object) {
  return $object.get("result");
}
function DeleteUniqueForeignKeyPayload_queryPlan() {
  return rootValue();
}
function DeleteUniqueForeignKeyByCompoundKey1AndCompoundKey2Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteCMyTablePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteCMyTablePayload_cMyTablePlan($object) {
  return $object.get("result");
}
function DeleteCMyTablePayload_queryPlan() {
  return rootValue();
}
function DeleteCMyTableByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteCPersonSecretPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteCPersonSecretPayload_cPersonSecretPlan($object) {
  return $object.get("result");
}
function DeleteCPersonSecretPayload_queryPlan() {
  return rootValue();
}
function DeleteCPersonSecretByPersonIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteViewTablePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteViewTablePayload_viewTablePlan($object) {
  return $object.get("result");
}
function DeleteViewTablePayload_queryPlan() {
  return rootValue();
}
function DeleteViewTableByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteCCompoundKeyPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteCCompoundKeyPayload_cCompoundKeyPlan($object) {
  return $object.get("result");
}
function DeleteCCompoundKeyPayload_queryPlan() {
  return rootValue();
}
function DeleteCCompoundKeyByPersonId1AndPersonId2Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteSimilarTable1Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteSimilarTable1Payload_similarTable1Plan($object) {
  return $object.get("result");
}
function DeleteSimilarTable1Payload_queryPlan() {
  return rootValue();
}
function DeleteSimilarTable1ByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteSimilarTable2Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteSimilarTable2Payload_similarTable2Plan($object) {
  return $object.get("result");
}
function DeleteSimilarTable2Payload_queryPlan() {
  return rootValue();
}
function DeleteSimilarTable2ByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteCNullTestRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteCNullTestRecordPayload_cNullTestRecordPlan($object) {
  return $object.get("result");
}
function DeleteCNullTestRecordPayload_queryPlan() {
  return rootValue();
}
function DeleteCNullTestRecordByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteCLeftArmPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteCLeftArmPayload_cLeftArmPlan($object) {
  return $object.get("result");
}
function DeleteCLeftArmPayload_queryPlan() {
  return rootValue();
}
function DeleteCLeftArmByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteCLeftArmByPersonIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteCIssue756Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteCIssue756Payload_cIssue756Plan($object) {
  return $object.get("result");
}
function DeleteCIssue756Payload_queryPlan() {
  return rootValue();
}
function DeleteCIssue756ByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeletePostPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeletePostPayload_postPlan($object) {
  return $object.get("result");
}
function DeletePostPayload_queryPlan() {
  return rootValue();
}
function DeletePostByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteCPersonPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteCPersonPayload_cPersonPlan($object) {
  return $object.get("result");
}
function DeleteCPersonPayload_queryPlan() {
  return rootValue();
}
function DeleteCPersonByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteCPersonByEmailInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteBTypePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteBTypePayload_bTypePlan($object) {
  return $object.get("result");
}
function DeleteBTypePayload_queryPlan() {
  return rootValue();
}
function DeleteBTypeByRowIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
export const typeDefs = /* GraphQL */`"""The root query type which gives access points into the data universe."""
type Query {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """Get a single \`Input\`."""
  inputByRowId(rowId: Int!): Input

  """Get a single \`Patch\`."""
  patchByRowId(rowId: Int!): Patch

  """Get a single \`Reserved\`."""
  reservedByRowId(rowId: Int!): Reserved

  """Get a single \`ReservedPatchRecord\`."""
  reservedPatchRecordByRowId(rowId: Int!): ReservedPatchRecord

  """Get a single \`ReservedInputRecord\`."""
  reservedInputRecordByRowId(rowId: Int!): ReservedInputRecord

  """Get a single \`DefaultValue\`."""
  defaultValueByRowId(rowId: Int!): DefaultValue

  """Get a single \`NoPrimaryKey\`."""
  noPrimaryKeyByRowId(rowId: Int!): NoPrimaryKey

  """Get a single \`UniqueForeignKey\`."""
  uniqueForeignKeyByCompoundKey1AndCompoundKey2(compoundKey1: Int!, compoundKey2: Int!): UniqueForeignKey

  """Get a single \`CMyTable\`."""
  cMyTableByRowId(rowId: Int!): CMyTable

  """Get a single \`CPersonSecret\`."""
  cPersonSecretByPersonId(personId: Int!): CPersonSecret @deprecated(reason: "This is deprecated (comment on table c.person_secret).")

  """Get a single \`ViewTable\`."""
  viewTableByRowId(rowId: Int!): ViewTable

  """Get a single \`CCompoundKey\`."""
  cCompoundKeyByPersonId1AndPersonId2(personId1: Int!, personId2: Int!): CCompoundKey

  """Get a single \`SimilarTable1\`."""
  similarTable1ByRowId(rowId: Int!): SimilarTable1

  """Get a single \`SimilarTable2\`."""
  similarTable2ByRowId(rowId: Int!): SimilarTable2

  """Get a single \`CNullTestRecord\`."""
  cNullTestRecordByRowId(rowId: Int!): CNullTestRecord

  """Get a single \`CLeftArm\`."""
  cLeftArmByRowId(rowId: Int!): CLeftArm

  """Get a single \`CLeftArm\`."""
  cLeftArmByPersonId(personId: Int!): CLeftArm

  """Get a single \`CIssue756\`."""
  cIssue756ByRowId(rowId: Int!): CIssue756

  """Get a single \`Post\`."""
  postByRowId(rowId: Int!): Post

  """Get a single \`CPerson\`."""
  cPersonByRowId(rowId: Int!): CPerson

  """Get a single \`CPerson\`."""
  cPersonByEmail(email: BEmail!): CPerson

  """Get a single \`BType\`."""
  bTypeByRowId(rowId: Int!): BType
  cCurrentUserId: Int
  cFuncOut: Int

  """Reads and enables pagination through a set of \`Int4\`."""
  cFuncOutSetof(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): CFuncOutSetofConnection
  cFuncOutUnnamed: Int
  cNoArgsQuery: Int

  """Reads and enables pagination through a set of \`Interval\`."""
  queryIntervalSet(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): QueryIntervalSetConnection

  """Reads and enables pagination through a set of \`Int8\`."""
  staticBigInteger(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): StaticBigIntegerConnection
  cFuncInOut(i: Int): Int

  """Reads and enables pagination through a set of \`Int4\`."""
  cFuncReturnsTableOneCol(
    i: Int

    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): CFuncReturnsTableOneColConnection
  cJsonIdentity(json: JSON): JSON
  cJsonbIdentity(json: JSON): JSON

  """lol, add some stuff 1 query"""
  add1Query(arg0: Int!, arg1: Int!): Int

  """lol, add some stuff 2 query"""
  add2Query(a: Int!, b: Int): Int

  """lol, add some stuff 3 query"""
  add3Query(a: Int, arg1: Int): Int

  """lol, add some stuff 4 query"""
  add4Query(arg0: Int, b: Int): Int
  cFuncInInout(i: Int, ino: Int): Int
  cFuncOutOut: CFuncOutOutRecord

  """
  Reads and enables pagination through a set of \`CFuncOutOutSetofRecord\`.
  """
  cFuncOutOutSetof(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): CFuncOutOutSetofConnection
  cFuncOutOutUnnamed: CFuncOutOutUnnamedRecord

  """
  Reads and enables pagination through a set of \`CSearchTestSummariesRecord\`.
  """
  cSearchTestSummaries(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): CSearchTestSummariesConnection
  optionalMissingMiddle1(arg0: Int!, b: Int, c: Int): Int
  optionalMissingMiddle2(a: Int!, b: Int, c: Int): Int
  optionalMissingMiddle3(a: Int!, arg1: Int, c: Int): Int
  optionalMissingMiddle4(arg0: Int!, b: Int, arg2: Int): Int
  optionalMissingMiddle5(a: Int!, arg1: Int, arg2: Int): Int
  cFuncOutUnnamedOutOutUnnamed: CFuncOutUnnamedOutOutUnnamedRecord

  """
  Reads and enables pagination through a set of \`CFuncReturnsTableMultiColRecord\`.
  """
  cFuncReturnsTableMultiCol(
    i: Int

    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): CFuncReturnsTableMultiColConnection

  """Reads and enables pagination through a set of \`Int4\`."""
  cIntSetQuery(
    x: Int
    y: Int
    z: Int

    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): CIntSetQueryConnection
  queryIntervalArray: [Interval]
  queryTextArray: [String]
  cReturnTableWithoutGrants: CCompoundKey
  cTypesQuery(a: BigInt!, b: Boolean!, c: String!, d: [Int]!, e: JSON!, f: FloatRangeInput!): Boolean
  cCompoundTypeComputedField(compoundType: CCompoundTypeInput): Int
  cFuncOutOutCompoundType(i1: Int): CFuncOutOutCompoundTypeRecord
  cQueryOutputTwoRows(leftArmId: Int, postId: Int, txt: String): CQueryOutputTwoRowsRecord

  """Reads and enables pagination through a set of \`CCompoundType\`."""
  cCompoundTypeSetQuery(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): CCompoundTypeConnection
  bCompoundTypeQuery(object: CCompoundTypeInput): CCompoundType
  cTableQuery(id: Int): Post
  queryCompoundTypeArray(object: CCompoundTypeInput): [CCompoundType]
  bCompoundTypeArrayQuery(object: CCompoundTypeInput): [CCompoundType]
  cFuncOutComplex(a: Int, b: String): CFuncOutComplexRecord

  """
  Reads and enables pagination through a set of \`CFuncOutComplexSetofRecord\`.
  """
  cFuncOutComplexSetof(
    a: Int
    b: String

    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): CFuncOutComplexSetofConnection

  """Reads and enables pagination through a set of \`CPerson\`."""
  cBadlyBehavedFunction(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): CPersonConnection @deprecated(reason: "This is deprecated (comment on function c.badly_behaved_function).")
  cFuncOutTable: CPerson

  """Reads and enables pagination through a set of \`CPerson\`."""
  cFuncOutTableSetof(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): CPersonConnection

  """Reads and enables pagination through a set of \`CPerson\`."""
  cTableSetQuery(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): CPersonConnection

  """Reads and enables pagination through a set of \`CPerson\`."""
  cTableSetQueryPlpgsql(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): CPersonConnection

  """Reads and enables pagination through a set of \`BType\`."""
  bTypeFunctionConnection(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): BTypeConnection
  bTypeFunction(id: Int): BType
  bTypeFunctionList: [BType]

  """Reads and enables pagination through a set of \`NonUpdatableView\`."""
  allNonUpdatableViews(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`NonUpdatableView\`."""
    orderBy: [NonUpdatableViewOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NonUpdatableViewCondition
  ): NonUpdatableViewConnection

  """Reads and enables pagination through a set of \`Input\`."""
  allInputs(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Input\`."""
    orderBy: [InputOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InputCondition
  ): InputConnection

  """Reads and enables pagination through a set of \`Patch\`."""
  allPatches(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Patch\`."""
    orderBy: [PatchOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PatchCondition
  ): PatchConnection

  """Reads and enables pagination through a set of \`Reserved\`."""
  allReserveds(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Reserved\`."""
    orderBy: [ReservedOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ReservedCondition
  ): ReservedConnection

  """Reads and enables pagination through a set of \`ReservedPatchRecord\`."""
  allReservedPatchRecords(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`ReservedPatchRecord\`."""
    orderBy: [ReservedPatchRecordOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ReservedPatchRecordCondition
  ): ReservedPatchRecordConnection

  """Reads and enables pagination through a set of \`ReservedInputRecord\`."""
  allReservedInputRecords(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`ReservedInputRecord\`."""
    orderBy: [ReservedInputRecordOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ReservedInputRecordCondition
  ): ReservedInputRecordConnection

  """Reads and enables pagination through a set of \`DefaultValue\`."""
  allDefaultValues(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`DefaultValue\`."""
    orderBy: [DefaultValueOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DefaultValueCondition
  ): DefaultValueConnection

  """Reads and enables pagination through a set of \`ForeignKey\`."""
  allForeignKeys(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`ForeignKey\`."""
    orderBy: [ForeignKeyOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ForeignKeyCondition
  ): ForeignKeyConnection

  """Reads and enables pagination through a set of \`NoPrimaryKey\`."""
  allNoPrimaryKeys(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`NoPrimaryKey\`."""
    orderBy: [NoPrimaryKeyOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NoPrimaryKeyCondition
  ): NoPrimaryKeyConnection

  """Reads and enables pagination through a set of \`Testview\`."""
  allTestviews(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Testview\`."""
    orderBy: [TestviewOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TestviewCondition
  ): TestviewConnection

  """Reads and enables pagination through a set of \`UniqueForeignKey\`."""
  allUniqueForeignKeys(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`UniqueForeignKey\`."""
    orderBy: [UniqueForeignKeyOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UniqueForeignKeyCondition
  ): UniqueForeignKeyConnection

  """Reads and enables pagination through a set of \`CMyTable\`."""
  allCMyTables(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`CMyTable\`."""
    orderBy: [CMyTableOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CMyTableCondition
  ): CMyTableConnection

  """Reads and enables pagination through a set of \`CPersonSecret\`."""
  allCPersonSecrets(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`CPersonSecret\`."""
    orderBy: [CPersonSecretOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CPersonSecretCondition
  ): CPersonSecretConnection @deprecated(reason: "This is deprecated (comment on table c.person_secret).")

  """Reads and enables pagination through a set of \`ViewTable\`."""
  allViewTables(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`ViewTable\`."""
    orderBy: [ViewTableOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ViewTableCondition
  ): ViewTableConnection

  """Reads and enables pagination through a set of \`BUpdatableView\`."""
  allBUpdatableViews(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`BUpdatableView\`."""
    orderBy: [BUpdatableViewOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BUpdatableViewCondition
  ): BUpdatableViewConnection

  """Reads and enables pagination through a set of \`CCompoundKey\`."""
  allCCompoundKeys(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`CCompoundKey\`."""
    orderBy: [CCompoundKeyOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CCompoundKeyCondition
  ): CCompoundKeyConnection

  """Reads and enables pagination through a set of \`SimilarTable1\`."""
  allSimilarTable1S(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SimilarTable1\`."""
    orderBy: [SimilarTable1OrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SimilarTable1Condition
  ): SimilarTable1Connection

  """Reads and enables pagination through a set of \`SimilarTable2\`."""
  allSimilarTable2S(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SimilarTable2\`."""
    orderBy: [SimilarTable2OrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SimilarTable2Condition
  ): SimilarTable2Connection

  """Reads and enables pagination through a set of \`CNullTestRecord\`."""
  allCNullTestRecords(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`CNullTestRecord\`."""
    orderBy: [CNullTestRecordOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CNullTestRecordCondition
  ): CNullTestRecordConnection

  """Reads and enables pagination through a set of \`CEdgeCase\`."""
  allCEdgeCases(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`CEdgeCase\`."""
    orderBy: [CEdgeCaseOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CEdgeCaseCondition
  ): CEdgeCaseConnection

  """Reads and enables pagination through a set of \`CLeftArm\`."""
  allCLeftArms(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`CLeftArm\`."""
    orderBy: [CLeftArmOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CLeftArmCondition
  ): CLeftArmConnection

  """Reads and enables pagination through a set of \`CIssue756\`."""
  allCIssue756S(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`CIssue756\`."""
    orderBy: [CIssue756OrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CIssue756Condition
  ): CIssue756Connection

  """Reads and enables pagination through a set of \`Post\`."""
  allPosts(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition
  ): PostConnection

  """Reads and enables pagination through a set of \`CPerson\`."""
  allCPeople(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`CPerson\`."""
    orderBy: [CPersonOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CPersonCondition
  ): CPersonConnection

  """Reads and enables pagination through a set of \`BType\`."""
  allBTypes(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`BType\`."""
    orderBy: [BTypeOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BTypeCondition
  ): BTypeConnection
}

"""Should output as Input"""
type Input {
  rowId: Int!
}

"""Should output as Patch"""
type Patch {
  rowId: Int!
}

type Reserved {
  rowId: Int!
}

"""
\`reservedPatchs\` table should get renamed to ReservedPatchRecord to prevent clashes with ReservedPatch from \`reserved\` table
"""
type ReservedPatchRecord {
  rowId: Int!
}

"""
\`reserved_input\` table should get renamed to ReservedInputRecord to prevent clashes with ReservedInput from \`reserved\` table
"""
type ReservedInputRecord {
  rowId: Int!
}

type DefaultValue {
  rowId: Int!
  nullValue: String
}

type NoPrimaryKey {
  rowId: Int!
  str: String!
}

type UniqueForeignKey {
  compoundKey1: Int
  compoundKey2: Int

  """
  Reads a single \`CCompoundKey\` that is related to this \`UniqueForeignKey\`.
  """
  cCompoundKeyByCompoundKey1AndCompoundKey2: CCompoundKey
}

type CCompoundKey {
  personId2: Int!
  personId1: Int!
  extra: Boolean

  """Reads a single \`CPerson\` that is related to this \`CCompoundKey\`."""
  cPersonByPersonId1: CPerson

  """Reads a single \`CPerson\` that is related to this \`CCompoundKey\`."""
  cPersonByPersonId2: CPerson

  """Reads and enables pagination through a set of \`ForeignKey\`."""
  foreignKeysByCompoundKey1AndCompoundKey2(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`ForeignKey\`."""
    orderBy: [ForeignKeyOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ForeignKeyCondition
  ): ForeignKeyConnection!

  """
  Reads a single \`UniqueForeignKey\` that is related to this \`CCompoundKey\`.
  """
  uniqueForeignKeyByCompoundKey1AndCompoundKey2: UniqueForeignKey
}

"""Person test comment"""
type CPerson {
  computedOut: String!

  """The first name of the person."""
  firstName: String
  computedOutOut: CPersonComputedOutOutRecord
  computedInout(ino: String): String
  computedInoutOut(ino: String): CPersonComputedInoutOutRecord
  exists(email: BEmail): Boolean @deprecated(reason: "This is deprecated (comment on function c.person_exists).")
  computedFirstArgInoutOut: CPersonComputedFirstArgInoutOutRecord
  computedComplex(a: Int, b: String): CPersonComputedComplexRecord

  """The first post by the person."""
  firstPost: Post
  computedFirstArgInout: CPerson

  """Reads and enables pagination through a set of \`CPerson\`."""
  friends(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): CPersonConnection!

  """Reads and enables pagination through a set of \`BType\`."""
  typeFunctionConnection(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): BTypeConnection!
  typeFunction(id: Int): BType
  typeFunctionList: [BType]

  """The primary unique identifier for the person"""
  rowId: Int!

  """The person’s name"""
  name: String!
  aliases: [String]!
  about: String
  email: BEmail!
  site: BWrappedUrl @deprecated(reason: "Don’t use me")
  config: KeyValueHash
  lastLoginFromIp: InternetAddress
  lastLoginFromSubnet: CidrAddress
  userMac: MacAddress
  createdAt: Datetime

  """Reads and enables pagination through a set of \`Post\`."""
  postsByAuthorId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition
  ): PostConnection!

  """Reads and enables pagination through a set of \`ForeignKey\`."""
  foreignKeysByPersonId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`ForeignKey\`."""
    orderBy: [ForeignKeyOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ForeignKeyCondition
  ): ForeignKeyConnection!

  """This \`Person\`'s \`PersonSecret\`."""
  cPersonSecretByPersonId: CPersonSecret @deprecated(reason: "This is deprecated (comment on table c.person_secret).")

  """Reads a single \`CLeftArm\` that is related to this \`CPerson\`."""
  cLeftArmByPersonId: CLeftArm

  """Reads and enables pagination through a set of \`CCompoundKey\`."""
  cCompoundKeysByPersonId1(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`CCompoundKey\`."""
    orderBy: [CCompoundKeyOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CCompoundKeyCondition
  ): CCompoundKeyConnection!

  """Reads and enables pagination through a set of \`CCompoundKey\`."""
  cCompoundKeysByPersonId2(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`CCompoundKey\`."""
    orderBy: [CCompoundKeyOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CCompoundKeyCondition
  ): CCompoundKeyConnection!
}

type CPersonComputedOutOutRecord {
  o1: String
  o2: String
}

type CPersonComputedInoutOutRecord {
  ino: String
  o: String
}

scalar BEmail

type CPersonComputedFirstArgInoutOutRecord {
  person: CPerson
  o: Int
}

type CPersonComputedComplexRecord {
  x: Int
  y: CCompoundType
  z: CPerson
}

"""Awesome feature!"""
type CCompoundType {
  computedField: Int
  query: CCompoundType
  queryCompoundTypeArray: [CCompoundType]
  arrayQuery: [CCompoundType]
  a: Int
  b: String
  c: BColor
  d: UUID
  e: BEnumCaps
  f: BEnumWithEmptyString
  g: Interval
  fooBar: Int
}

enum BColor {
  red
  green
  blue
}

"""
A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
"""
scalar UUID

enum BEnumCaps {
  FOO_BAR
  BAR_FOO
  BAZ_QUX
  _0_BAR
}

enum BEnumWithEmptyString {
  _EMPTY_
  one
  two
}

"""
An interval of time that has passed where the smallest distinct unit is a second.
"""
type Interval {
  """
  A quantity of seconds. This is the only non-integer field, as all the other
  fields will dump their overflow into a smaller unit of time. Intervals don’t
  have a smaller unit than seconds.
  """
  seconds: Float

  """A quantity of minutes."""
  minutes: Int

  """A quantity of hours."""
  hours: Int

  """A quantity of days."""
  days: Int

  """A quantity of months."""
  months: Int

  """A quantity of years."""
  years: Int
}

type Post {
  """Reads and enables pagination through a set of \`Interval\`."""
  computedIntervalSet(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): PostComputedIntervalSetConnection!
  computedIntervalArray: [Interval]
  computedTextArray: [String]
  computedWithOptionalArg(i: Int): Int
  computedWithRequiredArg(i: Int!): Int
  headlineTrimmed(length: Int, omission: String): String
  headlineTrimmedNoDefaults(length: Int, omission: String): String
  headlineTrimmedStrict(length: Int, omission: String): String
  computedCompoundTypeArray(object: CCompoundTypeInput): [CCompoundType]
  rowId: Int!
  headline: String!
  body: String
  authorId: Int
  enums: [AnEnum]
  comptypes: [Comptype]

  """Reads a single \`CPerson\` that is related to this \`Post\`."""
  cPersonByAuthorId: CPerson

  """Reads and enables pagination through a set of \`BType\`."""
  bTypesBySmallint(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`BType\`."""
    orderBy: [BTypeOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BTypeCondition
  ): BTypeConnection!

  """Reads a single \`BType\` that is related to this \`Post\`."""
  bTypeByRowId: BType
}

"""A connection to a list of \`Interval\` values."""
type PostComputedIntervalSetConnection {
  """A list of \`Interval\` objects."""
  nodes: [Interval]!

  """
  A list of edges which contains the \`Interval\` and cursor to aid in pagination.
  """
  edges: [PostComputedIntervalSetEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Interval\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Interval\` edge in the connection."""
type PostComputedIntervalSetEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Interval\` at the end of the edge."""
  node: Interval
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""An input for mutations affecting \`CCompoundType\`"""
input CCompoundTypeInput {
  a: Int
  b: String
  c: BColor
  d: UUID
  e: BEnumCaps
  f: BEnumWithEmptyString
  g: IntervalInput
  fooBar: Int
}

"""
An interval of time that has passed where the smallest distinct unit is a second.
"""
input IntervalInput {
  """
  A quantity of seconds. This is the only non-integer field, as all the other
  fields will dump their overflow into a smaller unit of time. Intervals don’t
  have a smaller unit than seconds.
  """
  seconds: Float

  """A quantity of minutes."""
  minutes: Int

  """A quantity of hours."""
  hours: Int

  """A quantity of days."""
  days: Int

  """A quantity of months."""
  months: Int

  """A quantity of years."""
  years: Int
}

enum AnEnum {
  awaiting
  rejected
  published
  ASTERISK
  ASTERISK__ASTERISK
  ASTERISK__ASTERISK__ASTERISK
  foo_ASTERISK
  foo_ASTERISK_
  _foo_ASTERISK
  ASTERISK_bar
  ASTERISK_bar_
  _ASTERISK_bar_
  ASTERISK_baz_ASTERISK
  _ASTERISK_baz_ASTERISK_
  PERCENT
  GREATER_THAN_OR_EQUAL
  LIKE
  DOLLAR
}

type Comptype {
  schedule: Datetime
  isOptimised: Boolean
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) and, if it has a timezone, [RFC
3339](https://datatracker.ietf.org/doc/html/rfc3339) standards. Input values
that do not conform to both ISO 8601 and RFC 3339 may be coerced, which may lead
to unexpected results.
"""
scalar Datetime

"""A connection to a list of \`BType\` values."""
type BTypeConnection {
  """A list of \`BType\` objects."""
  nodes: [BType]!

  """
  A list of edges which contains the \`BType\` and cursor to aid in pagination.
  """
  edges: [BTypeEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`BType\` you could get from the connection."""
  totalCount: Int!
}

type BType {
  rowId: Int!
  smallint: Int!
  bigint: BigInt!
  numeric: BigFloat!
  decimal: BigFloat!
  boolean: Boolean!
  varchar: String!
  enum: BColor!
  enumArray: [BColor]!
  domain: AnInt!
  domain2: BAnotherInt!
  textArray: [String]!
  json: JSON!
  jsonb: JSON!
  nullableRange: BigFloatRange
  numrange: BigFloatRange!
  daterange: DateRange!
  anIntRange: AnIntRange!
  timestamp: Datetime!
  timestamptz: Datetime!
  date: Date!
  time: Time!
  timetz: Time!
  interval: Interval!
  intervalArray: [Interval]!
  money: Float!
  compoundType: CCompoundType!
  nestedCompoundType: BNestedCompoundType!
  nullableCompoundType: CCompoundType
  nullableNestedCompoundType: BNestedCompoundType
  point: Point!
  nullablePoint: Point
  inet: InternetAddress
  cidr: CidrAddress
  macaddr: MacAddress
  regproc: RegProc
  regprocedure: RegProcedure
  regoper: RegOper
  regoperator: RegOperator
  regclass: RegClass
  regtype: RegType
  regconfig: RegConfig
  regdictionary: RegDictionary
  textArrayDomain: [String]
  int8ArrayDomain: [BigInt]
  bytea: Base64EncodedBinary
  byteaArray: [Base64EncodedBinary]
  ltree: LTree
  ltreeArray: [LTree]

  """Reads a single \`Post\` that is related to this \`BType\`."""
  postBySmallint: Post

  """Reads a single \`Post\` that is related to this \`BType\`."""
  postByRowId: Post
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

scalar AnInt

scalar BAnotherInt

"""
Represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""A range of \`BigFloat\`."""
type BigFloatRange {
  """The starting bound of our range."""
  start: BigFloatRangeBound

  """The ending bound of our range."""
  end: BigFloatRangeBound
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
type BigFloatRangeBound {
  """The value at one end of our range."""
  value: BigFloat!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""A range of \`Date\`."""
type DateRange {
  """The starting bound of our range."""
  start: DateRangeBound

  """The ending bound of our range."""
  end: DateRangeBound
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
type DateRangeBound {
  """The value at one end of our range."""
  value: Date!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""A calendar date in YYYY-MM-DD format."""
scalar Date

"""A range of \`AnInt\`."""
type AnIntRange {
  """The starting bound of our range."""
  start: AnIntRangeBound

  """The ending bound of our range."""
  end: AnIntRangeBound
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
type AnIntRangeBound {
  """The value at one end of our range."""
  value: AnInt!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""
The exact time of day, does not include the date. May or may not have a timezone offset.
"""
scalar Time

type BNestedCompoundType {
  a: CCompoundType
  b: CCompoundType
  bazBuz: Int
}

"""A cartesian point."""
type Point {
  x: Float!
  y: Float!
}

"""An IPv4 or IPv6 host address, and optionally its subnet."""
scalar InternetAddress

"""An IPv4 or IPv6 CIDR address."""
scalar CidrAddress

"""A 6-byte MAC address."""
scalar MacAddress

"""A builtin object identifier type for a function name"""
scalar RegProc

"""A builtin object identifier type for a function with argument types"""
scalar RegProcedure

"""A builtin object identifier type for an operator"""
scalar RegOper

"""A builtin object identifier type for an operator with argument types"""
scalar RegOperator

"""A builtin object identifier type for a relation name"""
scalar RegClass

"""A builtin object identifier type for a data type name"""
scalar RegType

"""A builtin object identifier type for a text search configuration"""
scalar RegConfig

"""A builtin object identifier type for a text search dictionary"""
scalar RegDictionary

"""Binary data encoded using Base64"""
scalar Base64EncodedBinary

"""
Represents an \`ltree\` hierarchical label tree as outlined in https://www.postgresql.org/docs/current/ltree.html
"""
scalar LTree

"""A \`BType\` edge in the connection."""
type BTypeEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`BType\` at the end of the edge."""
  node: BType
}

"""Methods to use when ordering \`BType\`."""
enum BTypeOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  SMALLINT_ASC
  SMALLINT_DESC
  BIGINT_ASC
  BIGINT_DESC
  NUMERIC_ASC
  NUMERIC_DESC
  DECIMAL_ASC
  DECIMAL_DESC
  BOOLEAN_ASC
  BOOLEAN_DESC
  VARCHAR_ASC
  VARCHAR_DESC
  ENUM_ASC
  ENUM_DESC
  DOMAIN_ASC
  DOMAIN_DESC
  DOMAIN2_ASC
  DOMAIN2_DESC
  JSON_ASC
  JSON_DESC
  JSONB_ASC
  JSONB_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  TIMESTAMPTZ_ASC
  TIMESTAMPTZ_DESC
  DATE_ASC
  DATE_DESC
  TIME_ASC
  TIME_DESC
  TIMETZ_ASC
  TIMETZ_DESC
  INTERVAL_ASC
  INTERVAL_DESC
  MONEY_ASC
  MONEY_DESC
  POINT_ASC
  POINT_DESC
  NULLABLE_POINT_ASC
  NULLABLE_POINT_DESC
  INET_ASC
  INET_DESC
  CIDR_ASC
  CIDR_DESC
  MACADDR_ASC
  MACADDR_DESC
  REGPROC_ASC
  REGPROC_DESC
  REGPROCEDURE_ASC
  REGPROCEDURE_DESC
  REGOPER_ASC
  REGOPER_DESC
  REGOPERATOR_ASC
  REGOPERATOR_DESC
  REGCLASS_ASC
  REGCLASS_DESC
  REGTYPE_ASC
  REGTYPE_DESC
  REGCONFIG_ASC
  REGCONFIG_DESC
  REGDICTIONARY_ASC
  REGDICTIONARY_DESC
  LTREE_ASC
  LTREE_DESC
}

"""
A condition to be used against \`BType\` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input BTypeCondition {
  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int

  """Checks for equality with the object’s \`smallint\` field."""
  smallint: Int

  """Checks for equality with the object’s \`bigint\` field."""
  bigint: BigInt

  """Checks for equality with the object’s \`numeric\` field."""
  numeric: BigFloat

  """Checks for equality with the object’s \`decimal\` field."""
  decimal: BigFloat

  """Checks for equality with the object’s \`boolean\` field."""
  boolean: Boolean

  """Checks for equality with the object’s \`varchar\` field."""
  varchar: String

  """Checks for equality with the object’s \`enum\` field."""
  enum: BColor

  """Checks for equality with the object’s \`domain\` field."""
  domain: AnInt

  """Checks for equality with the object’s \`domain2\` field."""
  domain2: BAnotherInt

  """Checks for equality with the object’s \`json\` field."""
  json: JSON

  """Checks for equality with the object’s \`jsonb\` field."""
  jsonb: JSON

  """Checks for equality with the object’s \`timestamp\` field."""
  timestamp: Datetime

  """Checks for equality with the object’s \`timestamptz\` field."""
  timestamptz: Datetime

  """Checks for equality with the object’s \`date\` field."""
  date: Date

  """Checks for equality with the object’s \`time\` field."""
  time: Time

  """Checks for equality with the object’s \`timetz\` field."""
  timetz: Time

  """Checks for equality with the object’s \`interval\` field."""
  interval: IntervalInput

  """Checks for equality with the object’s \`money\` field."""
  money: Float

  """Checks for equality with the object’s \`point\` field."""
  point: PointInput

  """Checks for equality with the object’s \`nullablePoint\` field."""
  nullablePoint: PointInput

  """Checks for equality with the object’s \`inet\` field."""
  inet: InternetAddress

  """Checks for equality with the object’s \`cidr\` field."""
  cidr: CidrAddress

  """Checks for equality with the object’s \`macaddr\` field."""
  macaddr: MacAddress

  """Checks for equality with the object’s \`regproc\` field."""
  regproc: RegProc

  """Checks for equality with the object’s \`regprocedure\` field."""
  regprocedure: RegProcedure

  """Checks for equality with the object’s \`regoper\` field."""
  regoper: RegOper

  """Checks for equality with the object’s \`regoperator\` field."""
  regoperator: RegOperator

  """Checks for equality with the object’s \`regclass\` field."""
  regclass: RegClass

  """Checks for equality with the object’s \`regtype\` field."""
  regtype: RegType

  """Checks for equality with the object’s \`regconfig\` field."""
  regconfig: RegConfig

  """Checks for equality with the object’s \`regdictionary\` field."""
  regdictionary: RegDictionary

  """Checks for equality with the object’s \`ltree\` field."""
  ltree: LTree
}

"""A cartesian point."""
input PointInput {
  x: Float!
  y: Float!
}

"""A connection to a list of \`CPerson\` values."""
type CPersonConnection {
  """A list of \`CPerson\` objects."""
  nodes: [CPerson]!

  """
  A list of edges which contains the \`CPerson\` and cursor to aid in pagination.
  """
  edges: [CPersonEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`CPerson\` you could get from the connection."""
  totalCount: Int!
}

"""A \`CPerson\` edge in the connection."""
type CPersonEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`CPerson\` at the end of the edge."""
  node: CPerson
}

type BWrappedUrl {
  url: BNotNullUrl!
}

scalar BNotNullUrl

"""
A set of key/value pairs, keys are strings, values may be a string or null. Exposed as a JSON object.
"""
scalar KeyValueHash

"""A connection to a list of \`Post\` values."""
type PostConnection {
  """A list of \`Post\` objects."""
  nodes: [Post]!

  """
  A list of edges which contains the \`Post\` and cursor to aid in pagination.
  """
  edges: [PostEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Post\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Post\` edge in the connection."""
type PostEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Post\` at the end of the edge."""
  node: Post
}

"""Methods to use when ordering \`Post\`."""
enum PostOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  HEADLINE_ASC
  HEADLINE_DESC
  BODY_ASC
  BODY_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
}

"""
A condition to be used against \`Post\` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input PostCondition {
  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int

  """Checks for equality with the object’s \`headline\` field."""
  headline: String

  """Checks for equality with the object’s \`body\` field."""
  body: String

  """Checks for equality with the object’s \`authorId\` field."""
  authorId: Int
}

"""A connection to a list of \`ForeignKey\` values."""
type ForeignKeyConnection {
  """A list of \`ForeignKey\` objects."""
  nodes: [ForeignKey]!

  """
  A list of edges which contains the \`ForeignKey\` and cursor to aid in pagination.
  """
  edges: [ForeignKeyEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`ForeignKey\` you could get from the connection."""
  totalCount: Int!
}

type ForeignKey {
  personId: Int
  compoundKey1: Int
  compoundKey2: Int

  """Reads a single \`CCompoundKey\` that is related to this \`ForeignKey\`."""
  cCompoundKeyByCompoundKey1AndCompoundKey2: CCompoundKey

  """Reads a single \`CPerson\` that is related to this \`ForeignKey\`."""
  cPersonByPersonId: CPerson
}

"""A \`ForeignKey\` edge in the connection."""
type ForeignKeyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`ForeignKey\` at the end of the edge."""
  node: ForeignKey
}

"""Methods to use when ordering \`ForeignKey\`."""
enum ForeignKeyOrderBy {
  NATURAL
  PERSON_ID_ASC
  PERSON_ID_DESC
  COMPOUND_KEY_1_ASC
  COMPOUND_KEY_1_DESC
  COMPOUND_KEY_2_ASC
  COMPOUND_KEY_2_DESC
}

"""
A condition to be used against \`ForeignKey\` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ForeignKeyCondition {
  """Checks for equality with the object’s \`personId\` field."""
  personId: Int

  """Checks for equality with the object’s \`compoundKey1\` field."""
  compoundKey1: Int

  """Checks for equality with the object’s \`compoundKey2\` field."""
  compoundKey2: Int
}

"""Tracks the person's secret"""
type CPersonSecret {
  personId: Int!

  """A secret held by the associated Person"""
  secret: String

  """The \`Person\` this \`PersonSecret\` belongs to."""
  cPersonByPersonId: CPerson
}

"""Tracks metadata about the left arms of various people"""
type CLeftArm {
  rowId: Int!
  personId: Int!
  lengthInMetres: Float
  mood: String!

  """Reads a single \`CPerson\` that is related to this \`CLeftArm\`."""
  cPersonByPersonId: CPerson
}

"""A connection to a list of \`CCompoundKey\` values."""
type CCompoundKeyConnection {
  """A list of \`CCompoundKey\` objects."""
  nodes: [CCompoundKey]!

  """
  A list of edges which contains the \`CCompoundKey\` and cursor to aid in pagination.
  """
  edges: [CCompoundKeyEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`CCompoundKey\` you could get from the connection."""
  totalCount: Int!
}

"""A \`CCompoundKey\` edge in the connection."""
type CCompoundKeyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`CCompoundKey\` at the end of the edge."""
  node: CCompoundKey
}

"""Methods to use when ordering \`CCompoundKey\`."""
enum CCompoundKeyOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PERSON_ID_2_ASC
  PERSON_ID_2_DESC
  PERSON_ID_1_ASC
  PERSON_ID_1_DESC
  EXTRA_ASC
  EXTRA_DESC
}

"""
A condition to be used against \`CCompoundKey\` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CCompoundKeyCondition {
  """Checks for equality with the object’s \`personId2\` field."""
  personId2: Int

  """Checks for equality with the object’s \`personId1\` field."""
  personId1: Int

  """Checks for equality with the object’s \`extra\` field."""
  extra: Boolean
}

type CMyTable {
  rowId: Int!
  jsonData: JSON
}

type ViewTable {
  rowId: Int!
  col1: Int
  col2: Int
}

type SimilarTable1 {
  rowId: Int!
  col1: Int
  col2: Int
  col3: Int!
}

type SimilarTable2 {
  rowId: Int!
  col3: Int!
  col4: Int
  col5: Int
}

type CNullTestRecord {
  rowId: Int!
  nullableText: String
  nullableInt: Int
  nonNullText: String!
}

type CIssue756 {
  rowId: Int!
  ts: CNotNullTimestamp!
}

scalar CNotNullTimestamp

"""A connection to a list of \`Int\` values."""
type CFuncOutSetofConnection {
  """A list of \`Int\` objects."""
  nodes: [Int]!

  """
  A list of edges which contains the \`Int\` and cursor to aid in pagination.
  """
  edges: [CFuncOutSetofEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Int\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Int\` edge in the connection."""
type CFuncOutSetofEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Int\` at the end of the edge."""
  node: Int
}

"""A connection to a list of \`Interval\` values."""
type QueryIntervalSetConnection {
  """A list of \`Interval\` objects."""
  nodes: [Interval]!

  """
  A list of edges which contains the \`Interval\` and cursor to aid in pagination.
  """
  edges: [QueryIntervalSetEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Interval\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Interval\` edge in the connection."""
type QueryIntervalSetEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Interval\` at the end of the edge."""
  node: Interval
}

"""A connection to a list of \`BigInt\` values."""
type StaticBigIntegerConnection {
  """A list of \`BigInt\` objects."""
  nodes: [BigInt]!

  """
  A list of edges which contains the \`BigInt\` and cursor to aid in pagination.
  """
  edges: [StaticBigIntegerEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`BigInt\` you could get from the connection."""
  totalCount: Int!
}

"""A \`BigInt\` edge in the connection."""
type StaticBigIntegerEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`BigInt\` at the end of the edge."""
  node: BigInt
}

"""A connection to a list of \`Int\` values."""
type CFuncReturnsTableOneColConnection {
  """A list of \`Int\` objects."""
  nodes: [Int]!

  """
  A list of edges which contains the \`Int\` and cursor to aid in pagination.
  """
  edges: [CFuncReturnsTableOneColEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Int\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Int\` edge in the connection."""
type CFuncReturnsTableOneColEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Int\` at the end of the edge."""
  node: Int
}

type CFuncOutOutRecord {
  firstOut: Int
  secondOut: String
}

"""A connection to a list of \`CFuncOutOutSetofRecord\` values."""
type CFuncOutOutSetofConnection {
  """A list of \`CFuncOutOutSetofRecord\` objects."""
  nodes: [CFuncOutOutSetofRecord]!

  """
  A list of edges which contains the \`CFuncOutOutSetofRecord\` and cursor to aid in pagination.
  """
  edges: [CFuncOutOutSetofEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`CFuncOutOutSetofRecord\` you could get from the connection.
  """
  totalCount: Int!
}

type CFuncOutOutSetofRecord {
  o1: Int
  o2: String
}

"""A \`CFuncOutOutSetofRecord\` edge in the connection."""
type CFuncOutOutSetofEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`CFuncOutOutSetofRecord\` at the end of the edge."""
  node: CFuncOutOutSetofRecord
}

type CFuncOutOutUnnamedRecord {
  column1: Int
  column2: String
}

"""A connection to a list of \`CSearchTestSummariesRecord\` values."""
type CSearchTestSummariesConnection {
  """A list of \`CSearchTestSummariesRecord\` objects."""
  nodes: [CSearchTestSummariesRecord]!

  """
  A list of edges which contains the \`CSearchTestSummariesRecord\` and cursor to aid in pagination.
  """
  edges: [CSearchTestSummariesEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`CSearchTestSummariesRecord\` you could get from the connection.
  """
  totalCount: Int!
}

type CSearchTestSummariesRecord {
  id: Int
  totalDuration: Interval
}

"""A \`CSearchTestSummariesRecord\` edge in the connection."""
type CSearchTestSummariesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`CSearchTestSummariesRecord\` at the end of the edge."""
  node: CSearchTestSummariesRecord
}

type CFuncOutUnnamedOutOutUnnamedRecord {
  column1: Int
  o2: String
  column3: Int
}

"""A connection to a list of \`CFuncReturnsTableMultiColRecord\` values."""
type CFuncReturnsTableMultiColConnection {
  """A list of \`CFuncReturnsTableMultiColRecord\` objects."""
  nodes: [CFuncReturnsTableMultiColRecord]!

  """
  A list of edges which contains the \`CFuncReturnsTableMultiColRecord\` and cursor to aid in pagination.
  """
  edges: [CFuncReturnsTableMultiColEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`CFuncReturnsTableMultiColRecord\` you could get from the connection.
  """
  totalCount: Int!
}

type CFuncReturnsTableMultiColRecord {
  col1: Int
  col2: String
}

"""A \`CFuncReturnsTableMultiColRecord\` edge in the connection."""
type CFuncReturnsTableMultiColEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`CFuncReturnsTableMultiColRecord\` at the end of the edge."""
  node: CFuncReturnsTableMultiColRecord
}

"""A connection to a list of \`Int\` values."""
type CIntSetQueryConnection {
  """A list of \`Int\` objects."""
  nodes: [Int]!

  """
  A list of edges which contains the \`Int\` and cursor to aid in pagination.
  """
  edges: [CIntSetQueryEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Int\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Int\` edge in the connection."""
type CIntSetQueryEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Int\` at the end of the edge."""
  node: Int
}

"""A range of \`Float\`."""
input FloatRangeInput {
  """The starting bound of our range."""
  start: FloatRangeBoundInput

  """The ending bound of our range."""
  end: FloatRangeBoundInput
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
input FloatRangeBoundInput {
  """The value at one end of our range."""
  value: Float!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

type CFuncOutOutCompoundTypeRecord {
  o1: Int
  o2: CCompoundType
}

type CQueryOutputTwoRowsRecord {
  txt: String
  leftArm: CLeftArm
  post: Post
}

"""A connection to a list of \`CCompoundType\` values."""
type CCompoundTypeConnection {
  """A list of \`CCompoundType\` objects."""
  nodes: [CCompoundType]!

  """
  A list of edges which contains the \`CCompoundType\` and cursor to aid in pagination.
  """
  edges: [CCompoundTypeEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`CCompoundType\` you could get from the connection."""
  totalCount: Int!
}

"""A \`CCompoundType\` edge in the connection."""
type CCompoundTypeEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`CCompoundType\` at the end of the edge."""
  node: CCompoundType
}

type CFuncOutComplexRecord {
  x: Int
  y: CCompoundType
  z: CPerson
}

"""A connection to a list of \`CFuncOutComplexSetofRecord\` values."""
type CFuncOutComplexSetofConnection {
  """A list of \`CFuncOutComplexSetofRecord\` objects."""
  nodes: [CFuncOutComplexSetofRecord]!

  """
  A list of edges which contains the \`CFuncOutComplexSetofRecord\` and cursor to aid in pagination.
  """
  edges: [CFuncOutComplexSetofEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`CFuncOutComplexSetofRecord\` you could get from the connection.
  """
  totalCount: Int!
}

type CFuncOutComplexSetofRecord {
  x: Int
  y: CCompoundType
  z: CPerson
}

"""A \`CFuncOutComplexSetofRecord\` edge in the connection."""
type CFuncOutComplexSetofEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`CFuncOutComplexSetofRecord\` at the end of the edge."""
  node: CFuncOutComplexSetofRecord
}

"""A connection to a list of \`NonUpdatableView\` values."""
type NonUpdatableViewConnection {
  """A list of \`NonUpdatableView\` objects."""
  nodes: [NonUpdatableView]!

  """
  A list of edges which contains the \`NonUpdatableView\` and cursor to aid in pagination.
  """
  edges: [NonUpdatableViewEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`NonUpdatableView\` you could get from the connection.
  """
  totalCount: Int!
}

type NonUpdatableView {
  column: Int
}

"""A \`NonUpdatableView\` edge in the connection."""
type NonUpdatableViewEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`NonUpdatableView\` at the end of the edge."""
  node: NonUpdatableView
}

"""Methods to use when ordering \`NonUpdatableView\`."""
enum NonUpdatableViewOrderBy {
  NATURAL
  COLUMN_ASC
  COLUMN_DESC
}

"""
A condition to be used against \`NonUpdatableView\` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input NonUpdatableViewCondition {
  """Checks for equality with the object’s \`column\` field."""
  column: Int
}

"""A connection to a list of \`Input\` values."""
type InputConnection {
  """A list of \`Input\` objects."""
  nodes: [Input]!

  """
  A list of edges which contains the \`Input\` and cursor to aid in pagination.
  """
  edges: [InputEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Input\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Input\` edge in the connection."""
type InputEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Input\` at the end of the edge."""
  node: Input
}

"""Methods to use when ordering \`Input\`."""
enum InputOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
}

"""
A condition to be used against \`Input\` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input InputCondition {
  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int
}

"""A connection to a list of \`Patch\` values."""
type PatchConnection {
  """A list of \`Patch\` objects."""
  nodes: [Patch]!

  """
  A list of edges which contains the \`Patch\` and cursor to aid in pagination.
  """
  edges: [PatchEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Patch\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Patch\` edge in the connection."""
type PatchEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Patch\` at the end of the edge."""
  node: Patch
}

"""Methods to use when ordering \`Patch\`."""
enum PatchOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
}

"""
A condition to be used against \`Patch\` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input PatchCondition {
  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int
}

"""A connection to a list of \`Reserved\` values."""
type ReservedConnection {
  """A list of \`Reserved\` objects."""
  nodes: [Reserved]!

  """
  A list of edges which contains the \`Reserved\` and cursor to aid in pagination.
  """
  edges: [ReservedEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Reserved\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Reserved\` edge in the connection."""
type ReservedEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Reserved\` at the end of the edge."""
  node: Reserved
}

"""Methods to use when ordering \`Reserved\`."""
enum ReservedOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
}

"""
A condition to be used against \`Reserved\` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ReservedCondition {
  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int
}

"""A connection to a list of \`ReservedPatchRecord\` values."""
type ReservedPatchRecordConnection {
  """A list of \`ReservedPatchRecord\` objects."""
  nodes: [ReservedPatchRecord]!

  """
  A list of edges which contains the \`ReservedPatchRecord\` and cursor to aid in pagination.
  """
  edges: [ReservedPatchRecordEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`ReservedPatchRecord\` you could get from the connection.
  """
  totalCount: Int!
}

"""A \`ReservedPatchRecord\` edge in the connection."""
type ReservedPatchRecordEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`ReservedPatchRecord\` at the end of the edge."""
  node: ReservedPatchRecord
}

"""Methods to use when ordering \`ReservedPatchRecord\`."""
enum ReservedPatchRecordOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
}

"""
A condition to be used against \`ReservedPatchRecord\` object types. All fields
are tested for equality and combined with a logical ‘and.’
"""
input ReservedPatchRecordCondition {
  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int
}

"""A connection to a list of \`ReservedInputRecord\` values."""
type ReservedInputRecordConnection {
  """A list of \`ReservedInputRecord\` objects."""
  nodes: [ReservedInputRecord]!

  """
  A list of edges which contains the \`ReservedInputRecord\` and cursor to aid in pagination.
  """
  edges: [ReservedInputRecordEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`ReservedInputRecord\` you could get from the connection.
  """
  totalCount: Int!
}

"""A \`ReservedInputRecord\` edge in the connection."""
type ReservedInputRecordEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`ReservedInputRecord\` at the end of the edge."""
  node: ReservedInputRecord
}

"""Methods to use when ordering \`ReservedInputRecord\`."""
enum ReservedInputRecordOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
}

"""
A condition to be used against \`ReservedInputRecord\` object types. All fields
are tested for equality and combined with a logical ‘and.’
"""
input ReservedInputRecordCondition {
  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int
}

"""A connection to a list of \`DefaultValue\` values."""
type DefaultValueConnection {
  """A list of \`DefaultValue\` objects."""
  nodes: [DefaultValue]!

  """
  A list of edges which contains the \`DefaultValue\` and cursor to aid in pagination.
  """
  edges: [DefaultValueEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`DefaultValue\` you could get from the connection."""
  totalCount: Int!
}

"""A \`DefaultValue\` edge in the connection."""
type DefaultValueEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`DefaultValue\` at the end of the edge."""
  node: DefaultValue
}

"""Methods to use when ordering \`DefaultValue\`."""
enum DefaultValueOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  NULL_VALUE_ASC
  NULL_VALUE_DESC
}

"""
A condition to be used against \`DefaultValue\` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input DefaultValueCondition {
  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int

  """Checks for equality with the object’s \`nullValue\` field."""
  nullValue: String
}

"""A connection to a list of \`NoPrimaryKey\` values."""
type NoPrimaryKeyConnection {
  """A list of \`NoPrimaryKey\` objects."""
  nodes: [NoPrimaryKey]!

  """
  A list of edges which contains the \`NoPrimaryKey\` and cursor to aid in pagination.
  """
  edges: [NoPrimaryKeyEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`NoPrimaryKey\` you could get from the connection."""
  totalCount: Int!
}

"""A \`NoPrimaryKey\` edge in the connection."""
type NoPrimaryKeyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`NoPrimaryKey\` at the end of the edge."""
  node: NoPrimaryKey
}

"""Methods to use when ordering \`NoPrimaryKey\`."""
enum NoPrimaryKeyOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  STR_ASC
  STR_DESC
}

"""
A condition to be used against \`NoPrimaryKey\` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input NoPrimaryKeyCondition {
  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int

  """Checks for equality with the object’s \`str\` field."""
  str: String
}

"""A connection to a list of \`Testview\` values."""
type TestviewConnection {
  """A list of \`Testview\` objects."""
  nodes: [Testview]!

  """
  A list of edges which contains the \`Testview\` and cursor to aid in pagination.
  """
  edges: [TestviewEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Testview\` you could get from the connection."""
  totalCount: Int!
}

type Testview {
  testviewid: Int
  col1: Int
  col2: Int
}

"""A \`Testview\` edge in the connection."""
type TestviewEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Testview\` at the end of the edge."""
  node: Testview
}

"""Methods to use when ordering \`Testview\`."""
enum TestviewOrderBy {
  NATURAL
  TESTVIEWID_ASC
  TESTVIEWID_DESC
  COL1_ASC
  COL1_DESC
  COL2_ASC
  COL2_DESC
}

"""
A condition to be used against \`Testview\` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input TestviewCondition {
  """Checks for equality with the object’s \`testviewid\` field."""
  testviewid: Int

  """Checks for equality with the object’s \`col1\` field."""
  col1: Int

  """Checks for equality with the object’s \`col2\` field."""
  col2: Int
}

"""A connection to a list of \`UniqueForeignKey\` values."""
type UniqueForeignKeyConnection {
  """A list of \`UniqueForeignKey\` objects."""
  nodes: [UniqueForeignKey]!

  """
  A list of edges which contains the \`UniqueForeignKey\` and cursor to aid in pagination.
  """
  edges: [UniqueForeignKeyEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`UniqueForeignKey\` you could get from the connection.
  """
  totalCount: Int!
}

"""A \`UniqueForeignKey\` edge in the connection."""
type UniqueForeignKeyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`UniqueForeignKey\` at the end of the edge."""
  node: UniqueForeignKey
}

"""Methods to use when ordering \`UniqueForeignKey\`."""
enum UniqueForeignKeyOrderBy {
  NATURAL
  COMPOUND_KEY_1_ASC
  COMPOUND_KEY_1_DESC
  COMPOUND_KEY_2_ASC
  COMPOUND_KEY_2_DESC
}

"""
A condition to be used against \`UniqueForeignKey\` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input UniqueForeignKeyCondition {
  """Checks for equality with the object’s \`compoundKey1\` field."""
  compoundKey1: Int

  """Checks for equality with the object’s \`compoundKey2\` field."""
  compoundKey2: Int
}

"""A connection to a list of \`CMyTable\` values."""
type CMyTableConnection {
  """A list of \`CMyTable\` objects."""
  nodes: [CMyTable]!

  """
  A list of edges which contains the \`CMyTable\` and cursor to aid in pagination.
  """
  edges: [CMyTableEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`CMyTable\` you could get from the connection."""
  totalCount: Int!
}

"""A \`CMyTable\` edge in the connection."""
type CMyTableEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`CMyTable\` at the end of the edge."""
  node: CMyTable
}

"""Methods to use when ordering \`CMyTable\`."""
enum CMyTableOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  JSON_DATA_ASC
  JSON_DATA_DESC
}

"""
A condition to be used against \`CMyTable\` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CMyTableCondition {
  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int

  """Checks for equality with the object’s \`jsonData\` field."""
  jsonData: JSON
}

"""A connection to a list of \`CPersonSecret\` values."""
type CPersonSecretConnection {
  """A list of \`CPersonSecret\` objects."""
  nodes: [CPersonSecret]!

  """
  A list of edges which contains the \`CPersonSecret\` and cursor to aid in pagination.
  """
  edges: [CPersonSecretEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`CPersonSecret\` you could get from the connection."""
  totalCount: Int!
}

"""A \`CPersonSecret\` edge in the connection."""
type CPersonSecretEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`CPersonSecret\` at the end of the edge."""
  node: CPersonSecret
}

"""Methods to use when ordering \`CPersonSecret\`."""
enum CPersonSecretOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PERSON_ID_ASC
  PERSON_ID_DESC
  SECRET_ASC
  SECRET_DESC
}

"""
A condition to be used against \`CPersonSecret\` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CPersonSecretCondition {
  """Checks for equality with the object’s \`personId\` field."""
  personId: Int

  """Checks for equality with the object’s \`secret\` field."""
  secret: String
}

"""A connection to a list of \`ViewTable\` values."""
type ViewTableConnection {
  """A list of \`ViewTable\` objects."""
  nodes: [ViewTable]!

  """
  A list of edges which contains the \`ViewTable\` and cursor to aid in pagination.
  """
  edges: [ViewTableEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`ViewTable\` you could get from the connection."""
  totalCount: Int!
}

"""A \`ViewTable\` edge in the connection."""
type ViewTableEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`ViewTable\` at the end of the edge."""
  node: ViewTable
}

"""Methods to use when ordering \`ViewTable\`."""
enum ViewTableOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  COL1_ASC
  COL1_DESC
  COL2_ASC
  COL2_DESC
}

"""
A condition to be used against \`ViewTable\` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ViewTableCondition {
  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int

  """Checks for equality with the object’s \`col1\` field."""
  col1: Int

  """Checks for equality with the object’s \`col2\` field."""
  col2: Int
}

"""A connection to a list of \`BUpdatableView\` values."""
type BUpdatableViewConnection {
  """A list of \`BUpdatableView\` objects."""
  nodes: [BUpdatableView]!

  """
  A list of edges which contains the \`BUpdatableView\` and cursor to aid in pagination.
  """
  edges: [BUpdatableViewEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`BUpdatableView\` you could get from the connection."""
  totalCount: Int!
}

"""YOYOYO!!"""
type BUpdatableView {
  x: Int
  name: String
  description: String

  """This is constantly 2"""
  constant: Int
}

"""A \`BUpdatableView\` edge in the connection."""
type BUpdatableViewEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`BUpdatableView\` at the end of the edge."""
  node: BUpdatableView
}

"""Methods to use when ordering \`BUpdatableView\`."""
enum BUpdatableViewOrderBy {
  NATURAL
  X_ASC
  X_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CONSTANT_ASC
  CONSTANT_DESC
}

"""
A condition to be used against \`BUpdatableView\` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input BUpdatableViewCondition {
  """Checks for equality with the object’s \`x\` field."""
  x: Int

  """Checks for equality with the object’s \`name\` field."""
  name: String

  """Checks for equality with the object’s \`description\` field."""
  description: String

  """Checks for equality with the object’s \`constant\` field."""
  constant: Int
}

"""A connection to a list of \`SimilarTable1\` values."""
type SimilarTable1Connection {
  """A list of \`SimilarTable1\` objects."""
  nodes: [SimilarTable1]!

  """
  A list of edges which contains the \`SimilarTable1\` and cursor to aid in pagination.
  """
  edges: [SimilarTable1Edge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`SimilarTable1\` you could get from the connection."""
  totalCount: Int!
}

"""A \`SimilarTable1\` edge in the connection."""
type SimilarTable1Edge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`SimilarTable1\` at the end of the edge."""
  node: SimilarTable1
}

"""Methods to use when ordering \`SimilarTable1\`."""
enum SimilarTable1OrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  COL1_ASC
  COL1_DESC
  COL2_ASC
  COL2_DESC
  COL3_ASC
  COL3_DESC
}

"""
A condition to be used against \`SimilarTable1\` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input SimilarTable1Condition {
  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int

  """Checks for equality with the object’s \`col1\` field."""
  col1: Int

  """Checks for equality with the object’s \`col2\` field."""
  col2: Int

  """Checks for equality with the object’s \`col3\` field."""
  col3: Int
}

"""A connection to a list of \`SimilarTable2\` values."""
type SimilarTable2Connection {
  """A list of \`SimilarTable2\` objects."""
  nodes: [SimilarTable2]!

  """
  A list of edges which contains the \`SimilarTable2\` and cursor to aid in pagination.
  """
  edges: [SimilarTable2Edge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`SimilarTable2\` you could get from the connection."""
  totalCount: Int!
}

"""A \`SimilarTable2\` edge in the connection."""
type SimilarTable2Edge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`SimilarTable2\` at the end of the edge."""
  node: SimilarTable2
}

"""Methods to use when ordering \`SimilarTable2\`."""
enum SimilarTable2OrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  COL3_ASC
  COL3_DESC
  COL4_ASC
  COL4_DESC
  COL5_ASC
  COL5_DESC
}

"""
A condition to be used against \`SimilarTable2\` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input SimilarTable2Condition {
  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int

  """Checks for equality with the object’s \`col3\` field."""
  col3: Int

  """Checks for equality with the object’s \`col4\` field."""
  col4: Int

  """Checks for equality with the object’s \`col5\` field."""
  col5: Int
}

"""A connection to a list of \`CNullTestRecord\` values."""
type CNullTestRecordConnection {
  """A list of \`CNullTestRecord\` objects."""
  nodes: [CNullTestRecord]!

  """
  A list of edges which contains the \`CNullTestRecord\` and cursor to aid in pagination.
  """
  edges: [CNullTestRecordEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`CNullTestRecord\` you could get from the connection.
  """
  totalCount: Int!
}

"""A \`CNullTestRecord\` edge in the connection."""
type CNullTestRecordEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`CNullTestRecord\` at the end of the edge."""
  node: CNullTestRecord
}

"""Methods to use when ordering \`CNullTestRecord\`."""
enum CNullTestRecordOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  NULLABLE_TEXT_ASC
  NULLABLE_TEXT_DESC
  NULLABLE_INT_ASC
  NULLABLE_INT_DESC
  NON_NULL_TEXT_ASC
  NON_NULL_TEXT_DESC
}

"""
A condition to be used against \`CNullTestRecord\` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CNullTestRecordCondition {
  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int

  """Checks for equality with the object’s \`nullableText\` field."""
  nullableText: String

  """Checks for equality with the object’s \`nullableInt\` field."""
  nullableInt: Int

  """Checks for equality with the object’s \`nonNullText\` field."""
  nonNullText: String
}

"""A connection to a list of \`CEdgeCase\` values."""
type CEdgeCaseConnection {
  """A list of \`CEdgeCase\` objects."""
  nodes: [CEdgeCase]!

  """
  A list of edges which contains the \`CEdgeCase\` and cursor to aid in pagination.
  """
  edges: [CEdgeCaseEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`CEdgeCase\` you could get from the connection."""
  totalCount: Int!
}

type CEdgeCase {
  computed: String
  notNullHasDefault: Boolean!
  wontCastEasy: Int
  rowId: Int
}

"""A \`CEdgeCase\` edge in the connection."""
type CEdgeCaseEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`CEdgeCase\` at the end of the edge."""
  node: CEdgeCase
}

"""Methods to use when ordering \`CEdgeCase\`."""
enum CEdgeCaseOrderBy {
  NATURAL
  NOT_NULL_HAS_DEFAULT_ASC
  NOT_NULL_HAS_DEFAULT_DESC
  WONT_CAST_EASY_ASC
  WONT_CAST_EASY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
}

"""
A condition to be used against \`CEdgeCase\` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CEdgeCaseCondition {
  """Checks for equality with the object’s \`notNullHasDefault\` field."""
  notNullHasDefault: Boolean

  """Checks for equality with the object’s \`wontCastEasy\` field."""
  wontCastEasy: Int

  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int
}

"""A connection to a list of \`CLeftArm\` values."""
type CLeftArmConnection {
  """A list of \`CLeftArm\` objects."""
  nodes: [CLeftArm]!

  """
  A list of edges which contains the \`CLeftArm\` and cursor to aid in pagination.
  """
  edges: [CLeftArmEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`CLeftArm\` you could get from the connection."""
  totalCount: Int!
}

"""A \`CLeftArm\` edge in the connection."""
type CLeftArmEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`CLeftArm\` at the end of the edge."""
  node: CLeftArm
}

"""Methods to use when ordering \`CLeftArm\`."""
enum CLeftArmOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  PERSON_ID_ASC
  PERSON_ID_DESC
  LENGTH_IN_METRES_ASC
  LENGTH_IN_METRES_DESC
  MOOD_ASC
  MOOD_DESC
}

"""
A condition to be used against \`CLeftArm\` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CLeftArmCondition {
  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int

  """Checks for equality with the object’s \`personId\` field."""
  personId: Int

  """Checks for equality with the object’s \`lengthInMetres\` field."""
  lengthInMetres: Float

  """Checks for equality with the object’s \`mood\` field."""
  mood: String
}

"""A connection to a list of \`CIssue756\` values."""
type CIssue756Connection {
  """A list of \`CIssue756\` objects."""
  nodes: [CIssue756]!

  """
  A list of edges which contains the \`CIssue756\` and cursor to aid in pagination.
  """
  edges: [CIssue756Edge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`CIssue756\` you could get from the connection."""
  totalCount: Int!
}

"""A \`CIssue756\` edge in the connection."""
type CIssue756Edge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`CIssue756\` at the end of the edge."""
  node: CIssue756
}

"""Methods to use when ordering \`CIssue756\`."""
enum CIssue756OrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  TS_ASC
  TS_DESC
}

"""
A condition to be used against \`CIssue756\` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CIssue756Condition {
  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int

  """Checks for equality with the object’s \`ts\` field."""
  ts: CNotNullTimestamp
}

"""Methods to use when ordering \`CPerson\`."""
enum CPersonOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  ABOUT_ASC
  ABOUT_DESC
  EMAIL_ASC
  EMAIL_DESC
  CONFIG_ASC
  CONFIG_DESC
  LAST_LOGIN_FROM_IP_ASC
  LAST_LOGIN_FROM_IP_DESC
  LAST_LOGIN_FROM_SUBNET_ASC
  LAST_LOGIN_FROM_SUBNET_DESC
  USER_MAC_ASC
  USER_MAC_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

"""
A condition to be used against \`CPerson\` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CPersonCondition {
  """Checks for equality with the object’s \`rowId\` field."""
  rowId: Int

  """Checks for equality with the object’s \`name\` field."""
  name: String

  """Checks for equality with the object’s \`about\` field."""
  about: String

  """Checks for equality with the object’s \`email\` field."""
  email: BEmail

  """Checks for equality with the object’s \`config\` field."""
  config: KeyValueHash

  """Checks for equality with the object’s \`lastLoginFromIp\` field."""
  lastLoginFromIp: InternetAddress

  """Checks for equality with the object’s \`lastLoginFromSubnet\` field."""
  lastLoginFromSubnet: CidrAddress

  """Checks for equality with the object’s \`userMac\` field."""
  userMac: MacAddress

  """Checks for equality with the object’s \`createdAt\` field."""
  createdAt: Datetime
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  cMutationOut(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CMutationOutInput!
  ): CMutationOutPayload
  cMutationOutSetof(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CMutationOutSetofInput!
  ): CMutationOutSetofPayload
  cMutationOutUnnamed(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CMutationOutUnnamedInput!
  ): CMutationOutUnnamedPayload
  cNoArgsMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CNoArgsMutationInput!
  ): CNoArgsMutationPayload
  returnVoidMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ReturnVoidMutationInput!
  ): ReturnVoidMutationPayload
  mutationIntervalSet(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: MutationIntervalSetInput!
  ): MutationIntervalSetPayload
  cMutationInOut(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CMutationInOutInput!
  ): CMutationInOutPayload
  cMutationReturnsTableOneCol(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CMutationReturnsTableOneColInput!
  ): CMutationReturnsTableOneColPayload
  cJsonIdentityMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CJsonIdentityMutationInput!
  ): CJsonIdentityMutationPayload
  cJsonbIdentityMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CJsonbIdentityMutationInput!
  ): CJsonbIdentityMutationPayload
  cJsonbIdentityMutationPlpgsql(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CJsonbIdentityMutationPlpgsqlInput!
  ): CJsonbIdentityMutationPlpgsqlPayload
  cJsonbIdentityMutationPlpgsqlWithDefault(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CJsonbIdentityMutationPlpgsqlWithDefaultInput!
  ): CJsonbIdentityMutationPlpgsqlWithDefaultPayload

  """lol, add some stuff 1 mutation"""
  add1Mutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: Add1MutationInput!
  ): Add1MutationPayload

  """lol, add some stuff 2 mutation"""
  add2Mutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: Add2MutationInput!
  ): Add2MutationPayload

  """lol, add some stuff 3 mutation"""
  add3Mutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: Add3MutationInput!
  ): Add3MutationPayload

  """lol, add some stuff 4 mutation"""
  add4Mutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: Add4MutationInput!
  ): Add4MutationPayload
  add4MutationError(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: Add4MutationErrorInput!
  ): Add4MutationErrorPayload
  bMult1(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BMult1Input!
  ): BMult1Payload
  bMult2(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BMult2Input!
  ): BMult2Payload
  bMult3(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BMult3Input!
  ): BMult3Payload
  bMult4(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BMult4Input!
  ): BMult4Payload
  cMutationInInout(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CMutationInInoutInput!
  ): CMutationInInoutPayload
  cMutationOutOut(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CMutationOutOutInput!
  ): CMutationOutOutPayload
  cMutationOutOutSetof(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CMutationOutOutSetofInput!
  ): CMutationOutOutSetofPayload
  cMutationOutOutUnnamed(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CMutationOutOutUnnamedInput!
  ): CMutationOutOutUnnamedPayload
  cIntSetMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CIntSetMutationInput!
  ): CIntSetMutationPayload
  cMutationOutUnnamedOutOutUnnamed(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CMutationOutUnnamedOutOutUnnamedInput!
  ): CMutationOutUnnamedOutOutUnnamedPayload
  cMutationReturnsTableMultiCol(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CMutationReturnsTableMultiColInput!
  ): CMutationReturnsTableMultiColPayload
  bGuidFn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BGuidFnInput!
  ): BGuidFnPayload
  mutationIntervalArray(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: MutationIntervalArrayInput!
  ): MutationIntervalArrayPayload
  mutationTextArray(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: MutationTextArrayInput!
  ): MutationTextArrayPayload
  bListBdeMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BListBdeMutationInput!
  ): BListBdeMutationPayload
  bAuthenticateFail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BAuthenticateFailInput!
  ): BAuthenticateFailPayload
  bAuthenticate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BAuthenticateInput!
  ): BAuthenticatePayload
  cLeftArmIdentity(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CLeftArmIdentityInput!
  ): CLeftArmIdentityPayload
  cIssue756Mutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CIssue756MutationInput!
  ): CIssue756MutationPayload
  cIssue756SetMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CIssue756SetMutationInput!
  ): CIssue756SetMutationPayload
  bAuthenticateMany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BAuthenticateManyInput!
  ): BAuthenticateManyPayload
  bAuthenticatePayload(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BAuthenticatePayloadInput!
  ): BAuthenticatePayloadPayload
  cTypesMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CTypesMutationInput!
  ): CTypesMutationPayload
  cMutationOutOutCompoundType(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CMutationOutOutCompoundTypeInput!
  ): CMutationOutOutCompoundTypePayload
  bCompoundTypeMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BCompoundTypeMutationInput!
  ): BCompoundTypeMutationPayload
  bCompoundTypeSetMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BCompoundTypeSetMutationInput!
  ): BCompoundTypeSetMutationPayload
  cTableMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CTableMutationInput!
  ): CTableMutationPayload
  postWithSuffix(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: PostWithSuffixInput!
  ): PostWithSuffixPayload @deprecated(reason: "This is deprecated (comment on function a.post_with_suffix).")
  mutationCompoundTypeArray(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: MutationCompoundTypeArrayInput!
  ): MutationCompoundTypeArrayPayload
  bCompoundTypeArrayMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BCompoundTypeArrayMutationInput!
  ): BCompoundTypeArrayMutationPayload
  postMany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: PostManyInput!
  ): PostManyPayload
  cMutationOutComplex(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CMutationOutComplexInput!
  ): CMutationOutComplexPayload
  cMutationOutComplexSetof(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CMutationOutComplexSetofInput!
  ): CMutationOutComplexSetofPayload
  cMutationOutTable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CMutationOutTableInput!
  ): CMutationOutTablePayload
  cMutationOutTableSetof(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CMutationOutTableSetofInput!
  ): CMutationOutTableSetofPayload
  cTableSetMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CTableSetMutationInput!
  ): CTableSetMutationPayload
  bTypeFunctionConnectionMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BTypeFunctionConnectionMutationInput!
  ): BTypeFunctionConnectionMutationPayload
  bTypeFunctionMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BTypeFunctionMutationInput!
  ): BTypeFunctionMutationPayload
  bTypeFunctionListMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BTypeFunctionListMutationInput!
  ): BTypeFunctionListMutationPayload

  """Creates a single \`Input\`."""
  createInput(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateInputInput!
  ): CreateInputPayload

  """Creates a single \`Patch\`."""
  createPatch(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePatchInput!
  ): CreatePatchPayload

  """Creates a single \`Reserved\`."""
  createReserved(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateReservedInput!
  ): CreateReservedPayload

  """Creates a single \`ReservedPatchRecord\`."""
  createReservedPatchRecord(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateReservedPatchRecordInput!
  ): CreateReservedPatchRecordPayload

  """Creates a single \`ReservedInputRecord\`."""
  createReservedInputRecord(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateReservedInputRecordInput!
  ): CreateReservedInputRecordPayload

  """Creates a single \`DefaultValue\`."""
  createDefaultValue(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateDefaultValueInput!
  ): CreateDefaultValuePayload

  """Creates a single \`ForeignKey\`."""
  createForeignKey(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateForeignKeyInput!
  ): CreateForeignKeyPayload

  """Creates a single \`NoPrimaryKey\`."""
  createNoPrimaryKey(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateNoPrimaryKeyInput!
  ): CreateNoPrimaryKeyPayload

  """Creates a single \`Testview\`."""
  createTestview(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTestviewInput!
  ): CreateTestviewPayload

  """Creates a single \`UniqueForeignKey\`."""
  createUniqueForeignKey(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUniqueForeignKeyInput!
  ): CreateUniqueForeignKeyPayload

  """Creates a single \`CMyTable\`."""
  createCMyTable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCMyTableInput!
  ): CreateCMyTablePayload

  """Creates a single \`CPersonSecret\`."""
  createCPersonSecret(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCPersonSecretInput!
  ): CreateCPersonSecretPayload @deprecated(reason: "This is deprecated (comment on table c.person_secret).")

  """Creates a single \`ViewTable\`."""
  createViewTable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateViewTableInput!
  ): CreateViewTablePayload

  """Creates a single \`BUpdatableView\`."""
  createBUpdatableView(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateBUpdatableViewInput!
  ): CreateBUpdatableViewPayload

  """Creates a single \`CCompoundKey\`."""
  createCCompoundKey(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCCompoundKeyInput!
  ): CreateCCompoundKeyPayload

  """Creates a single \`SimilarTable1\`."""
  createSimilarTable1(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSimilarTable1Input!
  ): CreateSimilarTable1Payload

  """Creates a single \`SimilarTable2\`."""
  createSimilarTable2(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSimilarTable2Input!
  ): CreateSimilarTable2Payload

  """Creates a single \`CNullTestRecord\`."""
  createCNullTestRecord(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCNullTestRecordInput!
  ): CreateCNullTestRecordPayload

  """Creates a single \`CEdgeCase\`."""
  createCEdgeCase(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCEdgeCaseInput!
  ): CreateCEdgeCasePayload

  """Creates a single \`CLeftArm\`."""
  createCLeftArm(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCLeftArmInput!
  ): CreateCLeftArmPayload

  """Creates a single \`CIssue756\`."""
  createCIssue756(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCIssue756Input!
  ): CreateCIssue756Payload

  """Creates a single \`Post\`."""
  createPost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePostInput!
  ): CreatePostPayload

  """Creates a single \`CPerson\`."""
  createCPerson(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCPersonInput!
  ): CreateCPersonPayload

  """Creates a single \`BType\`."""
  createBType(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateBTypeInput!
  ): CreateBTypePayload

  """Updates a single \`Input\` using a unique key and a patch."""
  updateInputByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateInputByRowIdInput!
  ): UpdateInputPayload

  """Updates a single \`Patch\` using a unique key and a patch."""
  updatePatchByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePatchByRowIdInput!
  ): UpdatePatchPayload

  """Updates a single \`Reserved\` using a unique key and a patch."""
  updateReservedByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateReservedByRowIdInput!
  ): UpdateReservedPayload

  """Updates a single \`ReservedPatchRecord\` using a unique key and a patch."""
  updateReservedPatchRecordByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateReservedPatchRecordByRowIdInput!
  ): UpdateReservedPatchRecordPayload

  """Updates a single \`ReservedInputRecord\` using a unique key and a patch."""
  updateReservedInputRecordByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateReservedInputRecordByRowIdInput!
  ): UpdateReservedInputRecordPayload

  """Updates a single \`DefaultValue\` using a unique key and a patch."""
  updateDefaultValueByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDefaultValueByRowIdInput!
  ): UpdateDefaultValuePayload

  """Updates a single \`NoPrimaryKey\` using a unique key and a patch."""
  updateNoPrimaryKeyByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateNoPrimaryKeyByRowIdInput!
  ): UpdateNoPrimaryKeyPayload

  """Updates a single \`UniqueForeignKey\` using a unique key and a patch."""
  updateUniqueForeignKeyByCompoundKey1AndCompoundKey2(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUniqueForeignKeyByCompoundKey1AndCompoundKey2Input!
  ): UpdateUniqueForeignKeyPayload

  """Updates a single \`CMyTable\` using a unique key and a patch."""
  updateCMyTableByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCMyTableByRowIdInput!
  ): UpdateCMyTablePayload

  """Updates a single \`CPersonSecret\` using a unique key and a patch."""
  updateCPersonSecretByPersonId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCPersonSecretByPersonIdInput!
  ): UpdateCPersonSecretPayload @deprecated(reason: "This is deprecated (comment on table c.person_secret).")

  """Updates a single \`ViewTable\` using a unique key and a patch."""
  updateViewTableByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateViewTableByRowIdInput!
  ): UpdateViewTablePayload

  """Updates a single \`CCompoundKey\` using a unique key and a patch."""
  updateCCompoundKeyByPersonId1AndPersonId2(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCCompoundKeyByPersonId1AndPersonId2Input!
  ): UpdateCCompoundKeyPayload

  """Updates a single \`SimilarTable1\` using a unique key and a patch."""
  updateSimilarTable1ByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSimilarTable1ByRowIdInput!
  ): UpdateSimilarTable1Payload

  """Updates a single \`SimilarTable2\` using a unique key and a patch."""
  updateSimilarTable2ByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSimilarTable2ByRowIdInput!
  ): UpdateSimilarTable2Payload

  """Updates a single \`CNullTestRecord\` using a unique key and a patch."""
  updateCNullTestRecordByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCNullTestRecordByRowIdInput!
  ): UpdateCNullTestRecordPayload

  """Updates a single \`CLeftArm\` using a unique key and a patch."""
  updateCLeftArmByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCLeftArmByRowIdInput!
  ): UpdateCLeftArmPayload

  """Updates a single \`CLeftArm\` using a unique key and a patch."""
  updateCLeftArmByPersonId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCLeftArmByPersonIdInput!
  ): UpdateCLeftArmPayload

  """Updates a single \`CIssue756\` using a unique key and a patch."""
  updateCIssue756ByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCIssue756ByRowIdInput!
  ): UpdateCIssue756Payload

  """Updates a single \`Post\` using a unique key and a patch."""
  updatePostByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePostByRowIdInput!
  ): UpdatePostPayload

  """Updates a single \`CPerson\` using a unique key and a patch."""
  updateCPersonByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCPersonByRowIdInput!
  ): UpdateCPersonPayload

  """Updates a single \`CPerson\` using a unique key and a patch."""
  updateCPersonByEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCPersonByEmailInput!
  ): UpdateCPersonPayload

  """Updates a single \`BType\` using a unique key and a patch."""
  updateBTypeByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateBTypeByRowIdInput!
  ): UpdateBTypePayload

  """Deletes a single \`Input\` using a unique key."""
  deleteInputByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteInputByRowIdInput!
  ): DeleteInputPayload

  """Deletes a single \`Patch\` using a unique key."""
  deletePatchByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePatchByRowIdInput!
  ): DeletePatchPayload

  """Deletes a single \`Reserved\` using a unique key."""
  deleteReservedByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteReservedByRowIdInput!
  ): DeleteReservedPayload

  """Deletes a single \`ReservedPatchRecord\` using a unique key."""
  deleteReservedPatchRecordByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteReservedPatchRecordByRowIdInput!
  ): DeleteReservedPatchRecordPayload

  """Deletes a single \`ReservedInputRecord\` using a unique key."""
  deleteReservedInputRecordByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteReservedInputRecordByRowIdInput!
  ): DeleteReservedInputRecordPayload

  """Deletes a single \`DefaultValue\` using a unique key."""
  deleteDefaultValueByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDefaultValueByRowIdInput!
  ): DeleteDefaultValuePayload

  """Deletes a single \`NoPrimaryKey\` using a unique key."""
  deleteNoPrimaryKeyByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteNoPrimaryKeyByRowIdInput!
  ): DeleteNoPrimaryKeyPayload

  """Deletes a single \`UniqueForeignKey\` using a unique key."""
  deleteUniqueForeignKeyByCompoundKey1AndCompoundKey2(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUniqueForeignKeyByCompoundKey1AndCompoundKey2Input!
  ): DeleteUniqueForeignKeyPayload

  """Deletes a single \`CMyTable\` using a unique key."""
  deleteCMyTableByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCMyTableByRowIdInput!
  ): DeleteCMyTablePayload

  """Deletes a single \`CPersonSecret\` using a unique key."""
  deleteCPersonSecretByPersonId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCPersonSecretByPersonIdInput!
  ): DeleteCPersonSecretPayload @deprecated(reason: "This is deprecated (comment on table c.person_secret).")

  """Deletes a single \`ViewTable\` using a unique key."""
  deleteViewTableByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteViewTableByRowIdInput!
  ): DeleteViewTablePayload

  """Deletes a single \`CCompoundKey\` using a unique key."""
  deleteCCompoundKeyByPersonId1AndPersonId2(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCCompoundKeyByPersonId1AndPersonId2Input!
  ): DeleteCCompoundKeyPayload

  """Deletes a single \`SimilarTable1\` using a unique key."""
  deleteSimilarTable1ByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSimilarTable1ByRowIdInput!
  ): DeleteSimilarTable1Payload

  """Deletes a single \`SimilarTable2\` using a unique key."""
  deleteSimilarTable2ByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSimilarTable2ByRowIdInput!
  ): DeleteSimilarTable2Payload

  """Deletes a single \`CNullTestRecord\` using a unique key."""
  deleteCNullTestRecordByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCNullTestRecordByRowIdInput!
  ): DeleteCNullTestRecordPayload

  """Deletes a single \`CLeftArm\` using a unique key."""
  deleteCLeftArmByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCLeftArmByRowIdInput!
  ): DeleteCLeftArmPayload

  """Deletes a single \`CLeftArm\` using a unique key."""
  deleteCLeftArmByPersonId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCLeftArmByPersonIdInput!
  ): DeleteCLeftArmPayload

  """Deletes a single \`CIssue756\` using a unique key."""
  deleteCIssue756ByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCIssue756ByRowIdInput!
  ): DeleteCIssue756Payload

  """Deletes a single \`Post\` using a unique key."""
  deletePostByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePostByRowIdInput!
  ): DeletePostPayload

  """Deletes a single \`CPerson\` using a unique key."""
  deleteCPersonByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCPersonByRowIdInput!
  ): DeleteCPersonPayload

  """Deletes a single \`CPerson\` using a unique key."""
  deleteCPersonByEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCPersonByEmailInput!
  ): DeleteCPersonPayload

  """Deletes a single \`BType\` using a unique key."""
  deleteBTypeByRowId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteBTypeByRowIdInput!
  ): DeleteBTypePayload
}

"""The output of our \`cMutationOut\` mutation."""
type CMutationOutPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`cMutationOut\` mutation."""
input CMutationOutInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`cMutationOutSetof\` mutation."""
type CMutationOutSetofPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [Int]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`cMutationOutSetof\` mutation."""
input CMutationOutSetofInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`cMutationOutUnnamed\` mutation."""
type CMutationOutUnnamedPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`cMutationOutUnnamed\` mutation."""
input CMutationOutUnnamedInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`cNoArgsMutation\` mutation."""
type CNoArgsMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`cNoArgsMutation\` mutation."""
input CNoArgsMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`returnVoidMutation\` mutation."""
type ReturnVoidMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`returnVoidMutation\` mutation."""
input ReturnVoidMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`mutationIntervalSet\` mutation."""
type MutationIntervalSetPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [Interval]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mutationIntervalSet\` mutation."""
input MutationIntervalSetInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`cMutationInOut\` mutation."""
type CMutationInOutPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`cMutationInOut\` mutation."""
input CMutationInOutInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  i: Int
}

"""The output of our \`cMutationReturnsTableOneCol\` mutation."""
type CMutationReturnsTableOneColPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [Int]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`cMutationReturnsTableOneCol\` mutation."""
input CMutationReturnsTableOneColInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  i: Int
}

"""The output of our \`cJsonIdentityMutation\` mutation."""
type CJsonIdentityMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: JSON

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`cJsonIdentityMutation\` mutation."""
input CJsonIdentityMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  json: JSON
}

"""The output of our \`cJsonbIdentityMutation\` mutation."""
type CJsonbIdentityMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: JSON

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`cJsonbIdentityMutation\` mutation."""
input CJsonbIdentityMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  json: JSON
}

"""The output of our \`cJsonbIdentityMutationPlpgsql\` mutation."""
type CJsonbIdentityMutationPlpgsqlPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: JSON

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`cJsonbIdentityMutationPlpgsql\` mutation."""
input CJsonbIdentityMutationPlpgsqlInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  _theJson: JSON!
}

"""The output of our \`cJsonbIdentityMutationPlpgsqlWithDefault\` mutation."""
type CJsonbIdentityMutationPlpgsqlWithDefaultPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: JSON

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`cJsonbIdentityMutationPlpgsqlWithDefault\` mutation."""
input CJsonbIdentityMutationPlpgsqlWithDefaultInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  _theJson: JSON
}

"""The output of our \`add1Mutation\` mutation."""
type Add1MutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`add1Mutation\` mutation."""
input Add1MutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  arg0: Int!
  arg1: Int!
}

"""The output of our \`add2Mutation\` mutation."""
type Add2MutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`add2Mutation\` mutation."""
input Add2MutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  a: Int!
  b: Int
}

"""The output of our \`add3Mutation\` mutation."""
type Add3MutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`add3Mutation\` mutation."""
input Add3MutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  a: Int
  arg1: Int
}

"""The output of our \`add4Mutation\` mutation."""
type Add4MutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`add4Mutation\` mutation."""
input Add4MutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  arg0: Int
  b: Int
}

"""The output of our \`add4MutationError\` mutation."""
type Add4MutationErrorPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`add4MutationError\` mutation."""
input Add4MutationErrorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  arg0: Int
  b: Int
}

"""The output of our \`bMult1\` mutation."""
type BMult1Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`bMult1\` mutation."""
input BMult1Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  arg0: Int
  arg1: Int
}

"""The output of our \`bMult2\` mutation."""
type BMult2Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`bMult2\` mutation."""
input BMult2Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  arg0: Int
  arg1: Int
}

"""The output of our \`bMult3\` mutation."""
type BMult3Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`bMult3\` mutation."""
input BMult3Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  arg0: Int!
  arg1: Int!
}

"""The output of our \`bMult4\` mutation."""
type BMult4Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`bMult4\` mutation."""
input BMult4Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  arg0: Int!
  arg1: Int!
}

"""The output of our \`cMutationInInout\` mutation."""
type CMutationInInoutPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`cMutationInInout\` mutation."""
input CMutationInInoutInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  i: Int
  ino: Int
}

"""The output of our \`cMutationOutOut\` mutation."""
type CMutationOutOutPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: CMutationOutOutRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type CMutationOutOutRecord {
  firstOut: Int
  secondOut: String
}

"""All input for the \`cMutationOutOut\` mutation."""
input CMutationOutOutInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`cMutationOutOutSetof\` mutation."""
type CMutationOutOutSetofPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [CMutationOutOutSetofRecord]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type CMutationOutOutSetofRecord {
  o1: Int
  o2: String
}

"""All input for the \`cMutationOutOutSetof\` mutation."""
input CMutationOutOutSetofInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`cMutationOutOutUnnamed\` mutation."""
type CMutationOutOutUnnamedPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: CMutationOutOutUnnamedRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type CMutationOutOutUnnamedRecord {
  column1: Int
  column2: String
}

"""All input for the \`cMutationOutOutUnnamed\` mutation."""
input CMutationOutOutUnnamedInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`cIntSetMutation\` mutation."""
type CIntSetMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [Int]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`cIntSetMutation\` mutation."""
input CIntSetMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  x: Int
  y: Int
  z: Int
}

"""The output of our \`cMutationOutUnnamedOutOutUnnamed\` mutation."""
type CMutationOutUnnamedOutOutUnnamedPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: CMutationOutUnnamedOutOutUnnamedRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type CMutationOutUnnamedOutOutUnnamedRecord {
  column1: Int
  o2: String
  column3: Int
}

"""All input for the \`cMutationOutUnnamedOutOutUnnamed\` mutation."""
input CMutationOutUnnamedOutOutUnnamedInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`cMutationReturnsTableMultiCol\` mutation."""
type CMutationReturnsTableMultiColPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [CMutationReturnsTableMultiColRecord]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type CMutationReturnsTableMultiColRecord {
  col1: Int
  col2: String
}

"""All input for the \`cMutationReturnsTableMultiCol\` mutation."""
input CMutationReturnsTableMultiColInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  i: Int
}

"""The output of our \`bGuidFn\` mutation."""
type BGuidFnPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: BGuid

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

scalar BGuid

"""All input for the \`bGuidFn\` mutation."""
input BGuidFnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  g: BGuid
}

"""The output of our \`mutationIntervalArray\` mutation."""
type MutationIntervalArrayPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [Interval]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mutationIntervalArray\` mutation."""
input MutationIntervalArrayInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`mutationTextArray\` mutation."""
type MutationTextArrayPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [String]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mutationTextArray\` mutation."""
input MutationTextArrayInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`bListBdeMutation\` mutation."""
type BListBdeMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [UUID]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`bListBdeMutation\` mutation."""
input BListBdeMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  b: [String]
  d: String
  e: String
}

"""The output of our \`bAuthenticateFail\` mutation."""
type BAuthenticateFailPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: BJwtToken

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type BJwtToken {
  role: String
  exp: BigInt
  a: Int
  b: BigFloat
  c: BigInt
}

"""All input for the \`bAuthenticateFail\` mutation."""
input BAuthenticateFailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`bAuthenticate\` mutation."""
type BAuthenticatePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: BJwtToken

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`bAuthenticate\` mutation."""
input BAuthenticateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  a: Int
  b: BigFloat
  c: BigInt
}

"""The output of our \`cLeftArmIdentity\` mutation."""
type CLeftArmIdentityPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: CLeftArm

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CLeftArm\`. May be used by Relay 1."""
  cLeftArmEdge(
    """The method to use when ordering \`CLeftArm\`."""
    orderBy: [CLeftArmOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CLeftArmEdge
}

"""All input for the \`cLeftArmIdentity\` mutation."""
input CLeftArmIdentityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  leftArm: CLeftArmBaseInput
}

"""An input representation of \`CLeftArm\` with nullable fields."""
input CLeftArmBaseInput {
  rowId: Int
  personId: Int
  lengthInMetres: Float
  mood: String
}

"""The output of our \`cIssue756Mutation\` mutation."""
type CIssue756MutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: CIssue756

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CIssue756\`. May be used by Relay 1."""
  cIssue756Edge(
    """The method to use when ordering \`CIssue756\`."""
    orderBy: [CIssue756OrderBy!]! = [PRIMARY_KEY_ASC]
  ): CIssue756Edge
}

"""All input for the \`cIssue756Mutation\` mutation."""
input CIssue756MutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`cIssue756SetMutation\` mutation."""
type CIssue756SetMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [CIssue756]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`cIssue756SetMutation\` mutation."""
input CIssue756SetMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`bAuthenticateMany\` mutation."""
type BAuthenticateManyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [BJwtToken]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`bAuthenticateMany\` mutation."""
input BAuthenticateManyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  a: Int
  b: BigFloat
  c: BigInt
}

"""The output of our \`bAuthenticatePayload\` mutation."""
type BAuthenticatePayloadPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: BAuthPayload

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type BAuthPayload {
  jwt: BJwtToken
  rowId: Int
  admin: Boolean

  """Reads a single \`CPerson\` that is related to this \`BAuthPayload\`."""
  cPersonByRowId: CPerson
}

"""All input for the \`bAuthenticatePayload\` mutation."""
input BAuthenticatePayloadInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  a: Int
  b: BigFloat
  c: BigInt
}

"""The output of our \`cTypesMutation\` mutation."""
type CTypesMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: Boolean

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`cTypesMutation\` mutation."""
input CTypesMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  a: BigInt!
  b: Boolean!
  c: String!
  d: [Int]!
  e: JSON!
  f: FloatRangeInput!
}

"""The output of our \`cMutationOutOutCompoundType\` mutation."""
type CMutationOutOutCompoundTypePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: CMutationOutOutCompoundTypeRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type CMutationOutOutCompoundTypeRecord {
  o1: Int
  o2: CCompoundType
}

"""All input for the \`cMutationOutOutCompoundType\` mutation."""
input CMutationOutOutCompoundTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  i1: Int
}

"""The output of our \`bCompoundTypeMutation\` mutation."""
type BCompoundTypeMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: CCompoundType

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`bCompoundTypeMutation\` mutation."""
input BCompoundTypeMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  object: CCompoundTypeInput
}

"""The output of our \`bCompoundTypeSetMutation\` mutation."""
type BCompoundTypeSetMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [CCompoundType]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`bCompoundTypeSetMutation\` mutation."""
input BCompoundTypeSetMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  object: CCompoundTypeInput
}

"""The output of our \`cTableMutation\` mutation."""
type CTableMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the \`cTableMutation\` mutation."""
input CTableMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int
}

"""The output of our \`postWithSuffix\` mutation."""
type PostWithSuffixPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the \`postWithSuffix\` mutation."""
input PostWithSuffixInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  post: PostInput
  suffix: String
}

"""An input for mutations affecting \`Post\`"""
input PostInput {
  rowId: Int
  headline: String!
  body: String
  authorId: Int
  enums: [AnEnum]
  comptypes: [ComptypeInput]
}

"""An input for mutations affecting \`Comptype\`"""
input ComptypeInput {
  schedule: Datetime
  isOptimised: Boolean
}

"""The output of our \`mutationCompoundTypeArray\` mutation."""
type MutationCompoundTypeArrayPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [CCompoundType]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mutationCompoundTypeArray\` mutation."""
input MutationCompoundTypeArrayInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  object: CCompoundTypeInput
}

"""The output of our \`bCompoundTypeArrayMutation\` mutation."""
type BCompoundTypeArrayMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [CCompoundType]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`bCompoundTypeArrayMutation\` mutation."""
input BCompoundTypeArrayMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  object: CCompoundTypeInput
}

"""The output of our \`postMany\` mutation."""
type PostManyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [Post]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`postMany\` mutation."""
input PostManyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  posts: [PostInput]
}

"""The output of our \`cMutationOutComplex\` mutation."""
type CMutationOutComplexPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: CMutationOutComplexRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type CMutationOutComplexRecord {
  x: Int
  y: CCompoundType
  z: CPerson
}

"""All input for the \`cMutationOutComplex\` mutation."""
input CMutationOutComplexInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  a: Int
  b: String
}

"""The output of our \`cMutationOutComplexSetof\` mutation."""
type CMutationOutComplexSetofPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [CMutationOutComplexSetofRecord]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type CMutationOutComplexSetofRecord {
  x: Int
  y: CCompoundType
  z: CPerson
}

"""All input for the \`cMutationOutComplexSetof\` mutation."""
input CMutationOutComplexSetofInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  a: Int
  b: String
}

"""The output of our \`cMutationOutTable\` mutation."""
type CMutationOutTablePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: CPerson

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CPerson\`. May be used by Relay 1."""
  cPersonEdge(
    """The method to use when ordering \`CPerson\`."""
    orderBy: [CPersonOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CPersonEdge
}

"""All input for the \`cMutationOutTable\` mutation."""
input CMutationOutTableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`cMutationOutTableSetof\` mutation."""
type CMutationOutTableSetofPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [CPerson]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`cMutationOutTableSetof\` mutation."""
input CMutationOutTableSetofInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`cTableSetMutation\` mutation."""
type CTableSetMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [CPerson]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`cTableSetMutation\` mutation."""
input CTableSetMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`bTypeFunctionConnectionMutation\` mutation."""
type BTypeFunctionConnectionMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [BType]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`bTypeFunctionConnectionMutation\` mutation."""
input BTypeFunctionConnectionMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`bTypeFunctionMutation\` mutation."""
type BTypeFunctionMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: BType

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`BType\`. May be used by Relay 1."""
  bTypeEdge(
    """The method to use when ordering \`BType\`."""
    orderBy: [BTypeOrderBy!]! = [PRIMARY_KEY_ASC]
  ): BTypeEdge
}

"""All input for the \`bTypeFunctionMutation\` mutation."""
input BTypeFunctionMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int
}

"""The output of our \`bTypeFunctionListMutation\` mutation."""
type BTypeFunctionListMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: [BType]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`bTypeFunctionListMutation\` mutation."""
input BTypeFunctionListMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our create \`Input\` mutation."""
type CreateInputPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Input\` that was created by this mutation."""
  input: Input

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Input\`. May be used by Relay 1."""
  inputEdge(
    """The method to use when ordering \`Input\`."""
    orderBy: [InputOrderBy!]! = [PRIMARY_KEY_ASC]
  ): InputEdge
}

"""All input for the create \`Input\` mutation."""
input CreateInputInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Input\` to be created by this mutation."""
  input: InputInput!
}

"""An input for mutations affecting \`Input\`"""
input InputInput {
  rowId: Int
}

"""The output of our create \`Patch\` mutation."""
type CreatePatchPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Patch\` that was created by this mutation."""
  patch: Patch

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Patch\`. May be used by Relay 1."""
  patchEdge(
    """The method to use when ordering \`Patch\`."""
    orderBy: [PatchOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PatchEdge
}

"""All input for the create \`Patch\` mutation."""
input CreatePatchInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Patch\` to be created by this mutation."""
  patch: PatchInput!
}

"""An input for mutations affecting \`Patch\`"""
input PatchInput {
  rowId: Int
}

"""The output of our create \`Reserved\` mutation."""
type CreateReservedPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Reserved\` that was created by this mutation."""
  reserved: Reserved

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Reserved\`. May be used by Relay 1."""
  reservedEdge(
    """The method to use when ordering \`Reserved\`."""
    orderBy: [ReservedOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedEdge
}

"""All input for the create \`Reserved\` mutation."""
input CreateReservedInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Reserved\` to be created by this mutation."""
  reserved: ReservedInput!
}

"""An input for mutations affecting \`Reserved\`"""
input ReservedInput {
  rowId: Int
}

"""The output of our create \`ReservedPatchRecord\` mutation."""
type CreateReservedPatchRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ReservedPatchRecord\` that was created by this mutation."""
  reservedPatchRecord: ReservedPatchRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ReservedPatchRecord\`. May be used by Relay 1."""
  reservedPatchRecordEdge(
    """The method to use when ordering \`ReservedPatchRecord\`."""
    orderBy: [ReservedPatchRecordOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedPatchRecordEdge
}

"""All input for the create \`ReservedPatchRecord\` mutation."""
input CreateReservedPatchRecordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`ReservedPatchRecord\` to be created by this mutation."""
  reservedPatchRecord: ReservedPatchRecordInput!
}

"""An input for mutations affecting \`ReservedPatchRecord\`"""
input ReservedPatchRecordInput {
  rowId: Int
}

"""The output of our create \`ReservedInputRecord\` mutation."""
type CreateReservedInputRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ReservedInputRecord\` that was created by this mutation."""
  reservedInputRecord: ReservedInputRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ReservedInputRecord\`. May be used by Relay 1."""
  reservedInputRecordEdge(
    """The method to use when ordering \`ReservedInputRecord\`."""
    orderBy: [ReservedInputRecordOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedInputRecordEdge
}

"""All input for the create \`ReservedInputRecord\` mutation."""
input CreateReservedInputRecordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`ReservedInputRecord\` to be created by this mutation."""
  reservedInputRecord: ReservedInputRecordInput!
}

"""An input for mutations affecting \`ReservedInputRecord\`"""
input ReservedInputRecordInput {
  rowId: Int
}

"""The output of our create \`DefaultValue\` mutation."""
type CreateDefaultValuePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`DefaultValue\` that was created by this mutation."""
  defaultValue: DefaultValue

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`DefaultValue\`. May be used by Relay 1."""
  defaultValueEdge(
    """The method to use when ordering \`DefaultValue\`."""
    orderBy: [DefaultValueOrderBy!]! = [PRIMARY_KEY_ASC]
  ): DefaultValueEdge
}

"""All input for the create \`DefaultValue\` mutation."""
input CreateDefaultValueInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`DefaultValue\` to be created by this mutation."""
  defaultValue: DefaultValueInput!
}

"""An input for mutations affecting \`DefaultValue\`"""
input DefaultValueInput {
  rowId: Int
  nullValue: String
}

"""The output of our create \`ForeignKey\` mutation."""
type CreateForeignKeyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ForeignKey\` that was created by this mutation."""
  foreignKey: ForeignKey

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create \`ForeignKey\` mutation."""
input CreateForeignKeyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`ForeignKey\` to be created by this mutation."""
  foreignKey: ForeignKeyInput!
}

"""An input for mutations affecting \`ForeignKey\`"""
input ForeignKeyInput {
  personId: Int
  compoundKey1: Int
  compoundKey2: Int
}

"""The output of our create \`NoPrimaryKey\` mutation."""
type CreateNoPrimaryKeyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`NoPrimaryKey\` that was created by this mutation."""
  noPrimaryKey: NoPrimaryKey

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create \`NoPrimaryKey\` mutation."""
input CreateNoPrimaryKeyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`NoPrimaryKey\` to be created by this mutation."""
  noPrimaryKey: NoPrimaryKeyInput!
}

"""An input for mutations affecting \`NoPrimaryKey\`"""
input NoPrimaryKeyInput {
  rowId: Int!
  str: String!
}

"""The output of our create \`Testview\` mutation."""
type CreateTestviewPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Testview\` that was created by this mutation."""
  testview: Testview

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create \`Testview\` mutation."""
input CreateTestviewInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Testview\` to be created by this mutation."""
  testview: TestviewInput!
}

"""An input for mutations affecting \`Testview\`"""
input TestviewInput {
  testviewid: Int
  col1: Int
  col2: Int
}

"""The output of our create \`UniqueForeignKey\` mutation."""
type CreateUniqueForeignKeyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`UniqueForeignKey\` that was created by this mutation."""
  uniqueForeignKey: UniqueForeignKey

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create \`UniqueForeignKey\` mutation."""
input CreateUniqueForeignKeyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`UniqueForeignKey\` to be created by this mutation."""
  uniqueForeignKey: UniqueForeignKeyInput!
}

"""An input for mutations affecting \`UniqueForeignKey\`"""
input UniqueForeignKeyInput {
  compoundKey1: Int
  compoundKey2: Int
}

"""The output of our create \`CMyTable\` mutation."""
type CreateCMyTablePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CMyTable\` that was created by this mutation."""
  cMyTable: CMyTable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CMyTable\`. May be used by Relay 1."""
  cMyTableEdge(
    """The method to use when ordering \`CMyTable\`."""
    orderBy: [CMyTableOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CMyTableEdge
}

"""All input for the create \`CMyTable\` mutation."""
input CreateCMyTableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`CMyTable\` to be created by this mutation."""
  cMyTable: CMyTableInput!
}

"""An input for mutations affecting \`CMyTable\`"""
input CMyTableInput {
  rowId: Int
  jsonData: JSON
}

"""The output of our create \`CPersonSecret\` mutation."""
type CreateCPersonSecretPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CPersonSecret\` that was created by this mutation."""
  cPersonSecret: CPersonSecret @deprecated(reason: "This is deprecated (comment on table c.person_secret).")

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CPersonSecret\`. May be used by Relay 1."""
  cPersonSecretEdge(
    """The method to use when ordering \`CPersonSecret\`."""
    orderBy: [CPersonSecretOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CPersonSecretEdge @deprecated(reason: "This is deprecated (comment on table c.person_secret).")
}

"""All input for the create \`CPersonSecret\` mutation."""
input CreateCPersonSecretInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`CPersonSecret\` to be created by this mutation."""
  cPersonSecret: CPersonSecretInput!
}

"""An input for mutations affecting \`CPersonSecret\`"""
input CPersonSecretInput {
  personId: Int!

  """A secret held by the associated Person"""
  secret: String
}

"""The output of our create \`ViewTable\` mutation."""
type CreateViewTablePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ViewTable\` that was created by this mutation."""
  viewTable: ViewTable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ViewTable\`. May be used by Relay 1."""
  viewTableEdge(
    """The method to use when ordering \`ViewTable\`."""
    orderBy: [ViewTableOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ViewTableEdge
}

"""All input for the create \`ViewTable\` mutation."""
input CreateViewTableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`ViewTable\` to be created by this mutation."""
  viewTable: ViewTableInput!
}

"""An input for mutations affecting \`ViewTable\`"""
input ViewTableInput {
  rowId: Int
  col1: Int
  col2: Int
}

"""The output of our create \`BUpdatableView\` mutation."""
type CreateBUpdatableViewPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`BUpdatableView\` that was created by this mutation."""
  bUpdatableView: BUpdatableView

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create \`BUpdatableView\` mutation."""
input CreateBUpdatableViewInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`BUpdatableView\` to be created by this mutation."""
  bUpdatableView: BUpdatableViewInput!
}

"""An input for mutations affecting \`BUpdatableView\`"""
input BUpdatableViewInput {
  x: Int
  name: String
  description: String

  """This is constantly 2"""
  constant: Int
}

"""The output of our create \`CCompoundKey\` mutation."""
type CreateCCompoundKeyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CCompoundKey\` that was created by this mutation."""
  cCompoundKey: CCompoundKey

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CCompoundKey\`. May be used by Relay 1."""
  cCompoundKeyEdge(
    """The method to use when ordering \`CCompoundKey\`."""
    orderBy: [CCompoundKeyOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CCompoundKeyEdge
}

"""All input for the create \`CCompoundKey\` mutation."""
input CreateCCompoundKeyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`CCompoundKey\` to be created by this mutation."""
  cCompoundKey: CCompoundKeyInput!
}

"""An input for mutations affecting \`CCompoundKey\`"""
input CCompoundKeyInput {
  personId2: Int!
  personId1: Int!
  extra: Boolean
}

"""The output of our create \`SimilarTable1\` mutation."""
type CreateSimilarTable1Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SimilarTable1\` that was created by this mutation."""
  similarTable1: SimilarTable1

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SimilarTable1\`. May be used by Relay 1."""
  similarTable1Edge(
    """The method to use when ordering \`SimilarTable1\`."""
    orderBy: [SimilarTable1OrderBy!]! = [PRIMARY_KEY_ASC]
  ): SimilarTable1Edge
}

"""All input for the create \`SimilarTable1\` mutation."""
input CreateSimilarTable1Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`SimilarTable1\` to be created by this mutation."""
  similarTable1: SimilarTable1Input!
}

"""An input for mutations affecting \`SimilarTable1\`"""
input SimilarTable1Input {
  rowId: Int
  col1: Int
  col2: Int
  col3: Int!
}

"""The output of our create \`SimilarTable2\` mutation."""
type CreateSimilarTable2Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SimilarTable2\` that was created by this mutation."""
  similarTable2: SimilarTable2

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SimilarTable2\`. May be used by Relay 1."""
  similarTable2Edge(
    """The method to use when ordering \`SimilarTable2\`."""
    orderBy: [SimilarTable2OrderBy!]! = [PRIMARY_KEY_ASC]
  ): SimilarTable2Edge
}

"""All input for the create \`SimilarTable2\` mutation."""
input CreateSimilarTable2Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`SimilarTable2\` to be created by this mutation."""
  similarTable2: SimilarTable2Input!
}

"""An input for mutations affecting \`SimilarTable2\`"""
input SimilarTable2Input {
  rowId: Int
  col3: Int!
  col4: Int
  col5: Int
}

"""The output of our create \`CNullTestRecord\` mutation."""
type CreateCNullTestRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CNullTestRecord\` that was created by this mutation."""
  cNullTestRecord: CNullTestRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CNullTestRecord\`. May be used by Relay 1."""
  cNullTestRecordEdge(
    """The method to use when ordering \`CNullTestRecord\`."""
    orderBy: [CNullTestRecordOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CNullTestRecordEdge
}

"""All input for the create \`CNullTestRecord\` mutation."""
input CreateCNullTestRecordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`CNullTestRecord\` to be created by this mutation."""
  cNullTestRecord: CNullTestRecordInput!
}

"""An input for mutations affecting \`CNullTestRecord\`"""
input CNullTestRecordInput {
  rowId: Int
  nullableText: String
  nullableInt: Int
  nonNullText: String!
}

"""The output of our create \`CEdgeCase\` mutation."""
type CreateCEdgeCasePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CEdgeCase\` that was created by this mutation."""
  cEdgeCase: CEdgeCase

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create \`CEdgeCase\` mutation."""
input CreateCEdgeCaseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`CEdgeCase\` to be created by this mutation."""
  cEdgeCase: CEdgeCaseInput!
}

"""An input for mutations affecting \`CEdgeCase\`"""
input CEdgeCaseInput {
  notNullHasDefault: Boolean
  wontCastEasy: Int
  rowId: Int
}

"""The output of our create \`CLeftArm\` mutation."""
type CreateCLeftArmPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CLeftArm\` that was created by this mutation."""
  cLeftArm: CLeftArm

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CLeftArm\`. May be used by Relay 1."""
  cLeftArmEdge(
    """The method to use when ordering \`CLeftArm\`."""
    orderBy: [CLeftArmOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CLeftArmEdge
}

"""All input for the create \`CLeftArm\` mutation."""
input CreateCLeftArmInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`CLeftArm\` to be created by this mutation."""
  cLeftArm: CLeftArmInput!
}

"""An input for mutations affecting \`CLeftArm\`"""
input CLeftArmInput {
  rowId: Int
  personId: Int
  lengthInMetres: Float
  mood: String
}

"""The output of our create \`CIssue756\` mutation."""
type CreateCIssue756Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CIssue756\` that was created by this mutation."""
  cIssue756: CIssue756

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CIssue756\`. May be used by Relay 1."""
  cIssue756Edge(
    """The method to use when ordering \`CIssue756\`."""
    orderBy: [CIssue756OrderBy!]! = [PRIMARY_KEY_ASC]
  ): CIssue756Edge
}

"""All input for the create \`CIssue756\` mutation."""
input CreateCIssue756Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`CIssue756\` to be created by this mutation."""
  cIssue756: CIssue756Input!
}

"""An input for mutations affecting \`CIssue756\`"""
input CIssue756Input {
  rowId: Int
  ts: CNotNullTimestamp
}

"""The output of our create \`Post\` mutation."""
type CreatePostPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Post\` that was created by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the create \`Post\` mutation."""
input CreatePostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Post\` to be created by this mutation."""
  post: PostInput!
}

"""The output of our create \`CPerson\` mutation."""
type CreateCPersonPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CPerson\` that was created by this mutation."""
  cPerson: CPerson

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CPerson\`. May be used by Relay 1."""
  cPersonEdge(
    """The method to use when ordering \`CPerson\`."""
    orderBy: [CPersonOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CPersonEdge
}

"""All input for the create \`CPerson\` mutation."""
input CreateCPersonInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`CPerson\` to be created by this mutation."""
  cPerson: CPersonInput!
}

"""An input for mutations affecting \`CPerson\`"""
input CPersonInput {
  """The primary unique identifier for the person"""
  rowId: Int

  """The person’s name"""
  name: String!
  aliases: [String]
  about: String
  email: BEmail!
  site: BWrappedUrlInput
  config: KeyValueHash
  lastLoginFromIp: InternetAddress
  lastLoginFromSubnet: CidrAddress
  userMac: MacAddress
  createdAt: Datetime
}

"""An input for mutations affecting \`BWrappedUrl\`"""
input BWrappedUrlInput {
  url: BNotNullUrl!
}

"""The output of our create \`BType\` mutation."""
type CreateBTypePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`BType\` that was created by this mutation."""
  bType: BType

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`BType\`. May be used by Relay 1."""
  bTypeEdge(
    """The method to use when ordering \`BType\`."""
    orderBy: [BTypeOrderBy!]! = [PRIMARY_KEY_ASC]
  ): BTypeEdge
}

"""All input for the create \`BType\` mutation."""
input CreateBTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`BType\` to be created by this mutation."""
  bType: BTypeInput!
}

"""An input for mutations affecting \`BType\`"""
input BTypeInput {
  rowId: Int
  smallint: Int!
  bigint: BigInt!
  numeric: BigFloat!
  decimal: BigFloat!
  boolean: Boolean!
  varchar: String!
  enum: BColor!
  enumArray: [BColor]!
  domain: AnInt!
  domain2: BAnotherInt!
  textArray: [String]!
  json: JSON!
  jsonb: JSON!
  nullableRange: BigFloatRangeInput
  numrange: BigFloatRangeInput!
  daterange: DateRangeInput!
  anIntRange: AnIntRangeInput!
  timestamp: Datetime!
  timestamptz: Datetime!
  date: Date!
  time: Time!
  timetz: Time!
  interval: IntervalInput!
  intervalArray: [IntervalInput]!
  money: Float!
  compoundType: CCompoundTypeInput!
  nestedCompoundType: BNestedCompoundTypeInput!
  nullableCompoundType: CCompoundTypeInput
  nullableNestedCompoundType: BNestedCompoundTypeInput
  point: PointInput!
  nullablePoint: PointInput
  inet: InternetAddress
  cidr: CidrAddress
  macaddr: MacAddress
  regproc: RegProc
  regprocedure: RegProcedure
  regoper: RegOper
  regoperator: RegOperator
  regclass: RegClass
  regtype: RegType
  regconfig: RegConfig
  regdictionary: RegDictionary
  textArrayDomain: [String]
  int8ArrayDomain: [BigInt]
  bytea: Base64EncodedBinary
  byteaArray: [Base64EncodedBinary]
  ltree: LTree
  ltreeArray: [LTree]
}

"""A range of \`BigFloat\`."""
input BigFloatRangeInput {
  """The starting bound of our range."""
  start: BigFloatRangeBoundInput

  """The ending bound of our range."""
  end: BigFloatRangeBoundInput
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
input BigFloatRangeBoundInput {
  """The value at one end of our range."""
  value: BigFloat!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""A range of \`Date\`."""
input DateRangeInput {
  """The starting bound of our range."""
  start: DateRangeBoundInput

  """The ending bound of our range."""
  end: DateRangeBoundInput
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
input DateRangeBoundInput {
  """The value at one end of our range."""
  value: Date!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""A range of \`AnInt\`."""
input AnIntRangeInput {
  """The starting bound of our range."""
  start: AnIntRangeBoundInput

  """The ending bound of our range."""
  end: AnIntRangeBoundInput
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
input AnIntRangeBoundInput {
  """The value at one end of our range."""
  value: AnInt!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""An input for mutations affecting \`BNestedCompoundType\`"""
input BNestedCompoundTypeInput {
  a: CCompoundTypeInput
  b: CCompoundTypeInput
  bazBuz: Int
}

"""The output of our update \`Input\` mutation."""
type UpdateInputPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Input\` that was updated by this mutation."""
  input: Input

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Input\`. May be used by Relay 1."""
  inputEdge(
    """The method to use when ordering \`Input\`."""
    orderBy: [InputOrderBy!]! = [PRIMARY_KEY_ASC]
  ): InputEdge
}

"""All input for the \`updateInputByRowId\` mutation."""
input UpdateInputByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!

  """
  An object where the defined keys will be set on the \`Input\` being updated.
  """
  inputPatch: InputPatch!
}

"""
Represents an update to a \`Input\`. Fields that are set will be updated.
"""
input InputPatch {
  rowId: Int
}

"""The output of our update \`Patch\` mutation."""
type UpdatePatchPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Patch\` that was updated by this mutation."""
  patch: Patch

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Patch\`. May be used by Relay 1."""
  patchEdge(
    """The method to use when ordering \`Patch\`."""
    orderBy: [PatchOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PatchEdge
}

"""All input for the \`updatePatchByRowId\` mutation."""
input UpdatePatchByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!

  """
  An object where the defined keys will be set on the \`Patch\` being updated.
  """
  patchPatch: PatchPatch!
}

"""
Represents an update to a \`Patch\`. Fields that are set will be updated.
"""
input PatchPatch {
  rowId: Int
}

"""The output of our update \`Reserved\` mutation."""
type UpdateReservedPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Reserved\` that was updated by this mutation."""
  reserved: Reserved

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Reserved\`. May be used by Relay 1."""
  reservedEdge(
    """The method to use when ordering \`Reserved\`."""
    orderBy: [ReservedOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedEdge
}

"""All input for the \`updateReservedByRowId\` mutation."""
input UpdateReservedByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!

  """
  An object where the defined keys will be set on the \`Reserved\` being updated.
  """
  reservedPatch: ReservedPatch!
}

"""
Represents an update to a \`Reserved\`. Fields that are set will be updated.
"""
input ReservedPatch {
  rowId: Int
}

"""The output of our update \`ReservedPatchRecord\` mutation."""
type UpdateReservedPatchRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ReservedPatchRecord\` that was updated by this mutation."""
  reservedPatchRecord: ReservedPatchRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ReservedPatchRecord\`. May be used by Relay 1."""
  reservedPatchRecordEdge(
    """The method to use when ordering \`ReservedPatchRecord\`."""
    orderBy: [ReservedPatchRecordOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedPatchRecordEdge
}

"""All input for the \`updateReservedPatchRecordByRowId\` mutation."""
input UpdateReservedPatchRecordByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!

  """
  An object where the defined keys will be set on the \`ReservedPatchRecord\` being updated.
  """
  reservedPatchRecordPatch: ReservedPatchRecordPatch!
}

"""
Represents an update to a \`ReservedPatchRecord\`. Fields that are set will be updated.
"""
input ReservedPatchRecordPatch {
  rowId: Int
}

"""The output of our update \`ReservedInputRecord\` mutation."""
type UpdateReservedInputRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ReservedInputRecord\` that was updated by this mutation."""
  reservedInputRecord: ReservedInputRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ReservedInputRecord\`. May be used by Relay 1."""
  reservedInputRecordEdge(
    """The method to use when ordering \`ReservedInputRecord\`."""
    orderBy: [ReservedInputRecordOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedInputRecordEdge
}

"""All input for the \`updateReservedInputRecordByRowId\` mutation."""
input UpdateReservedInputRecordByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!

  """
  An object where the defined keys will be set on the \`ReservedInputRecord\` being updated.
  """
  reservedInputRecordPatch: ReservedInputRecordPatch!
}

"""
Represents an update to a \`ReservedInputRecord\`. Fields that are set will be updated.
"""
input ReservedInputRecordPatch {
  rowId: Int
}

"""The output of our update \`DefaultValue\` mutation."""
type UpdateDefaultValuePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`DefaultValue\` that was updated by this mutation."""
  defaultValue: DefaultValue

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`DefaultValue\`. May be used by Relay 1."""
  defaultValueEdge(
    """The method to use when ordering \`DefaultValue\`."""
    orderBy: [DefaultValueOrderBy!]! = [PRIMARY_KEY_ASC]
  ): DefaultValueEdge
}

"""All input for the \`updateDefaultValueByRowId\` mutation."""
input UpdateDefaultValueByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!

  """
  An object where the defined keys will be set on the \`DefaultValue\` being updated.
  """
  defaultValuePatch: DefaultValuePatch!
}

"""
Represents an update to a \`DefaultValue\`. Fields that are set will be updated.
"""
input DefaultValuePatch {
  rowId: Int
  nullValue: String
}

"""The output of our update \`NoPrimaryKey\` mutation."""
type UpdateNoPrimaryKeyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`NoPrimaryKey\` that was updated by this mutation."""
  noPrimaryKey: NoPrimaryKey

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`updateNoPrimaryKeyByRowId\` mutation."""
input UpdateNoPrimaryKeyByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!

  """
  An object where the defined keys will be set on the \`NoPrimaryKey\` being updated.
  """
  noPrimaryKeyPatch: NoPrimaryKeyPatch!
}

"""
Represents an update to a \`NoPrimaryKey\`. Fields that are set will be updated.
"""
input NoPrimaryKeyPatch {
  rowId: Int
  str: String
}

"""The output of our update \`UniqueForeignKey\` mutation."""
type UpdateUniqueForeignKeyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`UniqueForeignKey\` that was updated by this mutation."""
  uniqueForeignKey: UniqueForeignKey

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the \`updateUniqueForeignKeyByCompoundKey1AndCompoundKey2\` mutation.
"""
input UpdateUniqueForeignKeyByCompoundKey1AndCompoundKey2Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  compoundKey1: Int!
  compoundKey2: Int!

  """
  An object where the defined keys will be set on the \`UniqueForeignKey\` being updated.
  """
  uniqueForeignKeyPatch: UniqueForeignKeyPatch!
}

"""
Represents an update to a \`UniqueForeignKey\`. Fields that are set will be updated.
"""
input UniqueForeignKeyPatch {
  compoundKey1: Int
  compoundKey2: Int
}

"""The output of our update \`CMyTable\` mutation."""
type UpdateCMyTablePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CMyTable\` that was updated by this mutation."""
  cMyTable: CMyTable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CMyTable\`. May be used by Relay 1."""
  cMyTableEdge(
    """The method to use when ordering \`CMyTable\`."""
    orderBy: [CMyTableOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CMyTableEdge
}

"""All input for the \`updateCMyTableByRowId\` mutation."""
input UpdateCMyTableByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!

  """
  An object where the defined keys will be set on the \`CMyTable\` being updated.
  """
  cMyTablePatch: CMyTablePatch!
}

"""
Represents an update to a \`CMyTable\`. Fields that are set will be updated.
"""
input CMyTablePatch {
  rowId: Int
  jsonData: JSON
}

"""The output of our update \`CPersonSecret\` mutation."""
type UpdateCPersonSecretPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CPersonSecret\` that was updated by this mutation."""
  cPersonSecret: CPersonSecret

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CPersonSecret\`. May be used by Relay 1."""
  cPersonSecretEdge(
    """The method to use when ordering \`CPersonSecret\`."""
    orderBy: [CPersonSecretOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CPersonSecretEdge @deprecated(reason: "This is deprecated (comment on table c.person_secret).")
}

"""All input for the \`updateCPersonSecretByPersonId\` mutation."""
input UpdateCPersonSecretByPersonIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  personId: Int!

  """
  An object where the defined keys will be set on the \`CPersonSecret\` being updated.
  """
  cPersonSecretPatch: CPersonSecretPatch!
}

"""
Represents an update to a \`CPersonSecret\`. Fields that are set will be updated.
"""
input CPersonSecretPatch {
  personId: Int

  """A secret held by the associated Person"""
  secret: String
}

"""The output of our update \`ViewTable\` mutation."""
type UpdateViewTablePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ViewTable\` that was updated by this mutation."""
  viewTable: ViewTable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ViewTable\`. May be used by Relay 1."""
  viewTableEdge(
    """The method to use when ordering \`ViewTable\`."""
    orderBy: [ViewTableOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ViewTableEdge
}

"""All input for the \`updateViewTableByRowId\` mutation."""
input UpdateViewTableByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!

  """
  An object where the defined keys will be set on the \`ViewTable\` being updated.
  """
  viewTablePatch: ViewTablePatch!
}

"""
Represents an update to a \`ViewTable\`. Fields that are set will be updated.
"""
input ViewTablePatch {
  rowId: Int
  col1: Int
  col2: Int
}

"""The output of our update \`CCompoundKey\` mutation."""
type UpdateCCompoundKeyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CCompoundKey\` that was updated by this mutation."""
  cCompoundKey: CCompoundKey

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CCompoundKey\`. May be used by Relay 1."""
  cCompoundKeyEdge(
    """The method to use when ordering \`CCompoundKey\`."""
    orderBy: [CCompoundKeyOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CCompoundKeyEdge
}

"""
All input for the \`updateCCompoundKeyByPersonId1AndPersonId2\` mutation.
"""
input UpdateCCompoundKeyByPersonId1AndPersonId2Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  personId1: Int!
  personId2: Int!

  """
  An object where the defined keys will be set on the \`CCompoundKey\` being updated.
  """
  cCompoundKeyPatch: CCompoundKeyPatch!
}

"""
Represents an update to a \`CCompoundKey\`. Fields that are set will be updated.
"""
input CCompoundKeyPatch {
  personId2: Int
  personId1: Int
  extra: Boolean
}

"""The output of our update \`SimilarTable1\` mutation."""
type UpdateSimilarTable1Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SimilarTable1\` that was updated by this mutation."""
  similarTable1: SimilarTable1

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SimilarTable1\`. May be used by Relay 1."""
  similarTable1Edge(
    """The method to use when ordering \`SimilarTable1\`."""
    orderBy: [SimilarTable1OrderBy!]! = [PRIMARY_KEY_ASC]
  ): SimilarTable1Edge
}

"""All input for the \`updateSimilarTable1ByRowId\` mutation."""
input UpdateSimilarTable1ByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!

  """
  An object where the defined keys will be set on the \`SimilarTable1\` being updated.
  """
  similarTable1Patch: SimilarTable1Patch!
}

"""
Represents an update to a \`SimilarTable1\`. Fields that are set will be updated.
"""
input SimilarTable1Patch {
  rowId: Int
  col1: Int
  col2: Int
  col3: Int
}

"""The output of our update \`SimilarTable2\` mutation."""
type UpdateSimilarTable2Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SimilarTable2\` that was updated by this mutation."""
  similarTable2: SimilarTable2

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SimilarTable2\`. May be used by Relay 1."""
  similarTable2Edge(
    """The method to use when ordering \`SimilarTable2\`."""
    orderBy: [SimilarTable2OrderBy!]! = [PRIMARY_KEY_ASC]
  ): SimilarTable2Edge
}

"""All input for the \`updateSimilarTable2ByRowId\` mutation."""
input UpdateSimilarTable2ByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!

  """
  An object where the defined keys will be set on the \`SimilarTable2\` being updated.
  """
  similarTable2Patch: SimilarTable2Patch!
}

"""
Represents an update to a \`SimilarTable2\`. Fields that are set will be updated.
"""
input SimilarTable2Patch {
  rowId: Int
  col3: Int
  col4: Int
  col5: Int
}

"""The output of our update \`CNullTestRecord\` mutation."""
type UpdateCNullTestRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CNullTestRecord\` that was updated by this mutation."""
  cNullTestRecord: CNullTestRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CNullTestRecord\`. May be used by Relay 1."""
  cNullTestRecordEdge(
    """The method to use when ordering \`CNullTestRecord\`."""
    orderBy: [CNullTestRecordOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CNullTestRecordEdge
}

"""All input for the \`updateCNullTestRecordByRowId\` mutation."""
input UpdateCNullTestRecordByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!

  """
  An object where the defined keys will be set on the \`CNullTestRecord\` being updated.
  """
  cNullTestRecordPatch: CNullTestRecordPatch!
}

"""
Represents an update to a \`CNullTestRecord\`. Fields that are set will be updated.
"""
input CNullTestRecordPatch {
  rowId: Int
  nullableText: String
  nullableInt: Int
  nonNullText: String
}

"""The output of our update \`CLeftArm\` mutation."""
type UpdateCLeftArmPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CLeftArm\` that was updated by this mutation."""
  cLeftArm: CLeftArm

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CLeftArm\`. May be used by Relay 1."""
  cLeftArmEdge(
    """The method to use when ordering \`CLeftArm\`."""
    orderBy: [CLeftArmOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CLeftArmEdge
}

"""All input for the \`updateCLeftArmByRowId\` mutation."""
input UpdateCLeftArmByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!

  """
  An object where the defined keys will be set on the \`CLeftArm\` being updated.
  """
  cLeftArmPatch: CLeftArmPatch!
}

"""
Represents an update to a \`CLeftArm\`. Fields that are set will be updated.
"""
input CLeftArmPatch {
  rowId: Int
  personId: Int
  lengthInMetres: Float
  mood: String
}

"""All input for the \`updateCLeftArmByPersonId\` mutation."""
input UpdateCLeftArmByPersonIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  personId: Int!

  """
  An object where the defined keys will be set on the \`CLeftArm\` being updated.
  """
  cLeftArmPatch: CLeftArmPatch!
}

"""The output of our update \`CIssue756\` mutation."""
type UpdateCIssue756Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CIssue756\` that was updated by this mutation."""
  cIssue756: CIssue756

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CIssue756\`. May be used by Relay 1."""
  cIssue756Edge(
    """The method to use when ordering \`CIssue756\`."""
    orderBy: [CIssue756OrderBy!]! = [PRIMARY_KEY_ASC]
  ): CIssue756Edge
}

"""All input for the \`updateCIssue756ByRowId\` mutation."""
input UpdateCIssue756ByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!

  """
  An object where the defined keys will be set on the \`CIssue756\` being updated.
  """
  cIssue756Patch: CIssue756Patch!
}

"""
Represents an update to a \`CIssue756\`. Fields that are set will be updated.
"""
input CIssue756Patch {
  rowId: Int
  ts: CNotNullTimestamp
}

"""The output of our update \`Post\` mutation."""
type UpdatePostPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Post\` that was updated by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the \`updatePostByRowId\` mutation."""
input UpdatePostByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!

  """
  An object where the defined keys will be set on the \`Post\` being updated.
  """
  postPatch: PostPatch!
}

"""Represents an update to a \`Post\`. Fields that are set will be updated."""
input PostPatch {
  rowId: Int
  headline: String
  body: String
  authorId: Int
  enums: [AnEnum]
  comptypes: [ComptypeInput]
}

"""The output of our update \`CPerson\` mutation."""
type UpdateCPersonPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CPerson\` that was updated by this mutation."""
  cPerson: CPerson

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CPerson\`. May be used by Relay 1."""
  cPersonEdge(
    """The method to use when ordering \`CPerson\`."""
    orderBy: [CPersonOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CPersonEdge
}

"""All input for the \`updateCPersonByRowId\` mutation."""
input UpdateCPersonByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The primary unique identifier for the person"""
  rowId: Int!

  """
  An object where the defined keys will be set on the \`CPerson\` being updated.
  """
  cPersonPatch: CPersonPatch!
}

"""
Represents an update to a \`CPerson\`. Fields that are set will be updated.
"""
input CPersonPatch {
  """The primary unique identifier for the person"""
  rowId: Int

  """The person’s name"""
  name: String
  aliases: [String]
  about: String
  email: BEmail
  site: BWrappedUrlInput
  config: KeyValueHash
  lastLoginFromIp: InternetAddress
  lastLoginFromSubnet: CidrAddress
  userMac: MacAddress
  createdAt: Datetime
}

"""All input for the \`updateCPersonByEmail\` mutation."""
input UpdateCPersonByEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  email: BEmail!

  """
  An object where the defined keys will be set on the \`CPerson\` being updated.
  """
  cPersonPatch: CPersonPatch!
}

"""The output of our update \`BType\` mutation."""
type UpdateBTypePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`BType\` that was updated by this mutation."""
  bType: BType

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`BType\`. May be used by Relay 1."""
  bTypeEdge(
    """The method to use when ordering \`BType\`."""
    orderBy: [BTypeOrderBy!]! = [PRIMARY_KEY_ASC]
  ): BTypeEdge
}

"""All input for the \`updateBTypeByRowId\` mutation."""
input UpdateBTypeByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!

  """
  An object where the defined keys will be set on the \`BType\` being updated.
  """
  bTypePatch: BTypePatch!
}

"""
Represents an update to a \`BType\`. Fields that are set will be updated.
"""
input BTypePatch {
  rowId: Int
  smallint: Int
  bigint: BigInt
  numeric: BigFloat
  decimal: BigFloat
  boolean: Boolean
  varchar: String
  enum: BColor
  enumArray: [BColor]
  domain: AnInt
  domain2: BAnotherInt
  textArray: [String]
  json: JSON
  jsonb: JSON
  nullableRange: BigFloatRangeInput
  numrange: BigFloatRangeInput
  daterange: DateRangeInput
  anIntRange: AnIntRangeInput
  timestamp: Datetime
  timestamptz: Datetime
  date: Date
  time: Time
  timetz: Time
  interval: IntervalInput
  intervalArray: [IntervalInput]
  money: Float
  compoundType: CCompoundTypeInput
  nestedCompoundType: BNestedCompoundTypeInput
  nullableCompoundType: CCompoundTypeInput
  nullableNestedCompoundType: BNestedCompoundTypeInput
  point: PointInput
  nullablePoint: PointInput
  inet: InternetAddress
  cidr: CidrAddress
  macaddr: MacAddress
  regproc: RegProc
  regprocedure: RegProcedure
  regoper: RegOper
  regoperator: RegOperator
  regclass: RegClass
  regtype: RegType
  regconfig: RegConfig
  regdictionary: RegDictionary
  textArrayDomain: [String]
  int8ArrayDomain: [BigInt]
  bytea: Base64EncodedBinary
  byteaArray: [Base64EncodedBinary]
  ltree: LTree
  ltreeArray: [LTree]
}

"""The output of our delete \`Input\` mutation."""
type DeleteInputPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Input\` that was deleted by this mutation."""
  input: Input

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Input\`. May be used by Relay 1."""
  inputEdge(
    """The method to use when ordering \`Input\`."""
    orderBy: [InputOrderBy!]! = [PRIMARY_KEY_ASC]
  ): InputEdge
}

"""All input for the \`deleteInputByRowId\` mutation."""
input DeleteInputByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!
}

"""The output of our delete \`Patch\` mutation."""
type DeletePatchPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Patch\` that was deleted by this mutation."""
  patch: Patch

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Patch\`. May be used by Relay 1."""
  patchEdge(
    """The method to use when ordering \`Patch\`."""
    orderBy: [PatchOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PatchEdge
}

"""All input for the \`deletePatchByRowId\` mutation."""
input DeletePatchByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!
}

"""The output of our delete \`Reserved\` mutation."""
type DeleteReservedPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Reserved\` that was deleted by this mutation."""
  reserved: Reserved

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Reserved\`. May be used by Relay 1."""
  reservedEdge(
    """The method to use when ordering \`Reserved\`."""
    orderBy: [ReservedOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedEdge
}

"""All input for the \`deleteReservedByRowId\` mutation."""
input DeleteReservedByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!
}

"""The output of our delete \`ReservedPatchRecord\` mutation."""
type DeleteReservedPatchRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ReservedPatchRecord\` that was deleted by this mutation."""
  reservedPatchRecord: ReservedPatchRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ReservedPatchRecord\`. May be used by Relay 1."""
  reservedPatchRecordEdge(
    """The method to use when ordering \`ReservedPatchRecord\`."""
    orderBy: [ReservedPatchRecordOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedPatchRecordEdge
}

"""All input for the \`deleteReservedPatchRecordByRowId\` mutation."""
input DeleteReservedPatchRecordByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!
}

"""The output of our delete \`ReservedInputRecord\` mutation."""
type DeleteReservedInputRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ReservedInputRecord\` that was deleted by this mutation."""
  reservedInputRecord: ReservedInputRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ReservedInputRecord\`. May be used by Relay 1."""
  reservedInputRecordEdge(
    """The method to use when ordering \`ReservedInputRecord\`."""
    orderBy: [ReservedInputRecordOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedInputRecordEdge
}

"""All input for the \`deleteReservedInputRecordByRowId\` mutation."""
input DeleteReservedInputRecordByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!
}

"""The output of our delete \`DefaultValue\` mutation."""
type DeleteDefaultValuePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`DefaultValue\` that was deleted by this mutation."""
  defaultValue: DefaultValue

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`DefaultValue\`. May be used by Relay 1."""
  defaultValueEdge(
    """The method to use when ordering \`DefaultValue\`."""
    orderBy: [DefaultValueOrderBy!]! = [PRIMARY_KEY_ASC]
  ): DefaultValueEdge
}

"""All input for the \`deleteDefaultValueByRowId\` mutation."""
input DeleteDefaultValueByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!
}

"""The output of our delete \`NoPrimaryKey\` mutation."""
type DeleteNoPrimaryKeyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`NoPrimaryKey\` that was deleted by this mutation."""
  noPrimaryKey: NoPrimaryKey

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`deleteNoPrimaryKeyByRowId\` mutation."""
input DeleteNoPrimaryKeyByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!
}

"""The output of our delete \`UniqueForeignKey\` mutation."""
type DeleteUniqueForeignKeyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`UniqueForeignKey\` that was deleted by this mutation."""
  uniqueForeignKey: UniqueForeignKey

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the \`deleteUniqueForeignKeyByCompoundKey1AndCompoundKey2\` mutation.
"""
input DeleteUniqueForeignKeyByCompoundKey1AndCompoundKey2Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  compoundKey1: Int!
  compoundKey2: Int!
}

"""The output of our delete \`CMyTable\` mutation."""
type DeleteCMyTablePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CMyTable\` that was deleted by this mutation."""
  cMyTable: CMyTable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CMyTable\`. May be used by Relay 1."""
  cMyTableEdge(
    """The method to use when ordering \`CMyTable\`."""
    orderBy: [CMyTableOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CMyTableEdge
}

"""All input for the \`deleteCMyTableByRowId\` mutation."""
input DeleteCMyTableByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!
}

"""The output of our delete \`CPersonSecret\` mutation."""
type DeleteCPersonSecretPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CPersonSecret\` that was deleted by this mutation."""
  cPersonSecret: CPersonSecret

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CPersonSecret\`. May be used by Relay 1."""
  cPersonSecretEdge(
    """The method to use when ordering \`CPersonSecret\`."""
    orderBy: [CPersonSecretOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CPersonSecretEdge @deprecated(reason: "This is deprecated (comment on table c.person_secret).")
}

"""All input for the \`deleteCPersonSecretByPersonId\` mutation."""
input DeleteCPersonSecretByPersonIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  personId: Int!
}

"""The output of our delete \`ViewTable\` mutation."""
type DeleteViewTablePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ViewTable\` that was deleted by this mutation."""
  viewTable: ViewTable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ViewTable\`. May be used by Relay 1."""
  viewTableEdge(
    """The method to use when ordering \`ViewTable\`."""
    orderBy: [ViewTableOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ViewTableEdge
}

"""All input for the \`deleteViewTableByRowId\` mutation."""
input DeleteViewTableByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!
}

"""The output of our delete \`CCompoundKey\` mutation."""
type DeleteCCompoundKeyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CCompoundKey\` that was deleted by this mutation."""
  cCompoundKey: CCompoundKey

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CCompoundKey\`. May be used by Relay 1."""
  cCompoundKeyEdge(
    """The method to use when ordering \`CCompoundKey\`."""
    orderBy: [CCompoundKeyOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CCompoundKeyEdge
}

"""
All input for the \`deleteCCompoundKeyByPersonId1AndPersonId2\` mutation.
"""
input DeleteCCompoundKeyByPersonId1AndPersonId2Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  personId1: Int!
  personId2: Int!
}

"""The output of our delete \`SimilarTable1\` mutation."""
type DeleteSimilarTable1Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SimilarTable1\` that was deleted by this mutation."""
  similarTable1: SimilarTable1

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SimilarTable1\`. May be used by Relay 1."""
  similarTable1Edge(
    """The method to use when ordering \`SimilarTable1\`."""
    orderBy: [SimilarTable1OrderBy!]! = [PRIMARY_KEY_ASC]
  ): SimilarTable1Edge
}

"""All input for the \`deleteSimilarTable1ByRowId\` mutation."""
input DeleteSimilarTable1ByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!
}

"""The output of our delete \`SimilarTable2\` mutation."""
type DeleteSimilarTable2Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SimilarTable2\` that was deleted by this mutation."""
  similarTable2: SimilarTable2

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SimilarTable2\`. May be used by Relay 1."""
  similarTable2Edge(
    """The method to use when ordering \`SimilarTable2\`."""
    orderBy: [SimilarTable2OrderBy!]! = [PRIMARY_KEY_ASC]
  ): SimilarTable2Edge
}

"""All input for the \`deleteSimilarTable2ByRowId\` mutation."""
input DeleteSimilarTable2ByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!
}

"""The output of our delete \`CNullTestRecord\` mutation."""
type DeleteCNullTestRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CNullTestRecord\` that was deleted by this mutation."""
  cNullTestRecord: CNullTestRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CNullTestRecord\`. May be used by Relay 1."""
  cNullTestRecordEdge(
    """The method to use when ordering \`CNullTestRecord\`."""
    orderBy: [CNullTestRecordOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CNullTestRecordEdge
}

"""All input for the \`deleteCNullTestRecordByRowId\` mutation."""
input DeleteCNullTestRecordByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!
}

"""The output of our delete \`CLeftArm\` mutation."""
type DeleteCLeftArmPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CLeftArm\` that was deleted by this mutation."""
  cLeftArm: CLeftArm

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CLeftArm\`. May be used by Relay 1."""
  cLeftArmEdge(
    """The method to use when ordering \`CLeftArm\`."""
    orderBy: [CLeftArmOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CLeftArmEdge
}

"""All input for the \`deleteCLeftArmByRowId\` mutation."""
input DeleteCLeftArmByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!
}

"""All input for the \`deleteCLeftArmByPersonId\` mutation."""
input DeleteCLeftArmByPersonIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  personId: Int!
}

"""The output of our delete \`CIssue756\` mutation."""
type DeleteCIssue756Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CIssue756\` that was deleted by this mutation."""
  cIssue756: CIssue756

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CIssue756\`. May be used by Relay 1."""
  cIssue756Edge(
    """The method to use when ordering \`CIssue756\`."""
    orderBy: [CIssue756OrderBy!]! = [PRIMARY_KEY_ASC]
  ): CIssue756Edge
}

"""All input for the \`deleteCIssue756ByRowId\` mutation."""
input DeleteCIssue756ByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!
}

"""The output of our delete \`Post\` mutation."""
type DeletePostPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Post\` that was deleted by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the \`deletePostByRowId\` mutation."""
input DeletePostByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!
}

"""The output of our delete \`CPerson\` mutation."""
type DeleteCPersonPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CPerson\` that was deleted by this mutation."""
  cPerson: CPerson

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CPerson\`. May be used by Relay 1."""
  cPersonEdge(
    """The method to use when ordering \`CPerson\`."""
    orderBy: [CPersonOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CPersonEdge
}

"""All input for the \`deleteCPersonByRowId\` mutation."""
input DeleteCPersonByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The primary unique identifier for the person"""
  rowId: Int!
}

"""All input for the \`deleteCPersonByEmail\` mutation."""
input DeleteCPersonByEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  email: BEmail!
}

"""The output of our delete \`BType\` mutation."""
type DeleteBTypePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`BType\` that was deleted by this mutation."""
  bType: BType

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`BType\`. May be used by Relay 1."""
  bTypeEdge(
    """The method to use when ordering \`BType\`."""
    orderBy: [BTypeOrderBy!]! = [PRIMARY_KEY_ASC]
  ): BTypeEdge
}

"""All input for the \`deleteBTypeByRowId\` mutation."""
input DeleteBTypeByRowIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: Int!
}`;
export const plans = {
  Query: {
    __assertStep() {
      return true;
    },
    query: Query_queryPlan,
    inputByRowId: {
      plan(_$root, args) {
        return resource_inputsPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    patchByRowId: {
      plan(_$root, args) {
        return resource_patchsPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    reservedByRowId: {
      plan(_$root, args) {
        return resource_reservedPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    reservedPatchRecordByRowId: {
      plan(_$root, args) {
        return resource_reservedPatchsPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    reservedInputRecordByRowId: {
      plan(_$root, args) {
        return resource_reserved_inputPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    defaultValueByRowId: {
      plan(_$root, args) {
        return resource_default_valuePgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    noPrimaryKeyByRowId: {
      plan(_$root, args) {
        return resource_no_primary_keyPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    uniqueForeignKeyByCompoundKey1AndCompoundKey2: {
      plan(_$root, args) {
        return resource_unique_foreign_keyPgResource.get({
          compound_key_1: args.get("compoundKey1"),
          compound_key_2: args.get("compoundKey2")
        });
      },
      args: {
        compoundKey1: undefined,
        compoundKey2: undefined
      }
    },
    cMyTableByRowId: {
      plan(_$root, args) {
        return resource_c_my_tablePgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    cPersonSecretByPersonId: {
      plan(_$root, args) {
        return resource_c_person_secretPgResource.get({
          person_id: args.get("personId")
        });
      },
      args: {
        personId: undefined
      }
    },
    viewTableByRowId: {
      plan(_$root, args) {
        return resource_view_tablePgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    cCompoundKeyByPersonId1AndPersonId2: {
      plan(_$root, args) {
        return resource_c_compound_keyPgResource.get({
          person_id_1: args.get("personId1"),
          person_id_2: args.get("personId2")
        });
      },
      args: {
        personId1: undefined,
        personId2: undefined
      }
    },
    similarTable1ByRowId: {
      plan(_$root, args) {
        return resource_similar_table_1PgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    similarTable2ByRowId: {
      plan(_$root, args) {
        return resource_similar_table_2PgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    cNullTestRecordByRowId: {
      plan(_$root, args) {
        return resource_c_null_test_recordPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    cLeftArmByRowId: {
      plan(_$root, args) {
        return resource_c_left_armPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    cLeftArmByPersonId: {
      plan(_$root, args) {
        return resource_c_left_armPgResource.get({
          person_id: args.get("personId")
        });
      },
      args: {
        personId: undefined
      }
    },
    cIssue756ByRowId: {
      plan(_$root, args) {
        return resource_c_issue756PgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    postByRowId: {
      plan(_$root, args) {
        return resource_postPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    cPersonByRowId: {
      plan(_$root, args) {
        return resource_c_personPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    cPersonByEmail: {
      plan(_$root, args) {
        return resource_c_personPgResource.get({
          email: args.get("email")
        });
      },
      args: {
        email: undefined
      }
    },
    bTypeByRowId: {
      plan(_$root, args) {
        return resource_b_typesPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    cCurrentUserId($root, args, _info) {
      const selectArgs = makeArgs(args);
      return resource_c_current_user_idPgResource.execute(selectArgs);
    },
    cFuncOut($root, args, _info) {
      const selectArgs = makeArgs2(args);
      return resource_c_func_outPgResource.execute(selectArgs);
    },
    cFuncOutSetof: {
      plan: Query_cFuncOutSetofPlan,
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutSetof_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutSetof_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutSetof_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutSetof_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutSetof_after_applyPlan
        }
      }
    },
    cFuncOutUnnamed($root, args, _info) {
      const selectArgs = makeArgs4(args);
      return resource_c_func_out_unnamedPgResource.execute(selectArgs);
    },
    cNoArgsQuery($root, args, _info) {
      const selectArgs = makeArgs5(args);
      return resource_c_no_args_queryPgResource.execute(selectArgs);
    },
    queryIntervalSet: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs2($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_queryIntervalSet_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_queryIntervalSet_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_queryIntervalSet_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_queryIntervalSet_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_queryIntervalSet_after_applyPlan
        }
      }
    },
    staticBigInteger: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs3($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_staticBigInteger_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_staticBigInteger_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_staticBigInteger_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_staticBigInteger_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_staticBigInteger_after_applyPlan
        }
      }
    },
    cFuncInOut: {
      plan($root, args, _info) {
        const selectArgs = makeArgs8(args);
        return resource_c_func_in_outPgResource.execute(selectArgs);
      },
      args: {
        i: undefined
      }
    },
    cFuncReturnsTableOneCol: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs4($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        i: undefined,
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncReturnsTableOneCol_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncReturnsTableOneCol_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncReturnsTableOneCol_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncReturnsTableOneCol_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncReturnsTableOneCol_after_applyPlan
        }
      }
    },
    cJsonIdentity: {
      plan($root, args, _info) {
        const selectArgs = makeArgs10(args);
        return resource_c_json_identityPgResource.execute(selectArgs);
      },
      args: {
        json: undefined
      }
    },
    cJsonbIdentity: {
      plan($root, args, _info) {
        const selectArgs = makeArgs11(args);
        return resource_c_jsonb_identityPgResource.execute(selectArgs);
      },
      args: {
        json: undefined
      }
    },
    add1Query: {
      plan($root, args, _info) {
        const selectArgs = makeArgs12(args);
        return resource_add_1_queryPgResource.execute(selectArgs);
      },
      args: {
        arg0: undefined,
        arg1: undefined
      }
    },
    add2Query: {
      plan($root, args, _info) {
        const selectArgs = makeArgs13(args);
        return resource_add_2_queryPgResource.execute(selectArgs);
      },
      args: {
        a: undefined,
        b: undefined
      }
    },
    add3Query: {
      plan($root, args, _info) {
        const selectArgs = makeArgs14(args);
        return resource_add_3_queryPgResource.execute(selectArgs);
      },
      args: {
        a: undefined,
        arg1: undefined
      }
    },
    add4Query: {
      plan($root, args, _info) {
        const selectArgs = makeArgs15(args);
        return resource_add_4_queryPgResource.execute(selectArgs);
      },
      args: {
        arg0: undefined,
        b: undefined
      }
    },
    cFuncInInout: {
      plan($root, args, _info) {
        const selectArgs = makeArgs16(args);
        return resource_c_func_in_inoutPgResource.execute(selectArgs);
      },
      args: {
        i: undefined,
        ino: undefined
      }
    },
    cFuncOutOut($root, args, _info) {
      const selectArgs = makeArgs17(args);
      return resource_c_func_out_outPgResource.execute(selectArgs);
    },
    cFuncOutOutSetof: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs5($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutOutSetof_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutOutSetof_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutOutSetof_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutOutSetof_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutOutSetof_after_applyPlan
        }
      }
    },
    cFuncOutOutUnnamed($root, args, _info) {
      const selectArgs = makeArgs19(args);
      return resource_c_func_out_out_unnamedPgResource.execute(selectArgs);
    },
    cSearchTestSummaries: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs6($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cSearchTestSummaries_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cSearchTestSummaries_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cSearchTestSummaries_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cSearchTestSummaries_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cSearchTestSummaries_after_applyPlan
        }
      }
    },
    optionalMissingMiddle1: {
      plan($root, args, _info) {
        const selectArgs = makeArgs21(args);
        return resource_optional_missing_middle_1PgResource.execute(selectArgs);
      },
      args: {
        arg0: undefined,
        b: undefined,
        c: undefined
      }
    },
    optionalMissingMiddle2: {
      plan($root, args, _info) {
        const selectArgs = makeArgs22(args);
        return resource_optional_missing_middle_2PgResource.execute(selectArgs);
      },
      args: {
        a: undefined,
        b: undefined,
        c: undefined
      }
    },
    optionalMissingMiddle3: {
      plan($root, args, _info) {
        const selectArgs = makeArgs23(args);
        return resource_optional_missing_middle_3PgResource.execute(selectArgs);
      },
      args: {
        a: undefined,
        arg1: undefined,
        c: undefined
      }
    },
    optionalMissingMiddle4: {
      plan($root, args, _info) {
        const selectArgs = makeArgs24(args);
        return resource_optional_missing_middle_4PgResource.execute(selectArgs);
      },
      args: {
        arg0: undefined,
        b: undefined,
        arg2: undefined
      }
    },
    optionalMissingMiddle5: {
      plan($root, args, _info) {
        const selectArgs = makeArgs25(args);
        return resource_optional_missing_middle_5PgResource.execute(selectArgs);
      },
      args: {
        a: undefined,
        arg1: undefined,
        arg2: undefined
      }
    },
    cFuncOutUnnamedOutOutUnnamed($root, args, _info) {
      const selectArgs = makeArgs26(args);
      return resource_c_func_out_unnamed_out_out_unnamedPgResource.execute(selectArgs);
    },
    cFuncReturnsTableMultiCol: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs7($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        i: undefined,
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncReturnsTableMultiCol_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncReturnsTableMultiCol_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncReturnsTableMultiCol_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncReturnsTableMultiCol_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncReturnsTableMultiCol_after_applyPlan
        }
      }
    },
    cIntSetQuery: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs8($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        x: undefined,
        y: undefined,
        z: undefined,
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cIntSetQuery_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cIntSetQuery_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cIntSetQuery_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cIntSetQuery_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cIntSetQuery_after_applyPlan
        }
      }
    },
    queryIntervalArray($root, args, _info) {
      const selectArgs = makeArgs29(args);
      return resource_query_interval_arrayPgResource.execute(selectArgs);
    },
    queryTextArray($root, args, _info) {
      const selectArgs = makeArgs30(args);
      return resource_query_text_arrayPgResource.execute(selectArgs);
    },
    cReturnTableWithoutGrants($root, args, _info) {
      const selectArgs = makeArgs31(args);
      return resource_c_return_table_without_grantsPgResource.execute(selectArgs);
    },
    cTypesQuery: {
      plan($root, args, _info) {
        const selectArgs = makeArgs32(args);
        return resource_c_types_queryPgResource.execute(selectArgs);
      },
      args: {
        a: undefined,
        b: undefined,
        c: undefined,
        d: undefined,
        e: undefined,
        f: undefined
      }
    },
    cCompoundTypeComputedField: {
      plan($root, args, _info) {
        const selectArgs = makeArgs33(args);
        return resource_c_compound_type_computed_fieldPgResource.execute(selectArgs);
      },
      args: {
        compoundType: undefined
      }
    },
    cFuncOutOutCompoundType: {
      plan($root, args, _info) {
        const selectArgs = makeArgs34(args);
        return resource_c_func_out_out_compound_typePgResource.execute(selectArgs);
      },
      args: {
        i1: undefined
      }
    },
    cQueryOutputTwoRows: {
      plan($root, args, _info) {
        const selectArgs = makeArgs35(args);
        return resource_c_query_output_two_rowsPgResource.execute(selectArgs);
      },
      args: {
        leftArmId: undefined,
        postId: undefined,
        txt: undefined
      }
    },
    cCompoundTypeSetQuery: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs9($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cCompoundTypeSetQuery_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cCompoundTypeSetQuery_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cCompoundTypeSetQuery_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cCompoundTypeSetQuery_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cCompoundTypeSetQuery_after_applyPlan
        }
      }
    },
    bCompoundTypeQuery: {
      plan($root, args, _info) {
        const selectArgs = makeArgs37(args);
        return resource_b_compound_type_queryPgResource.execute(selectArgs);
      },
      args: {
        object: undefined
      }
    },
    cTableQuery: {
      plan($root, args, _info) {
        const selectArgs = makeArgs38(args);
        return resource_c_table_queryPgResource.execute(selectArgs);
      },
      args: {
        id: undefined
      }
    },
    queryCompoundTypeArray: {
      plan($root, args, _info) {
        const selectArgs = makeArgs39(args);
        return resource_query_compound_type_arrayPgResource.execute(selectArgs);
      },
      args: {
        object: undefined
      }
    },
    bCompoundTypeArrayQuery: {
      plan($root, args, _info) {
        const selectArgs = makeArgs40(args);
        return resource_b_compound_type_array_queryPgResource.execute(selectArgs);
      },
      args: {
        object: undefined
      }
    },
    cFuncOutComplex: {
      plan($root, args, _info) {
        const selectArgs = makeArgs41(args);
        return resource_c_func_out_complexPgResource.execute(selectArgs);
      },
      args: {
        a: undefined,
        b: undefined
      }
    },
    cFuncOutComplexSetof: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs10($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        a: undefined,
        b: undefined,
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutComplexSetof_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutComplexSetof_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutComplexSetof_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutComplexSetof_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutComplexSetof_after_applyPlan
        }
      }
    },
    cBadlyBehavedFunction: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs11($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cBadlyBehavedFunction_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cBadlyBehavedFunction_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cBadlyBehavedFunction_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cBadlyBehavedFunction_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cBadlyBehavedFunction_after_applyPlan
        }
      }
    },
    cFuncOutTable($root, args, _info) {
      const selectArgs = makeArgs44(args);
      return resource_c_func_out_tablePgResource.execute(selectArgs);
    },
    cFuncOutTableSetof: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs12($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutTableSetof_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutTableSetof_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutTableSetof_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutTableSetof_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cFuncOutTableSetof_after_applyPlan
        }
      }
    },
    cTableSetQuery: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs13($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cTableSetQuery_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cTableSetQuery_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cTableSetQuery_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cTableSetQuery_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cTableSetQuery_after_applyPlan
        }
      }
    },
    cTableSetQueryPlpgsql: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs14($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cTableSetQueryPlpgsql_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cTableSetQueryPlpgsql_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cTableSetQueryPlpgsql_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cTableSetQueryPlpgsql_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_cTableSetQueryPlpgsql_after_applyPlan
        }
      }
    },
    bTypeFunctionConnection: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs15($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_bTypeFunctionConnection_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_bTypeFunctionConnection_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_bTypeFunctionConnection_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_bTypeFunctionConnection_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_bTypeFunctionConnection_after_applyPlan
        }
      }
    },
    bTypeFunction: {
      plan($root, args, _info) {
        const selectArgs = makeArgs49(args);
        return resource_b_type_functionPgResource.execute(selectArgs);
      },
      args: {
        id: undefined
      }
    },
    bTypeFunctionList($root, args, _info) {
      const selectArgs = makeArgs50(args);
      return resource_b_type_function_listPgResource.execute(selectArgs);
    },
    allNonUpdatableViews: {
      plan() {
        return connection(resource_non_updatable_viewPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNonUpdatableViews_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNonUpdatableViews_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNonUpdatableViews_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNonUpdatableViews_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNonUpdatableViews_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("NonUpdatableViewOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allInputs: {
      plan() {
        return connection(resource_inputsPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allInputs_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allInputs_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allInputs_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allInputs_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allInputs_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("InputOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allPatches: {
      plan() {
        return connection(resource_patchsPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPatches_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPatches_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPatches_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPatches_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPatches_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("PatchOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allReserveds: {
      plan() {
        return connection(resource_reservedPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReserveds_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReserveds_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReserveds_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReserveds_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReserveds_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ReservedOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allReservedPatchRecords: {
      plan() {
        return connection(resource_reservedPatchsPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedPatchRecords_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedPatchRecords_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedPatchRecords_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedPatchRecords_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedPatchRecords_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ReservedPatchRecordOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allReservedInputRecords: {
      plan() {
        return connection(resource_reserved_inputPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedInputRecords_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedInputRecords_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedInputRecords_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedInputRecords_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedInputRecords_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ReservedInputRecordOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allDefaultValues: {
      plan() {
        return connection(resource_default_valuePgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allDefaultValues_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allDefaultValues_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allDefaultValues_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allDefaultValues_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allDefaultValues_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("DefaultValueOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allForeignKeys: {
      plan() {
        return connection(resource_foreign_keyPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allForeignKeys_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allForeignKeys_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allForeignKeys_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allForeignKeys_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allForeignKeys_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ForeignKeyOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allNoPrimaryKeys: {
      plan() {
        return connection(resource_no_primary_keyPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNoPrimaryKeys_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNoPrimaryKeys_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNoPrimaryKeys_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNoPrimaryKeys_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNoPrimaryKeys_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("NoPrimaryKeyOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allTestviews: {
      plan() {
        return connection(resource_testviewPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allTestviews_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allTestviews_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allTestviews_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allTestviews_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allTestviews_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("TestviewOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allUniqueForeignKeys: {
      plan() {
        return connection(resource_unique_foreign_keyPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allUniqueForeignKeys_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allUniqueForeignKeys_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allUniqueForeignKeys_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allUniqueForeignKeys_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allUniqueForeignKeys_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("UniqueForeignKeyOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allCMyTables: {
      plan() {
        return connection(resource_c_my_tablePgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCMyTables_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCMyTables_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCMyTables_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCMyTables_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCMyTables_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("CMyTableOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allCPersonSecrets: {
      plan() {
        return connection(resource_c_person_secretPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCPersonSecrets_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCPersonSecrets_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCPersonSecrets_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCPersonSecrets_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCPersonSecrets_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("CPersonSecretOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allViewTables: {
      plan() {
        return connection(resource_view_tablePgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allViewTables_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allViewTables_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allViewTables_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allViewTables_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allViewTables_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ViewTableOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allBUpdatableViews: {
      plan() {
        return connection(resource_b_updatable_viewPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allBUpdatableViews_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allBUpdatableViews_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allBUpdatableViews_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allBUpdatableViews_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allBUpdatableViews_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("BUpdatableViewOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allCCompoundKeys: {
      plan() {
        return connection(resource_c_compound_keyPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCCompoundKeys_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCCompoundKeys_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCCompoundKeys_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCCompoundKeys_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCCompoundKeys_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("CCompoundKeyOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allSimilarTable1S: {
      plan() {
        return connection(resource_similar_table_1PgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable1S_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable1S_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable1S_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable1S_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable1S_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SimilarTable1OrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allSimilarTable2S: {
      plan() {
        return connection(resource_similar_table_2PgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable2S_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable2S_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable2S_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable2S_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable2S_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SimilarTable2OrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allCNullTestRecords: {
      plan() {
        return connection(resource_c_null_test_recordPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCNullTestRecords_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCNullTestRecords_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCNullTestRecords_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCNullTestRecords_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCNullTestRecords_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("CNullTestRecordOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allCEdgeCases: {
      plan() {
        return connection(resource_c_edge_casePgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCEdgeCases_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCEdgeCases_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCEdgeCases_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCEdgeCases_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCEdgeCases_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("CEdgeCaseOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allCLeftArms: {
      plan() {
        return connection(resource_c_left_armPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCLeftArms_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCLeftArms_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCLeftArms_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCLeftArms_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCLeftArms_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("CLeftArmOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allCIssue756S: {
      plan() {
        return connection(resource_c_issue756PgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCIssue756S_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCIssue756S_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCIssue756S_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCIssue756S_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCIssue756S_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("CIssue756OrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allPosts: {
      plan() {
        return connection(resource_postPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPosts_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPosts_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPosts_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPosts_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPosts_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("PostOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allCPeople: {
      plan() {
        return connection(resource_c_personPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCPeople_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCPeople_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCPeople_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCPeople_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCPeople_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("CPersonOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allBTypes: {
      plan() {
        return connection(resource_b_typesPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allBTypes_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allBTypes_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allBTypes_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allBTypes_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allBTypes_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("BTypeOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    }
  },
  Input: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    }
  },
  Patch: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    }
  },
  Reserved: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    }
  },
  ReservedPatchRecord: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    }
  },
  ReservedInputRecord: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    }
  },
  DefaultValue: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    nullValue($record) {
      return $record.get("null_value");
    }
  },
  NoPrimaryKey: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    str($record) {
      return $record.get("str");
    }
  },
  UniqueForeignKey: {
    __assertStep: assertPgClassSingleStep,
    compoundKey1($record) {
      return $record.get("compound_key_1");
    },
    compoundKey2($record) {
      return $record.get("compound_key_2");
    },
    cCompoundKeyByCompoundKey1AndCompoundKey2($record) {
      return resource_c_compound_keyPgResource.get({
        person_id_1: $record.get("compound_key_1"),
        person_id_2: $record.get("compound_key_2")
      });
    }
  },
  CCompoundKey: {
    __assertStep: assertPgClassSingleStep,
    personId2($record) {
      return $record.get("person_id_2");
    },
    personId1($record) {
      return $record.get("person_id_1");
    },
    extra($record) {
      return $record.get("extra");
    },
    cPersonByPersonId1($record) {
      return resource_c_personPgResource.get({
        id: $record.get("person_id_1")
      });
    },
    cPersonByPersonId2($record) {
      return resource_c_personPgResource.get({
        id: $record.get("person_id_2")
      });
    },
    foreignKeysByCompoundKey1AndCompoundKey2: {
      plan($record) {
        const $records = resource_foreign_keyPgResource.find({
          compound_key_1: $record.get("person_id_1"),
          compound_key_2: $record.get("person_id_2")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: CCompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: CCompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: CCompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: CCompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: CCompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ForeignKeyOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    uniqueForeignKeyByCompoundKey1AndCompoundKey2($record) {
      return resource_unique_foreign_keyPgResource.get({
        compound_key_1: $record.get("person_id_1"),
        compound_key_2: $record.get("person_id_2")
      });
    }
  },
  CPerson: {
    __assertStep: assertPgClassSingleStep,
    computedOut($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs51(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_c_person_computed_outPgResource.isUnique && !resource_c_person_computed_outPgResource.codec.attributes && typeof resource_c_person_computed_outPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_c_person_computed_outPgResource.codec)`${resource_c_person_computed_outPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_c_person_computed_outPgResource.execute(selectArgs);
    },
    firstName($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs52(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_c_person_first_namePgResource.isUnique && !resource_c_person_first_namePgResource.codec.attributes && typeof resource_c_person_first_namePgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_c_person_first_namePgResource.codec)`${resource_c_person_first_namePgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_c_person_first_namePgResource.execute(selectArgs);
    },
    computedOutOut($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs53(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_c_person_computed_out_outPgResource.isUnique && !resource_c_person_computed_out_outPgResource.codec.attributes && typeof resource_c_person_computed_out_outPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_c_person_computed_out_outPgResource.codec)`${resource_c_person_computed_out_outPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_c_person_computed_out_outPgResource.execute(selectArgs);
    },
    computedInout: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs54(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_c_person_computed_inoutPgResource.isUnique && !resource_c_person_computed_inoutPgResource.codec.attributes && typeof resource_c_person_computed_inoutPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_c_person_computed_inoutPgResource.codec)`${resource_c_person_computed_inoutPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_c_person_computed_inoutPgResource.execute(selectArgs);
      },
      args: {
        ino: undefined
      }
    },
    computedInoutOut: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs55(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_c_person_computed_inout_outPgResource.isUnique && !resource_c_person_computed_inout_outPgResource.codec.attributes && typeof resource_c_person_computed_inout_outPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_c_person_computed_inout_outPgResource.codec)`${resource_c_person_computed_inout_outPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_c_person_computed_inout_outPgResource.execute(selectArgs);
      },
      args: {
        ino: undefined
      }
    },
    exists: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs56(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_c_person_existsPgResource.isUnique && !resource_c_person_existsPgResource.codec.attributes && typeof resource_c_person_existsPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_c_person_existsPgResource.codec)`${resource_c_person_existsPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_c_person_existsPgResource.execute(selectArgs);
      },
      args: {
        email: undefined
      }
    },
    computedFirstArgInoutOut($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs57(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_c_person_computed_first_arg_inout_outPgResource.isUnique && !resource_c_person_computed_first_arg_inout_outPgResource.codec.attributes && typeof resource_c_person_computed_first_arg_inout_outPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_c_person_computed_first_arg_inout_outPgResource.codec)`${resource_c_person_computed_first_arg_inout_outPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_c_person_computed_first_arg_inout_outPgResource.execute(selectArgs);
    },
    computedComplex: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs58(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_c_person_computed_complexPgResource.isUnique && !resource_c_person_computed_complexPgResource.codec.attributes && typeof resource_c_person_computed_complexPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_c_person_computed_complexPgResource.codec)`${resource_c_person_computed_complexPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_c_person_computed_complexPgResource.execute(selectArgs);
      },
      args: {
        a: undefined,
        b: undefined
      }
    },
    firstPost($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs59(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_c_person_first_postPgResource.isUnique && !resource_c_person_first_postPgResource.codec.attributes && typeof resource_c_person_first_postPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_c_person_first_postPgResource.codec)`${resource_c_person_first_postPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_c_person_first_postPgResource.execute(selectArgs);
    },
    computedFirstArgInout($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs60(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_c_person_computed_first_arg_inoutPgResource.isUnique && !resource_c_person_computed_first_arg_inoutPgResource.codec.attributes && typeof resource_c_person_computed_first_arg_inoutPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_c_person_computed_first_arg_inoutPgResource.codec)`${resource_c_person_computed_first_arg_inoutPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_c_person_computed_first_arg_inoutPgResource.execute(selectArgs);
    },
    friends: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs16($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_friends_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_friends_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_friends_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_friends_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_friends_after_applyPlan
        }
      }
    },
    typeFunctionConnection: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs17($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_typeFunctionConnection_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_typeFunctionConnection_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_typeFunctionConnection_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_typeFunctionConnection_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_typeFunctionConnection_after_applyPlan
        }
      }
    },
    typeFunction: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs63(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_c_person_type_functionPgResource.isUnique && !resource_c_person_type_functionPgResource.codec.attributes && typeof resource_c_person_type_functionPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_c_person_type_functionPgResource.codec)`${resource_c_person_type_functionPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_c_person_type_functionPgResource.execute(selectArgs);
      },
      args: {
        id: undefined
      }
    },
    typeFunctionList($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs64(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_c_person_type_function_listPgResource.isUnique && !resource_c_person_type_function_listPgResource.codec.attributes && typeof resource_c_person_type_function_listPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_c_person_type_function_listPgResource.codec)`${resource_c_person_type_function_listPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_c_person_type_function_listPgResource.execute(selectArgs);
    },
    rowId($record) {
      return $record.get("id");
    },
    name($record) {
      return $record.get("person_full_name");
    },
    aliases($record) {
      return $record.get("aliases");
    },
    about($record) {
      return $record.get("about");
    },
    email($record) {
      return $record.get("email");
    },
    site($record) {
      const $plan = $record.get("site");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_bWrappedUrlPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    config($record) {
      return $record.get("config");
    },
    lastLoginFromIp($record) {
      return $record.get("last_login_from_ip");
    },
    lastLoginFromSubnet($record) {
      return $record.get("last_login_from_subnet");
    },
    userMac($record) {
      return $record.get("user_mac");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    postsByAuthorId: {
      plan($record) {
        const $records = resource_postPgResource.find({
          author_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_postsByAuthorId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_postsByAuthorId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_postsByAuthorId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_postsByAuthorId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_postsByAuthorId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("PostOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    foreignKeysByPersonId: {
      plan($record) {
        const $records = resource_foreign_keyPgResource.find({
          person_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_foreignKeysByPersonId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_foreignKeysByPersonId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_foreignKeysByPersonId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_foreignKeysByPersonId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_foreignKeysByPersonId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ForeignKeyOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    cPersonSecretByPersonId($record) {
      return resource_c_person_secretPgResource.get({
        person_id: $record.get("id")
      });
    },
    cLeftArmByPersonId($record) {
      return resource_c_left_armPgResource.get({
        person_id: $record.get("id")
      });
    },
    cCompoundKeysByPersonId1: {
      plan($record) {
        const $records = resource_c_compound_keyPgResource.find({
          person_id_1: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_cCompoundKeysByPersonId1_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_cCompoundKeysByPersonId1_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_cCompoundKeysByPersonId1_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_cCompoundKeysByPersonId1_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_cCompoundKeysByPersonId1_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("CCompoundKeyOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    cCompoundKeysByPersonId2: {
      plan($record) {
        const $records = resource_c_compound_keyPgResource.find({
          person_id_2: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_cCompoundKeysByPersonId2_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_cCompoundKeysByPersonId2_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_cCompoundKeysByPersonId2_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_cCompoundKeysByPersonId2_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: CPerson_cCompoundKeysByPersonId2_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("CCompoundKeyOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    }
  },
  CPersonComputedOutOutRecord: {
    __assertStep: assertPgClassSingleStep,
    o1($record) {
      return $record.get("o1");
    },
    o2($record) {
      return $record.get("o2");
    }
  },
  CPersonComputedInoutOutRecord: {
    __assertStep: assertPgClassSingleStep,
    ino($record) {
      return $record.get("ino");
    },
    o($record) {
      return $record.get("o");
    }
  },
  CPersonComputedFirstArgInoutOutRecord: {
    __assertStep: assertPgClassSingleStep,
    person($record) {
      const $plan = $record.get("person");
      const $select = pgSelectSingleFromRecord(resource_c_personPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    o($record) {
      return $record.get("o");
    }
  },
  CPersonComputedComplexRecord: {
    __assertStep: assertPgClassSingleStep,
    x($record) {
      return $record.get("x");
    },
    y($record) {
      const $plan = $record.get("y");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_cCompoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    z($record) {
      const $plan = $record.get("z");
      const $select = pgSelectSingleFromRecord(resource_c_personPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    }
  },
  CCompoundType: {
    __assertStep: assertPgClassSingleStep,
    computedField($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs65(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_c_compound_type_computed_fieldPgResource.isUnique && !resource_c_compound_type_computed_fieldPgResource.codec.attributes && typeof resource_c_compound_type_computed_fieldPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_c_compound_type_computed_fieldPgResource.codec)`${resource_c_compound_type_computed_fieldPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_c_compound_type_computed_fieldPgResource.execute(selectArgs);
    },
    query($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs66(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_b_compound_type_queryPgResource.isUnique && !resource_b_compound_type_queryPgResource.codec.attributes && typeof resource_b_compound_type_queryPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_b_compound_type_queryPgResource.codec)`${resource_b_compound_type_queryPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_b_compound_type_queryPgResource.execute(selectArgs);
    },
    queryCompoundTypeArray($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs67(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_query_compound_type_arrayPgResource.isUnique && !resource_query_compound_type_arrayPgResource.codec.attributes && typeof resource_query_compound_type_arrayPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_query_compound_type_arrayPgResource.codec)`${resource_query_compound_type_arrayPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_query_compound_type_arrayPgResource.execute(selectArgs);
    },
    arrayQuery($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs68(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_b_compound_type_array_queryPgResource.isUnique && !resource_b_compound_type_array_queryPgResource.codec.attributes && typeof resource_b_compound_type_array_queryPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_b_compound_type_array_queryPgResource.codec)`${resource_b_compound_type_array_queryPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_b_compound_type_array_queryPgResource.execute(selectArgs);
    },
    a($record) {
      return $record.get("a");
    },
    b($record) {
      return $record.get("b");
    },
    c($record) {
      return $record.get("c");
    },
    d($record) {
      return $record.get("d");
    },
    e($record) {
      return $record.get("e");
    },
    f($record) {
      return $record.get("f");
    },
    g($record) {
      return $record.get("g");
    },
    fooBar($record) {
      return $record.get("foo_bar");
    }
  },
  BEnumCaps: {
    _0_BAR: {
      value: "0_BAR"
    }
  },
  BEnumWithEmptyString: {
    _EMPTY_: {
      value: ""
    }
  },
  Interval: {
    __assertStep: assertExecutableStep,
    seconds: Interval_secondsPlan,
    minutes: Interval_minutesPlan,
    hours: Interval_hoursPlan,
    days: Interval_daysPlan,
    months: Interval_monthsPlan,
    years: Interval_yearsPlan
  },
  Post: {
    __assertStep: assertPgClassSingleStep,
    computedIntervalSet: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs18($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_computedIntervalSet_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_computedIntervalSet_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_computedIntervalSet_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_computedIntervalSet_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_computedIntervalSet_after_applyPlan
        }
      }
    },
    computedIntervalArray($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs70(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_post_computed_interval_arrayPgResource.isUnique && !resource_post_computed_interval_arrayPgResource.codec.attributes && typeof resource_post_computed_interval_arrayPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_post_computed_interval_arrayPgResource.codec)`${resource_post_computed_interval_arrayPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_post_computed_interval_arrayPgResource.execute(selectArgs);
    },
    computedTextArray($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs71(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_post_computed_text_arrayPgResource.isUnique && !resource_post_computed_text_arrayPgResource.codec.attributes && typeof resource_post_computed_text_arrayPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_post_computed_text_arrayPgResource.codec)`${resource_post_computed_text_arrayPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_post_computed_text_arrayPgResource.execute(selectArgs);
    },
    computedWithOptionalArg: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs72(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_post_computed_with_optional_argPgResource.isUnique && !resource_post_computed_with_optional_argPgResource.codec.attributes && typeof resource_post_computed_with_optional_argPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_post_computed_with_optional_argPgResource.codec)`${resource_post_computed_with_optional_argPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_post_computed_with_optional_argPgResource.execute(selectArgs);
      },
      args: {
        i: undefined
      }
    },
    computedWithRequiredArg: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs73(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_post_computed_with_required_argPgResource.isUnique && !resource_post_computed_with_required_argPgResource.codec.attributes && typeof resource_post_computed_with_required_argPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_post_computed_with_required_argPgResource.codec)`${resource_post_computed_with_required_argPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_post_computed_with_required_argPgResource.execute(selectArgs);
      },
      args: {
        i: undefined
      }
    },
    headlineTrimmed: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs74(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_post_headline_trimmedPgResource.isUnique && !resource_post_headline_trimmedPgResource.codec.attributes && typeof resource_post_headline_trimmedPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_post_headline_trimmedPgResource.codec)`${resource_post_headline_trimmedPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_post_headline_trimmedPgResource.execute(selectArgs);
      },
      args: {
        length: undefined,
        omission: undefined
      }
    },
    headlineTrimmedNoDefaults: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs75(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_post_headline_trimmed_no_defaultsPgResource.isUnique && !resource_post_headline_trimmed_no_defaultsPgResource.codec.attributes && typeof resource_post_headline_trimmed_no_defaultsPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_post_headline_trimmed_no_defaultsPgResource.codec)`${resource_post_headline_trimmed_no_defaultsPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_post_headline_trimmed_no_defaultsPgResource.execute(selectArgs);
      },
      args: {
        length: undefined,
        omission: undefined
      }
    },
    headlineTrimmedStrict: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs76(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_post_headline_trimmed_strictPgResource.isUnique && !resource_post_headline_trimmed_strictPgResource.codec.attributes && typeof resource_post_headline_trimmed_strictPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_post_headline_trimmed_strictPgResource.codec)`${resource_post_headline_trimmed_strictPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_post_headline_trimmed_strictPgResource.execute(selectArgs);
      },
      args: {
        length: undefined,
        omission: undefined
      }
    },
    computedCompoundTypeArray: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs77(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_post_computed_compound_type_arrayPgResource.isUnique && !resource_post_computed_compound_type_arrayPgResource.codec.attributes && typeof resource_post_computed_compound_type_arrayPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_post_computed_compound_type_arrayPgResource.codec)`${resource_post_computed_compound_type_arrayPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_post_computed_compound_type_arrayPgResource.execute(selectArgs);
      },
      args: {
        object: undefined
      }
    },
    rowId($record) {
      return $record.get("id");
    },
    headline($record) {
      return $record.get("headline");
    },
    body($record) {
      return $record.get("body");
    },
    authorId($record) {
      return $record.get("author_id");
    },
    enums($record) {
      return $record.get("enums");
    },
    comptypes($record) {
      const $val = $record.get("comptypes");
      const $select = pgSelectFromRecords(resource_frmcdc_comptypePgResource, $val);
      $select.setTrusted();
      return $select;
    },
    cPersonByAuthorId($record) {
      return resource_c_personPgResource.get({
        id: $record.get("author_id")
      });
    },
    bTypesBySmallint: {
      plan($record) {
        const $records = resource_b_typesPgResource.find({
          smallint: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_bTypesBySmallint_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_bTypesBySmallint_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_bTypesBySmallint_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_bTypesBySmallint_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_bTypesBySmallint_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("BTypeOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    bTypeByRowId($record) {
      return resource_b_typesPgResource.get({
        id: $record.get("id")
      });
    }
  },
  PostComputedIntervalSetConnection: {
    __assertStep: ConnectionStep,
    nodes: PostComputedIntervalSetConnection_nodesPlan,
    edges: PostComputedIntervalSetConnection_edgesPlan,
    pageInfo: PostComputedIntervalSetConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  PostComputedIntervalSetEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  PageInfo: {
    __assertStep: assertPageInfoCapableStep,
    hasNextPage: PageInfo_hasNextPagePlan,
    hasPreviousPage: PageInfo_hasPreviousPagePlan,
    startCursor($pageInfo) {
      return $pageInfo.startCursor();
    },
    endCursor($pageInfo) {
      return $pageInfo.endCursor();
    }
  },
  CCompoundTypeInput: {
    a: {
      applyPlan($insert, val) {
        $insert.set("a", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    b: {
      applyPlan($insert, val) {
        $insert.set("b", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    c: {
      applyPlan($insert, val) {
        $insert.set("c", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    d: {
      applyPlan($insert, val) {
        $insert.set("d", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    e: {
      applyPlan($insert, val) {
        $insert.set("e", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    f: {
      applyPlan($insert, val) {
        $insert.set("f", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    g: {
      applyPlan($insert, val) {
        $insert.set("g", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    fooBar: {
      applyPlan($insert, val) {
        $insert.set("foo_bar", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  IntervalInput: {
    seconds: undefined,
    minutes: undefined,
    hours: undefined,
    days: undefined,
    months: undefined,
    years: undefined
  },
  AnEnum: {
    ASTERISK: {
      value: "*"
    },
    ASTERISK__ASTERISK: {
      value: "**"
    },
    ASTERISK__ASTERISK__ASTERISK: {
      value: "***"
    },
    foo_ASTERISK: {
      value: "foo*"
    },
    foo_ASTERISK_: {
      value: "foo*_"
    },
    _foo_ASTERISK: {
      value: "_foo*"
    },
    ASTERISK_bar: {
      value: "*bar"
    },
    ASTERISK_bar_: {
      value: "*bar_"
    },
    _ASTERISK_bar_: {
      value: "_*bar_"
    },
    ASTERISK_baz_ASTERISK: {
      value: "*baz*"
    },
    _ASTERISK_baz_ASTERISK_: {
      value: "_*baz*_"
    },
    PERCENT: {
      value: "%"
    },
    GREATER_THAN_OR_EQUAL: {
      value: ">="
    },
    LIKE: {
      value: "~~"
    },
    DOLLAR: {
      value: "$"
    }
  },
  Comptype: {
    __assertStep: assertPgClassSingleStep,
    schedule($record) {
      return $record.get("schedule");
    },
    isOptimised($record) {
      return $record.get("is_optimised");
    }
  },
  BTypeConnection: {
    __assertStep: ConnectionStep,
    nodes: BTypeConnection_nodesPlan,
    edges: BTypeConnection_edgesPlan,
    pageInfo: BTypeConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  BType: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    smallint($record) {
      return $record.get("smallint");
    },
    bigint($record) {
      return $record.get("bigint");
    },
    numeric($record) {
      return $record.get("numeric");
    },
    decimal($record) {
      return $record.get("decimal");
    },
    boolean($record) {
      return $record.get("boolean");
    },
    varchar($record) {
      return $record.get("varchar");
    },
    enum($record) {
      return $record.get("enum");
    },
    enumArray($record) {
      return $record.get("enum_array");
    },
    domain($record) {
      return $record.get("domain");
    },
    domain2($record) {
      return $record.get("domain2");
    },
    textArray($record) {
      return $record.get("text_array");
    },
    json($record) {
      return $record.get("json");
    },
    jsonb($record) {
      return $record.get("jsonb");
    },
    nullableRange($record) {
      return $record.get("nullable_range");
    },
    numrange($record) {
      return $record.get("numrange");
    },
    daterange($record) {
      return $record.get("daterange");
    },
    anIntRange($record) {
      return $record.get("an_int_range");
    },
    timestamp($record) {
      return $record.get("timestamp");
    },
    timestamptz($record) {
      return $record.get("timestamptz");
    },
    date($record) {
      return $record.get("date");
    },
    time($record) {
      return $record.get("time");
    },
    timetz($record) {
      return $record.get("timetz");
    },
    interval($record) {
      return $record.get("interval");
    },
    intervalArray($record) {
      return $record.get("interval_array");
    },
    money($record) {
      return $record.get("money");
    },
    compoundType($record) {
      const $plan = $record.get("compound_type");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_cCompoundTypePgResource, $plan);
      if (true) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    nestedCompoundType($record) {
      const $plan = $record.get("nested_compound_type");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_bNestedCompoundTypePgResource, $plan);
      if (true) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    nullableCompoundType($record) {
      const $plan = $record.get("nullable_compound_type");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_cCompoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    nullableNestedCompoundType($record) {
      const $plan = $record.get("nullable_nested_compound_type");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_bNestedCompoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    point($record) {
      return $record.get("point");
    },
    nullablePoint($record) {
      return $record.get("nullablePoint");
    },
    inet($record) {
      return $record.get("inet");
    },
    cidr($record) {
      return $record.get("cidr");
    },
    macaddr($record) {
      return $record.get("macaddr");
    },
    regproc($record) {
      return $record.get("regproc");
    },
    regprocedure($record) {
      return $record.get("regprocedure");
    },
    regoper($record) {
      return $record.get("regoper");
    },
    regoperator($record) {
      return $record.get("regoperator");
    },
    regclass($record) {
      return $record.get("regclass");
    },
    regtype($record) {
      return $record.get("regtype");
    },
    regconfig($record) {
      return $record.get("regconfig");
    },
    regdictionary($record) {
      return $record.get("regdictionary");
    },
    textArrayDomain($record) {
      return $record.get("text_array_domain");
    },
    int8ArrayDomain($record) {
      return $record.get("int8_array_domain");
    },
    bytea($record) {
      return $record.get("bytea");
    },
    byteaArray($record) {
      return $record.get("bytea_array");
    },
    ltree($record) {
      return $record.get("ltree");
    },
    ltreeArray($record) {
      return $record.get("ltree_array");
    },
    postBySmallint($record) {
      return resource_postPgResource.get({
        id: $record.get("smallint")
      });
    },
    postByRowId($record) {
      return resource_postPgResource.get({
        id: $record.get("id")
      });
    }
  },
  BigFloatRange: {},
  BigFloatRangeBound: {},
  DateRange: {},
  DateRangeBound: {},
  AnIntRange: {},
  AnIntRangeBound: {},
  BNestedCompoundType: {
    __assertStep: assertPgClassSingleStep,
    a($record) {
      const $plan = $record.get("a");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_cCompoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    b($record) {
      const $plan = $record.get("b");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_cCompoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    bazBuz($record) {
      return $record.get("baz_buz");
    }
  },
  Point: {},
  BTypeEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  BTypeOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques28[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_bTypes_bTypes.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques28[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_bTypes_bTypes.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    SMALLINT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "smallint",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    SMALLINT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "smallint",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    BIGINT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "bigint",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    BIGINT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "bigint",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NUMERIC_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "numeric",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NUMERIC_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "numeric",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DECIMAL_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "decimal",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DECIMAL_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "decimal",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    BOOLEAN_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "boolean",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    BOOLEAN_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "boolean",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    VARCHAR_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "varchar",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    VARCHAR_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "varchar",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ENUM_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "enum",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ENUM_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "enum",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DOMAIN_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "domain",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DOMAIN_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "domain",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DOMAIN2_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "domain2",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DOMAIN2_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "domain2",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    JSON_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "json",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    JSON_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "json",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    JSONB_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "jsonb",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    JSONB_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "jsonb",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TIMESTAMP_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "timestamp",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TIMESTAMP_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "timestamp",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TIMESTAMPTZ_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "timestamptz",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TIMESTAMPTZ_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "timestamptz",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DATE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "date",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DATE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "date",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TIME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "time",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TIME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "time",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TIMETZ_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "timetz",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TIMETZ_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "timetz",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    INTERVAL_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "interval",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    INTERVAL_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "interval",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    MONEY_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "money",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    MONEY_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "money",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POINT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "point",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POINT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "point",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULLABLE_POINT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nullablePoint",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULLABLE_POINT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nullablePoint",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    INET_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "inet",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    INET_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "inet",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CIDR_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "cidr",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CIDR_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "cidr",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    MACADDR_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "macaddr",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    MACADDR_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "macaddr",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGPROC_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regproc",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGPROC_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regproc",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGPROCEDURE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regprocedure",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGPROCEDURE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regprocedure",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGOPER_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regoper",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGOPER_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regoper",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGOPERATOR_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regoperator",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGOPERATOR_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regoperator",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGCLASS_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regclass",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGCLASS_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regclass",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGTYPE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regtype",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGTYPE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regtype",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGCONFIG_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regconfig",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGCONFIG_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regconfig",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGDICTIONARY_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regdictionary",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGDICTIONARY_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regdictionary",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LTREE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "ltree",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LTREE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "ltree",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  BTypeCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    smallint: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "smallint",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "smallint",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.smallint.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    bigint: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "bigint",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "bigint",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.bigint.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    numeric: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "numeric",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "numeric",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.numeric.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    decimal: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "decimal",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "decimal",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.decimal.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    boolean: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "boolean",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "boolean",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.boolean.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    varchar: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "varchar",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "varchar",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.varchar.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    enum: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "enum",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "enum",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.enum.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    domain: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "domain",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "domain",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.domain.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    domain2: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "domain2",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "domain2",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.domain2.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    json: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "json",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "json",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.json.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    jsonb: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "jsonb",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "jsonb",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.jsonb.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timestamp: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "timestamp",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "timestamp",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.timestamp.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timestamptz: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "timestamptz",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "timestamptz",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.timestamptz.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    date: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "date",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "date",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.date.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    time: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "time",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "time",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.time.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timetz: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "timetz",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "timetz",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.timetz.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    interval: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "interval",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "interval",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.interval.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    money: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "money",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "money",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.money.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    point: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "point",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "point",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.point.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullablePoint: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "nullablePoint",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "nullablePoint",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.nullablePoint.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    inet: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "inet",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "inet",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.inet.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    cidr: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "cidr",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "cidr",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.cidr.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    macaddr: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "macaddr",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "macaddr",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.macaddr.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regproc: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "regproc",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "regproc",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.regproc.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regprocedure: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "regprocedure",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "regprocedure",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.regprocedure.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regoper: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "regoper",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "regoper",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.regoper.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regoperator: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "regoperator",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "regoperator",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.regoperator.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regclass: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "regclass",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "regclass",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.regclass.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regtype: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "regtype",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "regtype",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.regtype.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regconfig: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "regconfig",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "regconfig",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.regconfig.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regdictionary: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "regdictionary",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "regdictionary",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.regdictionary.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    ltree: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "ltree",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "ltree",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.ltree.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  PointInput: {
    x: undefined,
    y: undefined
  },
  CPersonConnection: {
    __assertStep: ConnectionStep,
    nodes: CPersonConnection_nodesPlan,
    edges: CPersonConnection_edgesPlan,
    pageInfo: CPersonConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CPersonEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  BWrappedUrl: {
    __assertStep: assertPgClassSingleStep,
    url($record) {
      return $record.get("url");
    }
  },
  PostConnection: {
    __assertStep: ConnectionStep,
    nodes: PostConnection_nodesPlan,
    edges: PostConnection_edgesPlan,
    pageInfo: PostConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  PostEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  PostOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques25[0].attributes.forEach(attributeName => {
          const attribute = attributes_post_codec_post.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques25[0].attributes.forEach(attributeName => {
          const attribute = attributes_post_codec_post.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    HEADLINE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "headline",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    HEADLINE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "headline",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    BODY_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "body",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    BODY_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "body",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  PostCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes39.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    headline: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "headline",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "headline",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes39.headline.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    body: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "body",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "body",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes39.body.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    authorId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes39.author_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ForeignKeyConnection: {
    __assertStep: ConnectionStep,
    nodes: ForeignKeyConnection_nodesPlan,
    edges: ForeignKeyConnection_edgesPlan,
    pageInfo: ForeignKeyConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  ForeignKey: {
    __assertStep: assertPgClassSingleStep,
    personId($record) {
      return $record.get("person_id");
    },
    compoundKey1($record) {
      return $record.get("compound_key_1");
    },
    compoundKey2($record) {
      return $record.get("compound_key_2");
    },
    cCompoundKeyByCompoundKey1AndCompoundKey2($record) {
      return resource_c_compound_keyPgResource.get({
        person_id_1: $record.get("compound_key_1"),
        person_id_2: $record.get("compound_key_2")
      });
    },
    cPersonByPersonId($record) {
      return resource_c_personPgResource.get({
        id: $record.get("person_id")
      });
    }
  },
  ForeignKeyEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  ForeignKeyOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PERSON_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COMPOUND_KEY_1_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "compound_key_1",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COMPOUND_KEY_1_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "compound_key_1",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COMPOUND_KEY_2_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "compound_key_2",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COMPOUND_KEY_2_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "compound_key_2",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  ForeignKeyCondition: {
    personId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes19.person_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    compoundKey1: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "compound_key_1",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "compound_key_1",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes19.compound_key_1.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    compoundKey2: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "compound_key_2",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "compound_key_2",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes19.compound_key_2.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CPersonSecret: {
    __assertStep: assertPgClassSingleStep,
    personId($record) {
      return $record.get("person_id");
    },
    secret($record) {
      return $record.get("sekrit");
    },
    cPersonByPersonId($record) {
      return resource_c_personPgResource.get({
        id: $record.get("person_id")
      });
    }
  },
  CLeftArm: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    personId($record) {
      return $record.get("person_id");
    },
    lengthInMetres($record) {
      return $record.get("length_in_metres");
    },
    mood($record) {
      return $record.get("mood");
    },
    cPersonByPersonId($record) {
      return resource_c_personPgResource.get({
        id: $record.get("person_id")
      });
    }
  },
  CCompoundKeyConnection: {
    __assertStep: ConnectionStep,
    nodes: CCompoundKeyConnection_nodesPlan,
    edges: CCompoundKeyConnection_edgesPlan,
    pageInfo: CCompoundKeyConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CCompoundKeyEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  CCompoundKeyOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques16[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_cCompoundKey_cCompoundKey.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques16[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_cCompoundKey_cCompoundKey.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PERSON_ID_2_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id_2",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_2_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id_2",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_1_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id_1",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_1_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id_1",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    EXTRA_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "extra",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    EXTRA_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "extra",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  CCompoundKeyCondition: {
    personId2: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "person_id_2",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "person_id_2",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes26.person_id_2.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId1: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "person_id_1",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "person_id_1",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes26.person_id_1.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    extra: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "extra",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "extra",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes26.extra.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CMyTable: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    jsonData($record) {
      return $record.get("json_data");
    }
  },
  ViewTable: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    col1($record) {
      return $record.get("col1");
    },
    col2($record) {
      return $record.get("col2");
    }
  },
  SimilarTable1: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    col1($record) {
      return $record.get("col1");
    },
    col2($record) {
      return $record.get("col2");
    },
    col3($record) {
      return $record.get("col3");
    }
  },
  SimilarTable2: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    col3($record) {
      return $record.get("col3");
    },
    col4($record) {
      return $record.get("col4");
    },
    col5($record) {
      return $record.get("col5");
    }
  },
  CNullTestRecord: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    nullableText($record) {
      return $record.get("nullable_text");
    },
    nullableInt($record) {
      return $record.get("nullable_int");
    },
    nonNullText($record) {
      return $record.get("non_null_text");
    }
  },
  CIssue756: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    ts($record) {
      return $record.get("ts");
    }
  },
  CFuncOutSetofConnection: {
    __assertStep: ConnectionStep,
    nodes: CFuncOutSetofConnection_nodesPlan,
    edges: CFuncOutSetofConnection_edgesPlan,
    pageInfo: CFuncOutSetofConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CFuncOutSetofEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  QueryIntervalSetConnection: {
    __assertStep: ConnectionStep,
    nodes: QueryIntervalSetConnection_nodesPlan,
    edges: QueryIntervalSetConnection_edgesPlan,
    pageInfo: QueryIntervalSetConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  QueryIntervalSetEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  StaticBigIntegerConnection: {
    __assertStep: ConnectionStep,
    nodes: StaticBigIntegerConnection_nodesPlan,
    edges: StaticBigIntegerConnection_edgesPlan,
    pageInfo: StaticBigIntegerConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  StaticBigIntegerEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  CFuncReturnsTableOneColConnection: {
    __assertStep: ConnectionStep,
    nodes: CFuncReturnsTableOneColConnection_nodesPlan,
    edges: CFuncReturnsTableOneColConnection_edgesPlan,
    pageInfo: CFuncReturnsTableOneColConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CFuncReturnsTableOneColEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  CFuncOutOutRecord: {
    __assertStep: assertPgClassSingleStep,
    firstOut($record) {
      return $record.get("first_out");
    },
    secondOut($record) {
      return $record.get("second_out");
    }
  },
  CFuncOutOutSetofConnection: {
    __assertStep: ConnectionStep,
    nodes: CFuncOutOutSetofConnection_nodesPlan,
    edges: CFuncOutOutSetofConnection_edgesPlan,
    pageInfo: CFuncOutOutSetofConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CFuncOutOutSetofRecord: {
    __assertStep: assertPgClassSingleStep,
    o1($record) {
      return $record.get("o1");
    },
    o2($record) {
      return $record.get("o2");
    }
  },
  CFuncOutOutSetofEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  CFuncOutOutUnnamedRecord: {
    __assertStep: assertPgClassSingleStep,
    column1($record) {
      return $record.get("column1");
    },
    column2($record) {
      return $record.get("column2");
    }
  },
  CSearchTestSummariesConnection: {
    __assertStep: ConnectionStep,
    nodes: CSearchTestSummariesConnection_nodesPlan,
    edges: CSearchTestSummariesConnection_edgesPlan,
    pageInfo: CSearchTestSummariesConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CSearchTestSummariesRecord: {
    __assertStep: assertPgClassSingleStep,
    id($record) {
      return $record.get("id");
    },
    totalDuration($record) {
      return $record.get("total_duration");
    }
  },
  CSearchTestSummariesEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  CFuncOutUnnamedOutOutUnnamedRecord: {
    __assertStep: assertPgClassSingleStep,
    column1($record) {
      return $record.get("column1");
    },
    o2($record) {
      return $record.get("o2");
    },
    column3($record) {
      return $record.get("column3");
    }
  },
  CFuncReturnsTableMultiColConnection: {
    __assertStep: ConnectionStep,
    nodes: CFuncReturnsTableMultiColConnection_nodesPlan,
    edges: CFuncReturnsTableMultiColConnection_edgesPlan,
    pageInfo: CFuncReturnsTableMultiColConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CFuncReturnsTableMultiColRecord: {
    __assertStep: assertPgClassSingleStep,
    col1($record) {
      return $record.get("col1");
    },
    col2($record) {
      return $record.get("col2");
    }
  },
  CFuncReturnsTableMultiColEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  CIntSetQueryConnection: {
    __assertStep: ConnectionStep,
    nodes: CIntSetQueryConnection_nodesPlan,
    edges: CIntSetQueryConnection_edgesPlan,
    pageInfo: CIntSetQueryConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CIntSetQueryEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  FloatRangeInput: {
    start: undefined,
    end: undefined
  },
  FloatRangeBoundInput: {
    value: undefined,
    inclusive: undefined
  },
  CFuncOutOutCompoundTypeRecord: {
    __assertStep: assertPgClassSingleStep,
    o1($record) {
      return $record.get("o1");
    },
    o2($record) {
      const $plan = $record.get("o2");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_cCompoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    }
  },
  CQueryOutputTwoRowsRecord: {
    __assertStep: assertPgClassSingleStep,
    txt($record) {
      return $record.get("txt");
    },
    leftArm($record) {
      const $plan = $record.get("left_arm");
      const $select = pgSelectSingleFromRecord(resource_c_left_armPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    post($record) {
      const $plan = $record.get("post");
      const $select = pgSelectSingleFromRecord(resource_postPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    }
  },
  CCompoundTypeConnection: {
    __assertStep: ConnectionStep,
    nodes: CCompoundTypeConnection_nodesPlan,
    edges: CCompoundTypeConnection_edgesPlan,
    pageInfo: CCompoundTypeConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CCompoundTypeEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  CFuncOutComplexRecord: {
    __assertStep: assertPgClassSingleStep,
    x($record) {
      return $record.get("x");
    },
    y($record) {
      const $plan = $record.get("y");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_cCompoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    z($record) {
      const $plan = $record.get("z");
      const $select = pgSelectSingleFromRecord(resource_c_personPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    }
  },
  CFuncOutComplexSetofConnection: {
    __assertStep: ConnectionStep,
    nodes: CFuncOutComplexSetofConnection_nodesPlan,
    edges: CFuncOutComplexSetofConnection_edgesPlan,
    pageInfo: CFuncOutComplexSetofConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CFuncOutComplexSetofRecord: {
    __assertStep: assertPgClassSingleStep,
    x($record) {
      return $record.get("x");
    },
    y($record) {
      const $plan = $record.get("y");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_cCompoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    z($record) {
      const $plan = $record.get("z");
      const $select = pgSelectSingleFromRecord(resource_c_personPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    }
  },
  CFuncOutComplexSetofEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  NonUpdatableViewConnection: {
    __assertStep: ConnectionStep,
    nodes: NonUpdatableViewConnection_nodesPlan,
    edges: NonUpdatableViewConnection_edgesPlan,
    pageInfo: NonUpdatableViewConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  NonUpdatableView: {
    __assertStep: assertPgClassSingleStep,
    column($record) {
      return $record.get("?column?");
    }
  },
  NonUpdatableViewEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  NonUpdatableViewOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    COLUMN_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "?column?",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COLUMN_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "?column?",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  NonUpdatableViewCondition: {
    column: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "?column?",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "?column?",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes12["?column?"].codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  InputConnection: {
    __assertStep: ConnectionStep,
    nodes: InputConnection_nodesPlan,
    edges: InputConnection_edgesPlan,
    pageInfo: InputConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  InputEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  InputOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques2[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_inputs_inputs.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques2[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_inputs_inputs.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  InputCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes13.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  PatchConnection: {
    __assertStep: ConnectionStep,
    nodes: PatchConnection_nodesPlan,
    edges: PatchConnection_edgesPlan,
    pageInfo: PatchConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  PatchEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  PatchOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques3[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_patchs_patchs.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques3[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_patchs_patchs.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  PatchCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes14.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ReservedConnection: {
    __assertStep: ConnectionStep,
    nodes: ReservedConnection_nodesPlan,
    edges: ReservedConnection_edgesPlan,
    pageInfo: ReservedConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  ReservedEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  ReservedOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques4[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_reserved_reserved.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques4[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_reserved_reserved.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  ReservedCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes15.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ReservedPatchRecordConnection: {
    __assertStep: ConnectionStep,
    nodes: ReservedPatchRecordConnection_nodesPlan,
    edges: ReservedPatchRecordConnection_edgesPlan,
    pageInfo: ReservedPatchRecordConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  ReservedPatchRecordEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  ReservedPatchRecordOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques5[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_reservedPatchs_reservedPatchs.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques5[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_reservedPatchs_reservedPatchs.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  ReservedPatchRecordCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes16.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ReservedInputRecordConnection: {
    __assertStep: ConnectionStep,
    nodes: ReservedInputRecordConnection_nodesPlan,
    edges: ReservedInputRecordConnection_edgesPlan,
    pageInfo: ReservedInputRecordConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  ReservedInputRecordEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  ReservedInputRecordOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques6[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_reservedInput_reservedInput.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques6[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_reservedInput_reservedInput.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  ReservedInputRecordCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes17.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  DefaultValueConnection: {
    __assertStep: ConnectionStep,
    nodes: DefaultValueConnection_nodesPlan,
    edges: DefaultValueConnection_edgesPlan,
    pageInfo: DefaultValueConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  DefaultValueEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  DefaultValueOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques7[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_defaultValue_defaultValue.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques7[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_defaultValue_defaultValue.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULL_VALUE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "null_value",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULL_VALUE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "null_value",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  DefaultValueCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes18.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullValue: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "null_value",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "null_value",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes18.null_value.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  NoPrimaryKeyConnection: {
    __assertStep: ConnectionStep,
    nodes: NoPrimaryKeyConnection_nodesPlan,
    edges: NoPrimaryKeyConnection_edgesPlan,
    pageInfo: NoPrimaryKeyConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  NoPrimaryKeyEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  NoPrimaryKeyOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    STR_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "str",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    STR_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "str",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  NoPrimaryKeyCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes20.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    str: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "str",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "str",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes20.str.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  TestviewConnection: {
    __assertStep: ConnectionStep,
    nodes: TestviewConnection_nodesPlan,
    edges: TestviewConnection_edgesPlan,
    pageInfo: TestviewConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  Testview: {
    __assertStep: assertPgClassSingleStep,
    testviewid($record) {
      return $record.get("testviewid");
    },
    col1($record) {
      return $record.get("col1");
    },
    col2($record) {
      return $record.get("col2");
    }
  },
  TestviewEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  TestviewOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    TESTVIEWID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "testviewid",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TESTVIEWID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "testviewid",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL1_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col1",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL1_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col1",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL2_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col2",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL2_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col2",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  TestviewCondition: {
    testviewid: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "testviewid",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "testviewid",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes21.testviewid.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col1: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col1",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col1",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes21.col1.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col2: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col2",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col2",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes21.col2.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UniqueForeignKeyConnection: {
    __assertStep: ConnectionStep,
    nodes: UniqueForeignKeyConnection_nodesPlan,
    edges: UniqueForeignKeyConnection_edgesPlan,
    pageInfo: UniqueForeignKeyConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  UniqueForeignKeyEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  UniqueForeignKeyOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    COMPOUND_KEY_1_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "compound_key_1",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    COMPOUND_KEY_1_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "compound_key_1",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    COMPOUND_KEY_2_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "compound_key_2",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COMPOUND_KEY_2_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "compound_key_2",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  UniqueForeignKeyCondition: {
    compoundKey1: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "compound_key_1",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "compound_key_1",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes22.compound_key_1.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    compoundKey2: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "compound_key_2",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "compound_key_2",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes22.compound_key_2.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CMyTableConnection: {
    __assertStep: ConnectionStep,
    nodes: CMyTableConnection_nodesPlan,
    edges: CMyTableConnection_edgesPlan,
    pageInfo: CMyTableConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CMyTableEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  CMyTableOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques12[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_cMyTable_cMyTable.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques12[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_cMyTable_cMyTable.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    JSON_DATA_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "json_data",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    JSON_DATA_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "json_data",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  CMyTableCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes23.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    jsonData: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "json_data",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "json_data",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes23.json_data.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CPersonSecretConnection: {
    __assertStep: ConnectionStep,
    nodes: CPersonSecretConnection_nodesPlan,
    edges: CPersonSecretConnection_edgesPlan,
    pageInfo: CPersonSecretConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CPersonSecretEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  CPersonSecretOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques13[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_cPersonSecret_cPersonSecret.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques13[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_cPersonSecret_cPersonSecret.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PERSON_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    SECRET_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "sekrit",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    SECRET_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "sekrit",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  CPersonSecretCondition: {
    personId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes24.person_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    secret: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "sekrit",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "sekrit",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes24.sekrit.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ViewTableConnection: {
    __assertStep: ConnectionStep,
    nodes: ViewTableConnection_nodesPlan,
    edges: ViewTableConnection_edgesPlan,
    pageInfo: ViewTableConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  ViewTableEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  ViewTableOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques14[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_viewTable_viewTable.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques14[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_viewTable_viewTable.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL1_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col1",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL1_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col1",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL2_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col2",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL2_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col2",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  ViewTableCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes25.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col1: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col1",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col1",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes25.col1.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col2: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col2",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col2",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes25.col2.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  BUpdatableViewConnection: {
    __assertStep: ConnectionStep,
    nodes: BUpdatableViewConnection_nodesPlan,
    edges: BUpdatableViewConnection_edgesPlan,
    pageInfo: BUpdatableViewConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  BUpdatableView: {
    __assertStep: assertPgClassSingleStep,
    x($record) {
      return $record.get("x");
    },
    name($record) {
      return $record.get("name");
    },
    description($record) {
      return $record.get("description");
    },
    constant($record) {
      return $record.get("constant");
    }
  },
  BUpdatableViewEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  BUpdatableViewOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    X_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "x",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    X_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "x",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DESCRIPTION_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "description",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DESCRIPTION_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "description",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CONSTANT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "constant",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CONSTANT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "constant",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  BUpdatableViewCondition: {
    x: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "x",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "x",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_.x.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_.name.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    description: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "description",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "description",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_.description.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    constant: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "constant",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "constant",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_.constant.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  SimilarTable1Connection: {
    __assertStep: ConnectionStep,
    nodes: SimilarTable1Connection_nodesPlan,
    edges: SimilarTable1Connection_edgesPlan,
    pageInfo: SimilarTable1Connection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  SimilarTable1Edge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  SimilarTable1OrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques17[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_similarTable1_similarTable1.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques17[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_similarTable1_similarTable1.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL1_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col1",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL1_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col1",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL2_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col2",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL2_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col2",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL3_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col3",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL3_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col3",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  SimilarTable1Condition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes27.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col1: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col1",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col1",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes27.col1.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col2: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col2",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col2",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes27.col2.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col3: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col3",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col3",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes27.col3.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  SimilarTable2Connection: {
    __assertStep: ConnectionStep,
    nodes: SimilarTable2Connection_nodesPlan,
    edges: SimilarTable2Connection_edgesPlan,
    pageInfo: SimilarTable2Connection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  SimilarTable2Edge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  SimilarTable2OrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques18[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_similarTable2_similarTable2.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques18[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_similarTable2_similarTable2.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL3_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col3",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL3_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col3",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL4_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col4",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL4_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col4",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL5_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col5",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL5_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col5",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  SimilarTable2Condition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes28.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col3: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col3",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col3",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes28.col3.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col4: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col4",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col4",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes28.col4.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col5: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col5",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col5",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes28.col5.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CNullTestRecordConnection: {
    __assertStep: ConnectionStep,
    nodes: CNullTestRecordConnection_nodesPlan,
    edges: CNullTestRecordConnection_edgesPlan,
    pageInfo: CNullTestRecordConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CNullTestRecordEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  CNullTestRecordOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques19[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_cNullTestRecord_cNullTestRecord.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques19[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_cNullTestRecord_cNullTestRecord.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULLABLE_TEXT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nullable_text",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULLABLE_TEXT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nullable_text",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULLABLE_INT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nullable_int",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULLABLE_INT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nullable_int",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NON_NULL_TEXT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "non_null_text",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NON_NULL_TEXT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "non_null_text",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  CNullTestRecordCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes29.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableText: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "nullable_text",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "nullable_text",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes29.nullable_text.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableInt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "nullable_int",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "nullable_int",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes29.nullable_int.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nonNullText: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "non_null_text",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "non_null_text",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes29.non_null_text.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CEdgeCaseConnection: {
    __assertStep: ConnectionStep,
    nodes: CEdgeCaseConnection_nodesPlan,
    edges: CEdgeCaseConnection_edgesPlan,
    pageInfo: CEdgeCaseConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CEdgeCase: {
    __assertStep: assertPgClassSingleStep,
    computed($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs78(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_c_edge_case_computedPgResource.isUnique && !resource_c_edge_case_computedPgResource.codec.attributes && typeof resource_c_edge_case_computedPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_c_edge_case_computedPgResource.codec)`${resource_c_edge_case_computedPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_c_edge_case_computedPgResource.execute(selectArgs);
    },
    notNullHasDefault($record) {
      return $record.get("not_null_has_default");
    },
    wontCastEasy($record) {
      return $record.get("wont_cast_easy");
    },
    rowId($record) {
      return $record.get("row_id");
    }
  },
  CEdgeCaseEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  CEdgeCaseOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    NOT_NULL_HAS_DEFAULT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "not_null_has_default",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NOT_NULL_HAS_DEFAULT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "not_null_has_default",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    WONT_CAST_EASY_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "wont_cast_easy",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    WONT_CAST_EASY_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "wont_cast_easy",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROW_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "row_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROW_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "row_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  CEdgeCaseCondition: {
    notNullHasDefault: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "not_null_has_default",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "not_null_has_default",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes30.not_null_has_default.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    wontCastEasy: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "wont_cast_easy",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "wont_cast_easy",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes30.wont_cast_easy.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "row_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "row_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes30.row_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CLeftArmConnection: {
    __assertStep: ConnectionStep,
    nodes: CLeftArmConnection_nodesPlan,
    edges: CLeftArmConnection_edgesPlan,
    pageInfo: CLeftArmConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CLeftArmEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  CLeftArmOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques21[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_cLeftArm_cLeftArm.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques21[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_cLeftArm_cLeftArm.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    LENGTH_IN_METRES_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "length_in_metres",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LENGTH_IN_METRES_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "length_in_metres",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    MOOD_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "mood",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    MOOD_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "mood",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  CLeftArmCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes31.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes31.person_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lengthInMetres: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "length_in_metres",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "length_in_metres",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes31.length_in_metres.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    mood: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "mood",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "mood",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes31.mood.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CIssue756Connection: {
    __assertStep: ConnectionStep,
    nodes: CIssue756Connection_nodesPlan,
    edges: CIssue756Connection_edgesPlan,
    pageInfo: CIssue756Connection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CIssue756Edge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  CIssue756OrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques23[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_cIssue756_cIssue756.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques23[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_cIssue756_cIssue756.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    TS_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "ts",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TS_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "ts",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  CIssue756Condition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes33.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    ts: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "ts",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "ts",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes33.ts.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CPersonOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques27[0].attributes.forEach(attributeName => {
          const attribute = attributes_person_codec_cPerson.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques27[0].attributes.forEach(attributeName => {
          const attribute = attributes_person_codec_cPerson.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_full_name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_full_name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ABOUT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "about",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ABOUT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "about",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    EMAIL_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "email",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    EMAIL_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "email",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    CONFIG_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "config",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CONFIG_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "config",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LAST_LOGIN_FROM_IP_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "last_login_from_ip",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LAST_LOGIN_FROM_IP_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "last_login_from_ip",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LAST_LOGIN_FROM_SUBNET_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "last_login_from_subnet",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LAST_LOGIN_FROM_SUBNET_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "last_login_from_subnet",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    USER_MAC_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "user_mac",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    USER_MAC_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "user_mac",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  CPersonCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "person_full_name",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "person_full_name",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.person_full_name.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    about: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "about",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "about",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.about.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    email: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "email",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "email",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.email.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    config: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "config",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "config",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.config.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastLoginFromIp: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "last_login_from_ip",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "last_login_from_ip",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.last_login_from_ip.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastLoginFromSubnet: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "last_login_from_subnet",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "last_login_from_subnet",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.last_login_from_subnet.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userMac: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "user_mac",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "user_mac",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.user_mac.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.created_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  Mutation: {
    __assertStep: __ValueStep,
    cMutationOut: {
      plan($root, args, _info) {
        const selectArgs = makeArgs79(args, ["input"]);
        const $result = resource_c_mutation_outPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cMutationOut_input_applyPlan
        }
      }
    },
    cMutationOutSetof: {
      plan($root, args, _info) {
        const selectArgs = makeArgs80(args, ["input"]);
        const $result = resource_c_mutation_out_setofPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cMutationOutSetof_input_applyPlan
        }
      }
    },
    cMutationOutUnnamed: {
      plan($root, args, _info) {
        const selectArgs = makeArgs81(args, ["input"]);
        const $result = resource_c_mutation_out_unnamedPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cMutationOutUnnamed_input_applyPlan
        }
      }
    },
    cNoArgsMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs82(args, ["input"]);
        const $result = resource_c_no_args_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cNoArgsMutation_input_applyPlan
        }
      }
    },
    returnVoidMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs83(args, ["input"]);
        const $result = resource_return_void_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_returnVoidMutation_input_applyPlan
        }
      }
    },
    mutationIntervalSet: {
      plan($root, args, _info) {
        const selectArgs = makeArgs84(args, ["input"]);
        const $result = resource_mutation_interval_setPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationIntervalSet_input_applyPlan
        }
      }
    },
    cMutationInOut: {
      plan($root, args, _info) {
        const selectArgs = makeArgs85(args, ["input"]);
        const $result = resource_c_mutation_in_outPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cMutationInOut_input_applyPlan
        }
      }
    },
    cMutationReturnsTableOneCol: {
      plan($root, args, _info) {
        const selectArgs = makeArgs86(args, ["input"]);
        const $result = resource_c_mutation_returns_table_one_colPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cMutationReturnsTableOneCol_input_applyPlan
        }
      }
    },
    cJsonIdentityMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs87(args, ["input"]);
        const $result = resource_c_json_identity_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cJsonIdentityMutation_input_applyPlan
        }
      }
    },
    cJsonbIdentityMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs88(args, ["input"]);
        const $result = resource_c_jsonb_identity_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cJsonbIdentityMutation_input_applyPlan
        }
      }
    },
    cJsonbIdentityMutationPlpgsql: {
      plan($root, args, _info) {
        const selectArgs = makeArgs89(args, ["input"]);
        const $result = resource_c_jsonb_identity_mutation_plpgsqlPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cJsonbIdentityMutationPlpgsql_input_applyPlan
        }
      }
    },
    cJsonbIdentityMutationPlpgsqlWithDefault: {
      plan($root, args, _info) {
        const selectArgs = makeArgs90(args, ["input"]);
        const $result = resource_c_jsonb_identity_mutation_plpgsql_with_defaultPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cJsonbIdentityMutationPlpgsqlWithDefault_input_applyPlan
        }
      }
    },
    add1Mutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs91(args, ["input"]);
        const $result = resource_add_1_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_add1Mutation_input_applyPlan
        }
      }
    },
    add2Mutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs92(args, ["input"]);
        const $result = resource_add_2_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_add2Mutation_input_applyPlan
        }
      }
    },
    add3Mutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs93(args, ["input"]);
        const $result = resource_add_3_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_add3Mutation_input_applyPlan
        }
      }
    },
    add4Mutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs94(args, ["input"]);
        const $result = resource_add_4_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_add4Mutation_input_applyPlan
        }
      }
    },
    add4MutationError: {
      plan($root, args, _info) {
        const selectArgs = makeArgs95(args, ["input"]);
        const $result = resource_add_4_mutation_errorPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_add4MutationError_input_applyPlan
        }
      }
    },
    bMult1: {
      plan($root, args, _info) {
        const selectArgs = makeArgs96(args, ["input"]);
        const $result = resource_b_mult_1PgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_bMult1_input_applyPlan
        }
      }
    },
    bMult2: {
      plan($root, args, _info) {
        const selectArgs = makeArgs97(args, ["input"]);
        const $result = resource_b_mult_2PgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_bMult2_input_applyPlan
        }
      }
    },
    bMult3: {
      plan($root, args, _info) {
        const selectArgs = makeArgs98(args, ["input"]);
        const $result = resource_b_mult_3PgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_bMult3_input_applyPlan
        }
      }
    },
    bMult4: {
      plan($root, args, _info) {
        const selectArgs = makeArgs99(args, ["input"]);
        const $result = resource_b_mult_4PgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_bMult4_input_applyPlan
        }
      }
    },
    cMutationInInout: {
      plan($root, args, _info) {
        const selectArgs = makeArgs100(args, ["input"]);
        const $result = resource_c_mutation_in_inoutPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cMutationInInout_input_applyPlan
        }
      }
    },
    cMutationOutOut: {
      plan($root, args, _info) {
        const selectArgs = makeArgs101(args, ["input"]);
        const $result = resource_c_mutation_out_outPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cMutationOutOut_input_applyPlan
        }
      }
    },
    cMutationOutOutSetof: {
      plan($root, args, _info) {
        const selectArgs = makeArgs102(args, ["input"]);
        const $result = resource_c_mutation_out_out_setofPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cMutationOutOutSetof_input_applyPlan
        }
      }
    },
    cMutationOutOutUnnamed: {
      plan($root, args, _info) {
        const selectArgs = makeArgs103(args, ["input"]);
        const $result = resource_c_mutation_out_out_unnamedPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cMutationOutOutUnnamed_input_applyPlan
        }
      }
    },
    cIntSetMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs104(args, ["input"]);
        const $result = resource_c_int_set_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cIntSetMutation_input_applyPlan
        }
      }
    },
    cMutationOutUnnamedOutOutUnnamed: {
      plan($root, args, _info) {
        const selectArgs = makeArgs105(args, ["input"]);
        const $result = resource_c_mutation_out_unnamed_out_out_unnamedPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cMutationOutUnnamedOutOutUnnamed_input_applyPlan
        }
      }
    },
    cMutationReturnsTableMultiCol: {
      plan($root, args, _info) {
        const selectArgs = makeArgs106(args, ["input"]);
        const $result = resource_c_mutation_returns_table_multi_colPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cMutationReturnsTableMultiCol_input_applyPlan
        }
      }
    },
    bGuidFn: {
      plan($root, args, _info) {
        const selectArgs = makeArgs107(args, ["input"]);
        const $result = resource_b_guid_fnPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_bGuidFn_input_applyPlan
        }
      }
    },
    mutationIntervalArray: {
      plan($root, args, _info) {
        const selectArgs = makeArgs108(args, ["input"]);
        const $result = resource_mutation_interval_arrayPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationIntervalArray_input_applyPlan
        }
      }
    },
    mutationTextArray: {
      plan($root, args, _info) {
        const selectArgs = makeArgs109(args, ["input"]);
        const $result = resource_mutation_text_arrayPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationTextArray_input_applyPlan
        }
      }
    },
    bListBdeMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs110(args, ["input"]);
        const $result = resource_b_list_bde_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_bListBdeMutation_input_applyPlan
        }
      }
    },
    bAuthenticateFail: {
      plan($root, args, _info) {
        const selectArgs = makeArgs111(args, ["input"]);
        const $result = resource_b_authenticate_failPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_bAuthenticateFail_input_applyPlan
        }
      }
    },
    bAuthenticate: {
      plan($root, args, _info) {
        const selectArgs = makeArgs112(args, ["input"]);
        const $result = resource_b_authenticatePgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_bAuthenticate_input_applyPlan
        }
      }
    },
    cLeftArmIdentity: {
      plan($root, args, _info) {
        const selectArgs = makeArgs113(args, ["input"]);
        const $result = resource_c_left_arm_identityPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cLeftArmIdentity_input_applyPlan
        }
      }
    },
    cIssue756Mutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs114(args, ["input"]);
        const $result = resource_c_issue756_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cIssue756Mutation_input_applyPlan
        }
      }
    },
    cIssue756SetMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs115(args, ["input"]);
        const $result = resource_c_issue756_set_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cIssue756SetMutation_input_applyPlan
        }
      }
    },
    bAuthenticateMany: {
      plan($root, args, _info) {
        const selectArgs = makeArgs116(args, ["input"]);
        const $result = resource_b_authenticate_manyPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_bAuthenticateMany_input_applyPlan
        }
      }
    },
    bAuthenticatePayload: {
      plan($root, args, _info) {
        const selectArgs = makeArgs117(args, ["input"]);
        const $result = resource_b_authenticate_payloadPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_bAuthenticatePayload_input_applyPlan
        }
      }
    },
    cTypesMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs118(args, ["input"]);
        const $result = resource_c_types_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cTypesMutation_input_applyPlan
        }
      }
    },
    cMutationOutOutCompoundType: {
      plan($root, args, _info) {
        const selectArgs = makeArgs119(args, ["input"]);
        const $result = resource_c_mutation_out_out_compound_typePgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cMutationOutOutCompoundType_input_applyPlan
        }
      }
    },
    bCompoundTypeMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs120(args, ["input"]);
        const $result = resource_b_compound_type_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_bCompoundTypeMutation_input_applyPlan
        }
      }
    },
    bCompoundTypeSetMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs121(args, ["input"]);
        const $result = resource_b_compound_type_set_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_bCompoundTypeSetMutation_input_applyPlan
        }
      }
    },
    cTableMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs122(args, ["input"]);
        const $result = resource_c_table_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cTableMutation_input_applyPlan
        }
      }
    },
    postWithSuffix: {
      plan($root, args, _info) {
        const selectArgs = makeArgs123(args, ["input"]);
        const $result = resource_post_with_suffixPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_postWithSuffix_input_applyPlan
        }
      }
    },
    mutationCompoundTypeArray: {
      plan($root, args, _info) {
        const selectArgs = makeArgs124(args, ["input"]);
        const $result = resource_mutation_compound_type_arrayPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationCompoundTypeArray_input_applyPlan
        }
      }
    },
    bCompoundTypeArrayMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs125(args, ["input"]);
        const $result = resource_b_compound_type_array_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_bCompoundTypeArrayMutation_input_applyPlan
        }
      }
    },
    postMany: {
      plan($root, args, _info) {
        const selectArgs = makeArgs126(args, ["input"]);
        const $result = resource_post_manyPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_postMany_input_applyPlan
        }
      }
    },
    cMutationOutComplex: {
      plan($root, args, _info) {
        const selectArgs = makeArgs127(args, ["input"]);
        const $result = resource_c_mutation_out_complexPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cMutationOutComplex_input_applyPlan
        }
      }
    },
    cMutationOutComplexSetof: {
      plan($root, args, _info) {
        const selectArgs = makeArgs128(args, ["input"]);
        const $result = resource_c_mutation_out_complex_setofPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cMutationOutComplexSetof_input_applyPlan
        }
      }
    },
    cMutationOutTable: {
      plan($root, args, _info) {
        const selectArgs = makeArgs129(args, ["input"]);
        const $result = resource_c_mutation_out_tablePgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cMutationOutTable_input_applyPlan
        }
      }
    },
    cMutationOutTableSetof: {
      plan($root, args, _info) {
        const selectArgs = makeArgs130(args, ["input"]);
        const $result = resource_c_mutation_out_table_setofPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cMutationOutTableSetof_input_applyPlan
        }
      }
    },
    cTableSetMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs131(args, ["input"]);
        const $result = resource_c_table_set_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_cTableSetMutation_input_applyPlan
        }
      }
    },
    bTypeFunctionConnectionMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs132(args, ["input"]);
        const $result = resource_b_type_function_connection_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_bTypeFunctionConnectionMutation_input_applyPlan
        }
      }
    },
    bTypeFunctionMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs133(args, ["input"]);
        const $result = resource_b_type_function_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_bTypeFunctionMutation_input_applyPlan
        }
      }
    },
    bTypeFunctionListMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs134(args, ["input"]);
        const $result = resource_b_type_function_list_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_bTypeFunctionListMutation_input_applyPlan
        }
      }
    },
    createInput: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_inputsPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createInput_input_applyPlan
        }
      }
    },
    createPatch: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_patchsPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createPatch_input_applyPlan
        }
      }
    },
    createReserved: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_reservedPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createReserved_input_applyPlan
        }
      }
    },
    createReservedPatchRecord: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_reservedPatchsPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createReservedPatchRecord_input_applyPlan
        }
      }
    },
    createReservedInputRecord: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_reserved_inputPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createReservedInputRecord_input_applyPlan
        }
      }
    },
    createDefaultValue: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_default_valuePgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createDefaultValue_input_applyPlan
        }
      }
    },
    createForeignKey: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_foreign_keyPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createForeignKey_input_applyPlan
        }
      }
    },
    createNoPrimaryKey: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_no_primary_keyPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createNoPrimaryKey_input_applyPlan
        }
      }
    },
    createTestview: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_testviewPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createTestview_input_applyPlan
        }
      }
    },
    createUniqueForeignKey: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_unique_foreign_keyPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createUniqueForeignKey_input_applyPlan
        }
      }
    },
    createCMyTable: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_c_my_tablePgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createCMyTable_input_applyPlan
        }
      }
    },
    createCPersonSecret: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_c_person_secretPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createCPersonSecret_input_applyPlan
        }
      }
    },
    createViewTable: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_view_tablePgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createViewTable_input_applyPlan
        }
      }
    },
    createBUpdatableView: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_b_updatable_viewPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createBUpdatableView_input_applyPlan
        }
      }
    },
    createCCompoundKey: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_c_compound_keyPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createCCompoundKey_input_applyPlan
        }
      }
    },
    createSimilarTable1: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_similar_table_1PgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createSimilarTable1_input_applyPlan
        }
      }
    },
    createSimilarTable2: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_similar_table_2PgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createSimilarTable2_input_applyPlan
        }
      }
    },
    createCNullTestRecord: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_c_null_test_recordPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createCNullTestRecord_input_applyPlan
        }
      }
    },
    createCEdgeCase: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_c_edge_casePgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createCEdgeCase_input_applyPlan
        }
      }
    },
    createCLeftArm: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_c_left_armPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createCLeftArm_input_applyPlan
        }
      }
    },
    createCIssue756: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_c_issue756PgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createCIssue756_input_applyPlan
        }
      }
    },
    createPost: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_postPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createPost_input_applyPlan
        }
      }
    },
    createCPerson: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_c_personPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createCPerson_input_applyPlan
        }
      }
    },
    createBType: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_b_typesPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createBType_input_applyPlan
        }
      }
    },
    updateInputByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_inputsPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateInputByRowId_input_applyPlan
        }
      }
    },
    updatePatchByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_patchsPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updatePatchByRowId_input_applyPlan
        }
      }
    },
    updateReservedByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_reservedPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateReservedByRowId_input_applyPlan
        }
      }
    },
    updateReservedPatchRecordByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_reservedPatchsPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateReservedPatchRecordByRowId_input_applyPlan
        }
      }
    },
    updateReservedInputRecordByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_reserved_inputPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateReservedInputRecordByRowId_input_applyPlan
        }
      }
    },
    updateDefaultValueByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_default_valuePgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateDefaultValueByRowId_input_applyPlan
        }
      }
    },
    updateNoPrimaryKeyByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_no_primary_keyPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateNoPrimaryKeyByRowId_input_applyPlan
        }
      }
    },
    updateUniqueForeignKeyByCompoundKey1AndCompoundKey2: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_unique_foreign_keyPgResource, {
            compound_key_1: args.get(['input', "compoundKey1"]),
            compound_key_2: args.get(['input', "compoundKey2"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateUniqueForeignKeyByCompoundKey1AndCompoundKey2_input_applyPlan
        }
      }
    },
    updateCMyTableByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_c_my_tablePgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateCMyTableByRowId_input_applyPlan
        }
      }
    },
    updateCPersonSecretByPersonId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_c_person_secretPgResource, {
            person_id: args.get(['input', "personId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateCPersonSecretByPersonId_input_applyPlan
        }
      }
    },
    updateViewTableByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_view_tablePgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateViewTableByRowId_input_applyPlan
        }
      }
    },
    updateCCompoundKeyByPersonId1AndPersonId2: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_c_compound_keyPgResource, {
            person_id_1: args.get(['input', "personId1"]),
            person_id_2: args.get(['input', "personId2"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateCCompoundKeyByPersonId1AndPersonId2_input_applyPlan
        }
      }
    },
    updateSimilarTable1ByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_similar_table_1PgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateSimilarTable1ByRowId_input_applyPlan
        }
      }
    },
    updateSimilarTable2ByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_similar_table_2PgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateSimilarTable2ByRowId_input_applyPlan
        }
      }
    },
    updateCNullTestRecordByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_c_null_test_recordPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateCNullTestRecordByRowId_input_applyPlan
        }
      }
    },
    updateCLeftArmByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_c_left_armPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateCLeftArmByRowId_input_applyPlan
        }
      }
    },
    updateCLeftArmByPersonId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_c_left_armPgResource, {
            person_id: args.get(['input', "personId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateCLeftArmByPersonId_input_applyPlan
        }
      }
    },
    updateCIssue756ByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_c_issue756PgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateCIssue756ByRowId_input_applyPlan
        }
      }
    },
    updatePostByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_postPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updatePostByRowId_input_applyPlan
        }
      }
    },
    updateCPersonByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_c_personPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateCPersonByRowId_input_applyPlan
        }
      }
    },
    updateCPersonByEmail: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_c_personPgResource, {
            email: args.get(['input', "email"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateCPersonByEmail_input_applyPlan
        }
      }
    },
    updateBTypeByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_b_typesPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateBTypeByRowId_input_applyPlan
        }
      }
    },
    deleteInputByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_inputsPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteInputByRowId_input_applyPlan
        }
      }
    },
    deletePatchByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_patchsPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deletePatchByRowId_input_applyPlan
        }
      }
    },
    deleteReservedByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_reservedPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteReservedByRowId_input_applyPlan
        }
      }
    },
    deleteReservedPatchRecordByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_reservedPatchsPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteReservedPatchRecordByRowId_input_applyPlan
        }
      }
    },
    deleteReservedInputRecordByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_reserved_inputPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteReservedInputRecordByRowId_input_applyPlan
        }
      }
    },
    deleteDefaultValueByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_default_valuePgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteDefaultValueByRowId_input_applyPlan
        }
      }
    },
    deleteNoPrimaryKeyByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_no_primary_keyPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteNoPrimaryKeyByRowId_input_applyPlan
        }
      }
    },
    deleteUniqueForeignKeyByCompoundKey1AndCompoundKey2: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_unique_foreign_keyPgResource, {
            compound_key_1: args.get(['input', "compoundKey1"]),
            compound_key_2: args.get(['input', "compoundKey2"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteUniqueForeignKeyByCompoundKey1AndCompoundKey2_input_applyPlan
        }
      }
    },
    deleteCMyTableByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_c_my_tablePgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteCMyTableByRowId_input_applyPlan
        }
      }
    },
    deleteCPersonSecretByPersonId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_c_person_secretPgResource, {
            person_id: args.get(['input', "personId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteCPersonSecretByPersonId_input_applyPlan
        }
      }
    },
    deleteViewTableByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_view_tablePgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteViewTableByRowId_input_applyPlan
        }
      }
    },
    deleteCCompoundKeyByPersonId1AndPersonId2: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_c_compound_keyPgResource, {
            person_id_1: args.get(['input', "personId1"]),
            person_id_2: args.get(['input', "personId2"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteCCompoundKeyByPersonId1AndPersonId2_input_applyPlan
        }
      }
    },
    deleteSimilarTable1ByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_similar_table_1PgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteSimilarTable1ByRowId_input_applyPlan
        }
      }
    },
    deleteSimilarTable2ByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_similar_table_2PgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteSimilarTable2ByRowId_input_applyPlan
        }
      }
    },
    deleteCNullTestRecordByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_c_null_test_recordPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteCNullTestRecordByRowId_input_applyPlan
        }
      }
    },
    deleteCLeftArmByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_c_left_armPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteCLeftArmByRowId_input_applyPlan
        }
      }
    },
    deleteCLeftArmByPersonId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_c_left_armPgResource, {
            person_id: args.get(['input', "personId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteCLeftArmByPersonId_input_applyPlan
        }
      }
    },
    deleteCIssue756ByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_c_issue756PgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteCIssue756ByRowId_input_applyPlan
        }
      }
    },
    deletePostByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_postPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deletePostByRowId_input_applyPlan
        }
      }
    },
    deleteCPersonByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_c_personPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteCPersonByRowId_input_applyPlan
        }
      }
    },
    deleteCPersonByEmail: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_c_personPgResource, {
            email: args.get(['input', "email"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteCPersonByEmail_input_applyPlan
        }
      }
    },
    deleteBTypeByRowId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_b_typesPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteBTypeByRowId_input_applyPlan
        }
      }
    }
  },
  CMutationOutPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CMutationOutPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CMutationOutPayload_queryPlan
  },
  CMutationOutInput: {
    clientMutationId: {
      applyPlan: CMutationOutInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CMutationOutSetofPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CMutationOutSetofPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CMutationOutSetofPayload_queryPlan
  },
  CMutationOutSetofInput: {
    clientMutationId: {
      applyPlan: CMutationOutSetofInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CMutationOutUnnamedPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CMutationOutUnnamedPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CMutationOutUnnamedPayload_queryPlan
  },
  CMutationOutUnnamedInput: {
    clientMutationId: {
      applyPlan: CMutationOutUnnamedInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CNoArgsMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CNoArgsMutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CNoArgsMutationPayload_queryPlan
  },
  CNoArgsMutationInput: {
    clientMutationId: {
      applyPlan: CNoArgsMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ReturnVoidMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: ReturnVoidMutationPayload_clientMutationIdPlan,
    query: ReturnVoidMutationPayload_queryPlan
  },
  ReturnVoidMutationInput: {
    clientMutationId: {
      applyPlan: ReturnVoidMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MutationIntervalSetPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationIntervalSetPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: MutationIntervalSetPayload_queryPlan
  },
  MutationIntervalSetInput: {
    clientMutationId: {
      applyPlan: MutationIntervalSetInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CMutationInOutPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CMutationInOutPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CMutationInOutPayload_queryPlan
  },
  CMutationInOutInput: {
    clientMutationId: {
      applyPlan: CMutationInOutInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    i: undefined
  },
  CMutationReturnsTableOneColPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CMutationReturnsTableOneColPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CMutationReturnsTableOneColPayload_queryPlan
  },
  CMutationReturnsTableOneColInput: {
    clientMutationId: {
      applyPlan: CMutationReturnsTableOneColInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    i: undefined
  },
  CJsonIdentityMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CJsonIdentityMutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CJsonIdentityMutationPayload_queryPlan
  },
  CJsonIdentityMutationInput: {
    clientMutationId: {
      applyPlan: CJsonIdentityMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    json: undefined
  },
  CJsonbIdentityMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CJsonbIdentityMutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CJsonbIdentityMutationPayload_queryPlan
  },
  CJsonbIdentityMutationInput: {
    clientMutationId: {
      applyPlan: CJsonbIdentityMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    json: undefined
  },
  CJsonbIdentityMutationPlpgsqlPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CJsonbIdentityMutationPlpgsqlPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CJsonbIdentityMutationPlpgsqlPayload_queryPlan
  },
  CJsonbIdentityMutationPlpgsqlInput: {
    clientMutationId: {
      applyPlan: CJsonbIdentityMutationPlpgsqlInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    _theJson: undefined
  },
  CJsonbIdentityMutationPlpgsqlWithDefaultPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CJsonbIdentityMutationPlpgsqlWithDefaultPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CJsonbIdentityMutationPlpgsqlWithDefaultPayload_queryPlan
  },
  CJsonbIdentityMutationPlpgsqlWithDefaultInput: {
    clientMutationId: {
      applyPlan: CJsonbIdentityMutationPlpgsqlWithDefaultInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    _theJson: undefined
  },
  Add1MutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: Add1MutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: Add1MutationPayload_queryPlan
  },
  Add1MutationInput: {
    clientMutationId: {
      applyPlan: Add1MutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    arg0: undefined,
    arg1: undefined
  },
  Add2MutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: Add2MutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: Add2MutationPayload_queryPlan
  },
  Add2MutationInput: {
    clientMutationId: {
      applyPlan: Add2MutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    a: undefined,
    b: undefined
  },
  Add3MutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: Add3MutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: Add3MutationPayload_queryPlan
  },
  Add3MutationInput: {
    clientMutationId: {
      applyPlan: Add3MutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    a: undefined,
    arg1: undefined
  },
  Add4MutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: Add4MutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: Add4MutationPayload_queryPlan
  },
  Add4MutationInput: {
    clientMutationId: {
      applyPlan: Add4MutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    arg0: undefined,
    b: undefined
  },
  Add4MutationErrorPayload: {
    __assertStep: ObjectStep,
    clientMutationId: Add4MutationErrorPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: Add4MutationErrorPayload_queryPlan
  },
  Add4MutationErrorInput: {
    clientMutationId: {
      applyPlan: Add4MutationErrorInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    arg0: undefined,
    b: undefined
  },
  BMult1Payload: {
    __assertStep: ObjectStep,
    clientMutationId: BMult1Payload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: BMult1Payload_queryPlan
  },
  BMult1Input: {
    clientMutationId: {
      applyPlan: BMult1Input_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    arg0: undefined,
    arg1: undefined
  },
  BMult2Payload: {
    __assertStep: ObjectStep,
    clientMutationId: BMult2Payload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: BMult2Payload_queryPlan
  },
  BMult2Input: {
    clientMutationId: {
      applyPlan: BMult2Input_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    arg0: undefined,
    arg1: undefined
  },
  BMult3Payload: {
    __assertStep: ObjectStep,
    clientMutationId: BMult3Payload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: BMult3Payload_queryPlan
  },
  BMult3Input: {
    clientMutationId: {
      applyPlan: BMult3Input_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    arg0: undefined,
    arg1: undefined
  },
  BMult4Payload: {
    __assertStep: ObjectStep,
    clientMutationId: BMult4Payload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: BMult4Payload_queryPlan
  },
  BMult4Input: {
    clientMutationId: {
      applyPlan: BMult4Input_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    arg0: undefined,
    arg1: undefined
  },
  CMutationInInoutPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CMutationInInoutPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CMutationInInoutPayload_queryPlan
  },
  CMutationInInoutInput: {
    clientMutationId: {
      applyPlan: CMutationInInoutInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    i: undefined,
    ino: undefined
  },
  CMutationOutOutPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CMutationOutOutPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CMutationOutOutPayload_queryPlan
  },
  CMutationOutOutRecord: {
    __assertStep: assertPgClassSingleStep,
    firstOut($record) {
      return $record.get("first_out");
    },
    secondOut($record) {
      return $record.get("second_out");
    }
  },
  CMutationOutOutInput: {
    clientMutationId: {
      applyPlan: CMutationOutOutInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CMutationOutOutSetofPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CMutationOutOutSetofPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CMutationOutOutSetofPayload_queryPlan
  },
  CMutationOutOutSetofRecord: {
    __assertStep: assertPgClassSingleStep,
    o1($record) {
      return $record.get("o1");
    },
    o2($record) {
      return $record.get("o2");
    }
  },
  CMutationOutOutSetofInput: {
    clientMutationId: {
      applyPlan: CMutationOutOutSetofInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CMutationOutOutUnnamedPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CMutationOutOutUnnamedPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CMutationOutOutUnnamedPayload_queryPlan
  },
  CMutationOutOutUnnamedRecord: {
    __assertStep: assertPgClassSingleStep,
    column1($record) {
      return $record.get("column1");
    },
    column2($record) {
      return $record.get("column2");
    }
  },
  CMutationOutOutUnnamedInput: {
    clientMutationId: {
      applyPlan: CMutationOutOutUnnamedInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CIntSetMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CIntSetMutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CIntSetMutationPayload_queryPlan
  },
  CIntSetMutationInput: {
    clientMutationId: {
      applyPlan: CIntSetMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    x: undefined,
    y: undefined,
    z: undefined
  },
  CMutationOutUnnamedOutOutUnnamedPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CMutationOutUnnamedOutOutUnnamedPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CMutationOutUnnamedOutOutUnnamedPayload_queryPlan
  },
  CMutationOutUnnamedOutOutUnnamedRecord: {
    __assertStep: assertPgClassSingleStep,
    column1($record) {
      return $record.get("column1");
    },
    o2($record) {
      return $record.get("o2");
    },
    column3($record) {
      return $record.get("column3");
    }
  },
  CMutationOutUnnamedOutOutUnnamedInput: {
    clientMutationId: {
      applyPlan: CMutationOutUnnamedOutOutUnnamedInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CMutationReturnsTableMultiColPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CMutationReturnsTableMultiColPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CMutationReturnsTableMultiColPayload_queryPlan
  },
  CMutationReturnsTableMultiColRecord: {
    __assertStep: assertPgClassSingleStep,
    col1($record) {
      return $record.get("col1");
    },
    col2($record) {
      return $record.get("col2");
    }
  },
  CMutationReturnsTableMultiColInput: {
    clientMutationId: {
      applyPlan: CMutationReturnsTableMultiColInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    i: undefined
  },
  BGuidFnPayload: {
    __assertStep: ObjectStep,
    clientMutationId: BGuidFnPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: BGuidFnPayload_queryPlan
  },
  BGuidFnInput: {
    clientMutationId: {
      applyPlan: BGuidFnInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    g: undefined
  },
  MutationIntervalArrayPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationIntervalArrayPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: MutationIntervalArrayPayload_queryPlan
  },
  MutationIntervalArrayInput: {
    clientMutationId: {
      applyPlan: MutationIntervalArrayInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MutationTextArrayPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationTextArrayPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: MutationTextArrayPayload_queryPlan
  },
  MutationTextArrayInput: {
    clientMutationId: {
      applyPlan: MutationTextArrayInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  BListBdeMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: BListBdeMutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: BListBdeMutationPayload_queryPlan
  },
  BListBdeMutationInput: {
    clientMutationId: {
      applyPlan: BListBdeMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    b: undefined,
    d: undefined,
    e: undefined
  },
  BAuthenticateFailPayload: {
    __assertStep: ObjectStep,
    clientMutationId: BAuthenticateFailPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: BAuthenticateFailPayload_queryPlan
  },
  BJwtToken: {
    __assertStep: assertPgClassSingleStep,
    role($record) {
      return $record.get("role");
    },
    exp($record) {
      return $record.get("exp");
    },
    a($record) {
      return $record.get("a");
    },
    b($record) {
      return $record.get("b");
    },
    c($record) {
      return $record.get("c");
    }
  },
  BAuthenticateFailInput: {
    clientMutationId: {
      applyPlan: BAuthenticateFailInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  BAuthenticatePayload: {
    __assertStep: ObjectStep,
    clientMutationId: BAuthenticatePayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: BAuthenticatePayload_queryPlan
  },
  BAuthenticateInput: {
    clientMutationId: {
      applyPlan: BAuthenticateInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    a: undefined,
    b: undefined,
    c: undefined
  },
  CLeftArmIdentityPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CLeftArmIdentityPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CLeftArmIdentityPayload_queryPlan,
    cLeftArmEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques21[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_left_armPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CLeftArmOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CLeftArmIdentityInput: {
    clientMutationId: {
      applyPlan: CLeftArmIdentityInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    leftArm: undefined
  },
  CLeftArmBaseInput: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lengthInMetres: {
      applyPlan($insert, val) {
        $insert.set("length_in_metres", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    mood: {
      applyPlan($insert, val) {
        $insert.set("mood", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CIssue756MutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CIssue756MutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CIssue756MutationPayload_queryPlan,
    cIssue756Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques23[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_issue756PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CIssue756OrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CIssue756MutationInput: {
    clientMutationId: {
      applyPlan: CIssue756MutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CIssue756SetMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CIssue756SetMutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CIssue756SetMutationPayload_queryPlan
  },
  CIssue756SetMutationInput: {
    clientMutationId: {
      applyPlan: CIssue756SetMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  BAuthenticateManyPayload: {
    __assertStep: ObjectStep,
    clientMutationId: BAuthenticateManyPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: BAuthenticateManyPayload_queryPlan
  },
  BAuthenticateManyInput: {
    clientMutationId: {
      applyPlan: BAuthenticateManyInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    a: undefined,
    b: undefined,
    c: undefined
  },
  BAuthenticatePayloadPayload: {
    __assertStep: ObjectStep,
    clientMutationId: BAuthenticatePayloadPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: BAuthenticatePayloadPayload_queryPlan
  },
  BAuthPayload: {
    __assertStep: assertPgClassSingleStep,
    jwt($record) {
      const $plan = $record.get("jwt");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_bJwtTokenPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    rowId($record) {
      return $record.get("id");
    },
    admin($record) {
      return $record.get("admin");
    },
    cPersonByRowId($record) {
      return resource_c_personPgResource.get({
        id: $record.get("id")
      });
    }
  },
  BAuthenticatePayloadInput: {
    clientMutationId: {
      applyPlan: BAuthenticatePayloadInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    a: undefined,
    b: undefined,
    c: undefined
  },
  CTypesMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CTypesMutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CTypesMutationPayload_queryPlan
  },
  CTypesMutationInput: {
    clientMutationId: {
      applyPlan: CTypesMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    a: undefined,
    b: undefined,
    c: undefined,
    d: undefined,
    e: undefined,
    f: undefined
  },
  CMutationOutOutCompoundTypePayload: {
    __assertStep: ObjectStep,
    clientMutationId: CMutationOutOutCompoundTypePayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CMutationOutOutCompoundTypePayload_queryPlan
  },
  CMutationOutOutCompoundTypeRecord: {
    __assertStep: assertPgClassSingleStep,
    o1($record) {
      return $record.get("o1");
    },
    o2($record) {
      const $plan = $record.get("o2");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_cCompoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    }
  },
  CMutationOutOutCompoundTypeInput: {
    clientMutationId: {
      applyPlan: CMutationOutOutCompoundTypeInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    i1: undefined
  },
  BCompoundTypeMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: BCompoundTypeMutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: BCompoundTypeMutationPayload_queryPlan
  },
  BCompoundTypeMutationInput: {
    clientMutationId: {
      applyPlan: BCompoundTypeMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    object: undefined
  },
  BCompoundTypeSetMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: BCompoundTypeSetMutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: BCompoundTypeSetMutationPayload_queryPlan
  },
  BCompoundTypeSetMutationInput: {
    clientMutationId: {
      applyPlan: BCompoundTypeSetMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    object: undefined
  },
  CTableMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CTableMutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CTableMutationPayload_queryPlan,
    postEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques25[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_postPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PostOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CTableMutationInput: {
    clientMutationId: {
      applyPlan: CTableMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    id: undefined
  },
  PostWithSuffixPayload: {
    __assertStep: ObjectStep,
    clientMutationId: PostWithSuffixPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: PostWithSuffixPayload_queryPlan,
    postEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques25[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_postPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PostOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  PostWithSuffixInput: {
    clientMutationId: {
      applyPlan: PostWithSuffixInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    post: undefined,
    suffix: undefined
  },
  PostInput: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    headline: {
      applyPlan($insert, val) {
        $insert.set("headline", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    body: {
      applyPlan($insert, val) {
        $insert.set("body", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    authorId: {
      applyPlan($insert, val) {
        $insert.set("author_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    enums: {
      applyPlan($insert, val) {
        $insert.set("enums", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    comptypes: {
      applyPlan($insert, val) {
        $insert.set("comptypes", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ComptypeInput: {
    schedule: {
      applyPlan($insert, val) {
        $insert.set("schedule", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    isOptimised: {
      applyPlan($insert, val) {
        $insert.set("is_optimised", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MutationCompoundTypeArrayPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationCompoundTypeArrayPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: MutationCompoundTypeArrayPayload_queryPlan
  },
  MutationCompoundTypeArrayInput: {
    clientMutationId: {
      applyPlan: MutationCompoundTypeArrayInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    object: undefined
  },
  BCompoundTypeArrayMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: BCompoundTypeArrayMutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: BCompoundTypeArrayMutationPayload_queryPlan
  },
  BCompoundTypeArrayMutationInput: {
    clientMutationId: {
      applyPlan: BCompoundTypeArrayMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    object: undefined
  },
  PostManyPayload: {
    __assertStep: ObjectStep,
    clientMutationId: PostManyPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: PostManyPayload_queryPlan
  },
  PostManyInput: {
    clientMutationId: {
      applyPlan: PostManyInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    posts: undefined
  },
  CMutationOutComplexPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CMutationOutComplexPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CMutationOutComplexPayload_queryPlan
  },
  CMutationOutComplexRecord: {
    __assertStep: assertPgClassSingleStep,
    x($record) {
      return $record.get("x");
    },
    y($record) {
      const $plan = $record.get("y");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_cCompoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    z($record) {
      const $plan = $record.get("z");
      const $select = pgSelectSingleFromRecord(resource_c_personPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    }
  },
  CMutationOutComplexInput: {
    clientMutationId: {
      applyPlan: CMutationOutComplexInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    a: undefined,
    b: undefined
  },
  CMutationOutComplexSetofPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CMutationOutComplexSetofPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CMutationOutComplexSetofPayload_queryPlan
  },
  CMutationOutComplexSetofRecord: {
    __assertStep: assertPgClassSingleStep,
    x($record) {
      return $record.get("x");
    },
    y($record) {
      const $plan = $record.get("y");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_cCompoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    z($record) {
      const $plan = $record.get("z");
      const $select = pgSelectSingleFromRecord(resource_c_personPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    }
  },
  CMutationOutComplexSetofInput: {
    clientMutationId: {
      applyPlan: CMutationOutComplexSetofInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    a: undefined,
    b: undefined
  },
  CMutationOutTablePayload: {
    __assertStep: ObjectStep,
    clientMutationId: CMutationOutTablePayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CMutationOutTablePayload_queryPlan,
    cPersonEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques27[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_personPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CPersonOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CMutationOutTableInput: {
    clientMutationId: {
      applyPlan: CMutationOutTableInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CMutationOutTableSetofPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CMutationOutTableSetofPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CMutationOutTableSetofPayload_queryPlan
  },
  CMutationOutTableSetofInput: {
    clientMutationId: {
      applyPlan: CMutationOutTableSetofInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CTableSetMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CTableSetMutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: CTableSetMutationPayload_queryPlan
  },
  CTableSetMutationInput: {
    clientMutationId: {
      applyPlan: CTableSetMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  BTypeFunctionConnectionMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: BTypeFunctionConnectionMutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: BTypeFunctionConnectionMutationPayload_queryPlan
  },
  BTypeFunctionConnectionMutationInput: {
    clientMutationId: {
      applyPlan: BTypeFunctionConnectionMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  BTypeFunctionMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: BTypeFunctionMutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: BTypeFunctionMutationPayload_queryPlan,
    bTypeEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques28[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_b_typesPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("BTypeOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  BTypeFunctionMutationInput: {
    clientMutationId: {
      applyPlan: BTypeFunctionMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    id: undefined
  },
  BTypeFunctionListMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: BTypeFunctionListMutationPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: BTypeFunctionListMutationPayload_queryPlan
  },
  BTypeFunctionListMutationInput: {
    clientMutationId: {
      applyPlan: BTypeFunctionListMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateInputPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateInputPayload_clientMutationIdPlan,
    input: CreateInputPayload_inputPlan,
    query: CreateInputPayload_queryPlan,
    inputEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques2[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_inputsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("InputOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateInputInput: {
    clientMutationId: {
      applyPlan: CreateInputInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    input: {
      applyPlan: CreateInputInput_input_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  InputInput: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreatePatchPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreatePatchPayload_clientMutationIdPlan,
    patch: CreatePatchPayload_patchPlan,
    query: CreatePatchPayload_queryPlan,
    patchEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques3[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_patchsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PatchOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreatePatchInput: {
    clientMutationId: {
      applyPlan: CreatePatchInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    patch: {
      applyPlan: CreatePatchInput_patch_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  PatchInput: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateReservedPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateReservedPayload_clientMutationIdPlan,
    reserved: CreateReservedPayload_reservedPlan,
    query: CreateReservedPayload_queryPlan,
    reservedEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques4[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reservedPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateReservedInput: {
    clientMutationId: {
      applyPlan: CreateReservedInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    reserved: {
      applyPlan: CreateReservedInput_reserved_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ReservedInput: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateReservedPatchRecordPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateReservedPatchRecordPayload_clientMutationIdPlan,
    reservedPatchRecord: CreateReservedPatchRecordPayload_reservedPatchRecordPlan,
    query: CreateReservedPatchRecordPayload_queryPlan,
    reservedPatchRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques5[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reservedPatchsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedPatchRecordOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateReservedPatchRecordInput: {
    clientMutationId: {
      applyPlan: CreateReservedPatchRecordInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    reservedPatchRecord: {
      applyPlan: CreateReservedPatchRecordInput_reservedPatchRecord_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ReservedPatchRecordInput: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateReservedInputRecordPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateReservedInputRecordPayload_clientMutationIdPlan,
    reservedInputRecord: CreateReservedInputRecordPayload_reservedInputRecordPlan,
    query: CreateReservedInputRecordPayload_queryPlan,
    reservedInputRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques6[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reserved_inputPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedInputRecordOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateReservedInputRecordInput: {
    clientMutationId: {
      applyPlan: CreateReservedInputRecordInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    reservedInputRecord: {
      applyPlan: CreateReservedInputRecordInput_reservedInputRecord_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ReservedInputRecordInput: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateDefaultValuePayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateDefaultValuePayload_clientMutationIdPlan,
    defaultValue: CreateDefaultValuePayload_defaultValuePlan,
    query: CreateDefaultValuePayload_queryPlan,
    defaultValueEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques7[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_default_valuePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("DefaultValueOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateDefaultValueInput: {
    clientMutationId: {
      applyPlan: CreateDefaultValueInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    defaultValue: {
      applyPlan: CreateDefaultValueInput_defaultValue_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  DefaultValueInput: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullValue: {
      applyPlan($insert, val) {
        $insert.set("null_value", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateForeignKeyPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateForeignKeyPayload_clientMutationIdPlan,
    foreignKey: CreateForeignKeyPayload_foreignKeyPlan,
    query: CreateForeignKeyPayload_queryPlan
  },
  CreateForeignKeyInput: {
    clientMutationId: {
      applyPlan: CreateForeignKeyInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    foreignKey: {
      applyPlan: CreateForeignKeyInput_foreignKey_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ForeignKeyInput: {
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    compoundKey1: {
      applyPlan($insert, val) {
        $insert.set("compound_key_1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    compoundKey2: {
      applyPlan($insert, val) {
        $insert.set("compound_key_2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateNoPrimaryKeyPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateNoPrimaryKeyPayload_clientMutationIdPlan,
    noPrimaryKey: CreateNoPrimaryKeyPayload_noPrimaryKeyPlan,
    query: CreateNoPrimaryKeyPayload_queryPlan
  },
  CreateNoPrimaryKeyInput: {
    clientMutationId: {
      applyPlan: CreateNoPrimaryKeyInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    noPrimaryKey: {
      applyPlan: CreateNoPrimaryKeyInput_noPrimaryKey_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  NoPrimaryKeyInput: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    str: {
      applyPlan($insert, val) {
        $insert.set("str", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateTestviewPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateTestviewPayload_clientMutationIdPlan,
    testview: CreateTestviewPayload_testviewPlan,
    query: CreateTestviewPayload_queryPlan
  },
  CreateTestviewInput: {
    clientMutationId: {
      applyPlan: CreateTestviewInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    testview: {
      applyPlan: CreateTestviewInput_testview_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  TestviewInput: {
    testviewid: {
      applyPlan($insert, val) {
        $insert.set("testviewid", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col1: {
      applyPlan($insert, val) {
        $insert.set("col1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col2: {
      applyPlan($insert, val) {
        $insert.set("col2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateUniqueForeignKeyPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateUniqueForeignKeyPayload_clientMutationIdPlan,
    uniqueForeignKey: CreateUniqueForeignKeyPayload_uniqueForeignKeyPlan,
    query: CreateUniqueForeignKeyPayload_queryPlan
  },
  CreateUniqueForeignKeyInput: {
    clientMutationId: {
      applyPlan: CreateUniqueForeignKeyInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    uniqueForeignKey: {
      applyPlan: CreateUniqueForeignKeyInput_uniqueForeignKey_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UniqueForeignKeyInput: {
    compoundKey1: {
      applyPlan($insert, val) {
        $insert.set("compound_key_1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    compoundKey2: {
      applyPlan($insert, val) {
        $insert.set("compound_key_2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateCMyTablePayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateCMyTablePayload_clientMutationIdPlan,
    cMyTable: CreateCMyTablePayload_cMyTablePlan,
    query: CreateCMyTablePayload_queryPlan,
    cMyTableEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques12[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_my_tablePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CMyTableOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateCMyTableInput: {
    clientMutationId: {
      applyPlan: CreateCMyTableInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    cMyTable: {
      applyPlan: CreateCMyTableInput_cMyTable_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CMyTableInput: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    jsonData: {
      applyPlan($insert, val) {
        $insert.set("json_data", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateCPersonSecretPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateCPersonSecretPayload_clientMutationIdPlan,
    cPersonSecret: CreateCPersonSecretPayload_cPersonSecretPlan,
    query: CreateCPersonSecretPayload_queryPlan,
    cPersonSecretEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques13[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_person_secretPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CPersonSecretOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateCPersonSecretInput: {
    clientMutationId: {
      applyPlan: CreateCPersonSecretInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    cPersonSecret: {
      applyPlan: CreateCPersonSecretInput_cPersonSecret_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CPersonSecretInput: {
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    secret: {
      applyPlan($insert, val) {
        $insert.set("sekrit", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateViewTablePayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateViewTablePayload_clientMutationIdPlan,
    viewTable: CreateViewTablePayload_viewTablePlan,
    query: CreateViewTablePayload_queryPlan,
    viewTableEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques14[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_view_tablePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ViewTableOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateViewTableInput: {
    clientMutationId: {
      applyPlan: CreateViewTableInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    viewTable: {
      applyPlan: CreateViewTableInput_viewTable_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ViewTableInput: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col1: {
      applyPlan($insert, val) {
        $insert.set("col1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col2: {
      applyPlan($insert, val) {
        $insert.set("col2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateBUpdatableViewPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateBUpdatableViewPayload_clientMutationIdPlan,
    bUpdatableView: CreateBUpdatableViewPayload_bUpdatableViewPlan,
    query: CreateBUpdatableViewPayload_queryPlan
  },
  CreateBUpdatableViewInput: {
    clientMutationId: {
      applyPlan: CreateBUpdatableViewInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    bUpdatableView: {
      applyPlan: CreateBUpdatableViewInput_bUpdatableView_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  BUpdatableViewInput: {
    x: {
      applyPlan($insert, val) {
        $insert.set("x", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    description: {
      applyPlan($insert, val) {
        $insert.set("description", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    constant: {
      applyPlan($insert, val) {
        $insert.set("constant", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateCCompoundKeyPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateCCompoundKeyPayload_clientMutationIdPlan,
    cCompoundKey: CreateCCompoundKeyPayload_cCompoundKeyPlan,
    query: CreateCCompoundKeyPayload_queryPlan,
    cCompoundKeyEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques16[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_compound_keyPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CCompoundKeyOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateCCompoundKeyInput: {
    clientMutationId: {
      applyPlan: CreateCCompoundKeyInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    cCompoundKey: {
      applyPlan: CreateCCompoundKeyInput_cCompoundKey_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CCompoundKeyInput: {
    personId2: {
      applyPlan($insert, val) {
        $insert.set("person_id_2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId1: {
      applyPlan($insert, val) {
        $insert.set("person_id_1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    extra: {
      applyPlan($insert, val) {
        $insert.set("extra", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateSimilarTable1Payload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateSimilarTable1Payload_clientMutationIdPlan,
    similarTable1: CreateSimilarTable1Payload_similarTable1Plan,
    query: CreateSimilarTable1Payload_queryPlan,
    similarTable1Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques17[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_similar_table_1PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SimilarTable1OrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateSimilarTable1Input: {
    clientMutationId: {
      applyPlan: CreateSimilarTable1Input_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    similarTable1: {
      applyPlan: CreateSimilarTable1Input_similarTable1_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  SimilarTable1Input: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col1: {
      applyPlan($insert, val) {
        $insert.set("col1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col2: {
      applyPlan($insert, val) {
        $insert.set("col2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col3: {
      applyPlan($insert, val) {
        $insert.set("col3", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateSimilarTable2Payload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateSimilarTable2Payload_clientMutationIdPlan,
    similarTable2: CreateSimilarTable2Payload_similarTable2Plan,
    query: CreateSimilarTable2Payload_queryPlan,
    similarTable2Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques18[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_similar_table_2PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SimilarTable2OrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateSimilarTable2Input: {
    clientMutationId: {
      applyPlan: CreateSimilarTable2Input_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    similarTable2: {
      applyPlan: CreateSimilarTable2Input_similarTable2_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  SimilarTable2Input: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col3: {
      applyPlan($insert, val) {
        $insert.set("col3", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col4: {
      applyPlan($insert, val) {
        $insert.set("col4", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col5: {
      applyPlan($insert, val) {
        $insert.set("col5", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateCNullTestRecordPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateCNullTestRecordPayload_clientMutationIdPlan,
    cNullTestRecord: CreateCNullTestRecordPayload_cNullTestRecordPlan,
    query: CreateCNullTestRecordPayload_queryPlan,
    cNullTestRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques19[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_null_test_recordPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CNullTestRecordOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateCNullTestRecordInput: {
    clientMutationId: {
      applyPlan: CreateCNullTestRecordInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    cNullTestRecord: {
      applyPlan: CreateCNullTestRecordInput_cNullTestRecord_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CNullTestRecordInput: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableText: {
      applyPlan($insert, val) {
        $insert.set("nullable_text", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableInt: {
      applyPlan($insert, val) {
        $insert.set("nullable_int", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nonNullText: {
      applyPlan($insert, val) {
        $insert.set("non_null_text", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateCEdgeCasePayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateCEdgeCasePayload_clientMutationIdPlan,
    cEdgeCase: CreateCEdgeCasePayload_cEdgeCasePlan,
    query: CreateCEdgeCasePayload_queryPlan
  },
  CreateCEdgeCaseInput: {
    clientMutationId: {
      applyPlan: CreateCEdgeCaseInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    cEdgeCase: {
      applyPlan: CreateCEdgeCaseInput_cEdgeCase_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CEdgeCaseInput: {
    notNullHasDefault: {
      applyPlan($insert, val) {
        $insert.set("not_null_has_default", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    wontCastEasy: {
      applyPlan($insert, val) {
        $insert.set("wont_cast_easy", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("row_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateCLeftArmPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateCLeftArmPayload_clientMutationIdPlan,
    cLeftArm: CreateCLeftArmPayload_cLeftArmPlan,
    query: CreateCLeftArmPayload_queryPlan,
    cLeftArmEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques21[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_left_armPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CLeftArmOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateCLeftArmInput: {
    clientMutationId: {
      applyPlan: CreateCLeftArmInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    cLeftArm: {
      applyPlan: CreateCLeftArmInput_cLeftArm_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CLeftArmInput: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lengthInMetres: {
      applyPlan($insert, val) {
        $insert.set("length_in_metres", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    mood: {
      applyPlan($insert, val) {
        $insert.set("mood", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateCIssue756Payload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateCIssue756Payload_clientMutationIdPlan,
    cIssue756: CreateCIssue756Payload_cIssue756Plan,
    query: CreateCIssue756Payload_queryPlan,
    cIssue756Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques23[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_issue756PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CIssue756OrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateCIssue756Input: {
    clientMutationId: {
      applyPlan: CreateCIssue756Input_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    cIssue756: {
      applyPlan: CreateCIssue756Input_cIssue756_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CIssue756Input: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    ts: {
      applyPlan($insert, val) {
        $insert.set("ts", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreatePostPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreatePostPayload_clientMutationIdPlan,
    post: CreatePostPayload_postPlan,
    query: CreatePostPayload_queryPlan,
    postEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques25[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_postPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PostOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreatePostInput: {
    clientMutationId: {
      applyPlan: CreatePostInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    post: {
      applyPlan: CreatePostInput_post_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateCPersonPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateCPersonPayload_clientMutationIdPlan,
    cPerson: CreateCPersonPayload_cPersonPlan,
    query: CreateCPersonPayload_queryPlan,
    cPersonEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques27[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_personPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CPersonOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateCPersonInput: {
    clientMutationId: {
      applyPlan: CreateCPersonInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    cPerson: {
      applyPlan: CreateCPersonInput_cPerson_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CPersonInput: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("person_full_name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    aliases: {
      applyPlan($insert, val) {
        $insert.set("aliases", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    about: {
      applyPlan($insert, val) {
        $insert.set("about", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    email: {
      applyPlan($insert, val) {
        $insert.set("email", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    site: {
      applyPlan($insert, val) {
        $insert.set("site", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    config: {
      applyPlan($insert, val) {
        $insert.set("config", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastLoginFromIp: {
      applyPlan($insert, val) {
        $insert.set("last_login_from_ip", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastLoginFromSubnet: {
      applyPlan($insert, val) {
        $insert.set("last_login_from_subnet", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userMac: {
      applyPlan($insert, val) {
        $insert.set("user_mac", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  BWrappedUrlInput: {
    url: {
      applyPlan($insert, val) {
        $insert.set("url", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateBTypePayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateBTypePayload_clientMutationIdPlan,
    bType: CreateBTypePayload_bTypePlan,
    query: CreateBTypePayload_queryPlan,
    bTypeEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques28[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_b_typesPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("BTypeOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateBTypeInput: {
    clientMutationId: {
      applyPlan: CreateBTypeInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    bType: {
      applyPlan: CreateBTypeInput_bType_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  BTypeInput: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    smallint: {
      applyPlan($insert, val) {
        $insert.set("smallint", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    bigint: {
      applyPlan($insert, val) {
        $insert.set("bigint", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    numeric: {
      applyPlan($insert, val) {
        $insert.set("numeric", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    decimal: {
      applyPlan($insert, val) {
        $insert.set("decimal", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    boolean: {
      applyPlan($insert, val) {
        $insert.set("boolean", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    varchar: {
      applyPlan($insert, val) {
        $insert.set("varchar", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    enum: {
      applyPlan($insert, val) {
        $insert.set("enum", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    enumArray: {
      applyPlan($insert, val) {
        $insert.set("enum_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    domain: {
      applyPlan($insert, val) {
        $insert.set("domain", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    domain2: {
      applyPlan($insert, val) {
        $insert.set("domain2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    textArray: {
      applyPlan($insert, val) {
        $insert.set("text_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    json: {
      applyPlan($insert, val) {
        $insert.set("json", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    jsonb: {
      applyPlan($insert, val) {
        $insert.set("jsonb", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableRange: {
      applyPlan($insert, val) {
        $insert.set("nullable_range", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    numrange: {
      applyPlan($insert, val) {
        $insert.set("numrange", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    daterange: {
      applyPlan($insert, val) {
        $insert.set("daterange", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    anIntRange: {
      applyPlan($insert, val) {
        $insert.set("an_int_range", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timestamp: {
      applyPlan($insert, val) {
        $insert.set("timestamp", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timestamptz: {
      applyPlan($insert, val) {
        $insert.set("timestamptz", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    date: {
      applyPlan($insert, val) {
        $insert.set("date", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    time: {
      applyPlan($insert, val) {
        $insert.set("time", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timetz: {
      applyPlan($insert, val) {
        $insert.set("timetz", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    interval: {
      applyPlan($insert, val) {
        $insert.set("interval", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    intervalArray: {
      applyPlan($insert, val) {
        $insert.set("interval_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    money: {
      applyPlan($insert, val) {
        $insert.set("money", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    compoundType: {
      applyPlan($insert, val) {
        $insert.set("compound_type", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nestedCompoundType: {
      applyPlan($insert, val) {
        $insert.set("nested_compound_type", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableCompoundType: {
      applyPlan($insert, val) {
        $insert.set("nullable_compound_type", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableNestedCompoundType: {
      applyPlan($insert, val) {
        $insert.set("nullable_nested_compound_type", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    point: {
      applyPlan($insert, val) {
        $insert.set("point", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullablePoint: {
      applyPlan($insert, val) {
        $insert.set("nullablePoint", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    inet: {
      applyPlan($insert, val) {
        $insert.set("inet", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    cidr: {
      applyPlan($insert, val) {
        $insert.set("cidr", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    macaddr: {
      applyPlan($insert, val) {
        $insert.set("macaddr", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regproc: {
      applyPlan($insert, val) {
        $insert.set("regproc", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regprocedure: {
      applyPlan($insert, val) {
        $insert.set("regprocedure", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regoper: {
      applyPlan($insert, val) {
        $insert.set("regoper", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regoperator: {
      applyPlan($insert, val) {
        $insert.set("regoperator", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regclass: {
      applyPlan($insert, val) {
        $insert.set("regclass", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regtype: {
      applyPlan($insert, val) {
        $insert.set("regtype", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regconfig: {
      applyPlan($insert, val) {
        $insert.set("regconfig", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regdictionary: {
      applyPlan($insert, val) {
        $insert.set("regdictionary", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    textArrayDomain: {
      applyPlan($insert, val) {
        $insert.set("text_array_domain", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    int8ArrayDomain: {
      applyPlan($insert, val) {
        $insert.set("int8_array_domain", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    bytea: {
      applyPlan($insert, val) {
        $insert.set("bytea", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    byteaArray: {
      applyPlan($insert, val) {
        $insert.set("bytea_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    ltree: {
      applyPlan($insert, val) {
        $insert.set("ltree", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    ltreeArray: {
      applyPlan($insert, val) {
        $insert.set("ltree_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  BigFloatRangeInput: {
    start: undefined,
    end: undefined
  },
  BigFloatRangeBoundInput: {
    value: undefined,
    inclusive: undefined
  },
  DateRangeInput: {
    start: undefined,
    end: undefined
  },
  DateRangeBoundInput: {
    value: undefined,
    inclusive: undefined
  },
  AnIntRangeInput: {
    start: undefined,
    end: undefined
  },
  AnIntRangeBoundInput: {
    value: undefined,
    inclusive: undefined
  },
  BNestedCompoundTypeInput: {
    a: {
      applyPlan($insert, val) {
        $insert.set("a", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    b: {
      applyPlan($insert, val) {
        $insert.set("b", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    bazBuz: {
      applyPlan($insert, val) {
        $insert.set("baz_buz", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateInputPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateInputPayload_clientMutationIdPlan,
    input: UpdateInputPayload_inputPlan,
    query: UpdateInputPayload_queryPlan,
    inputEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques2[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_inputsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("InputOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateInputByRowIdInput: {
    clientMutationId: {
      applyPlan: UpdateInputByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined,
    inputPatch: {
      applyPlan: UpdateInputByRowIdInput_inputPatch_applyPlan
    }
  },
  InputPatch: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdatePatchPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdatePatchPayload_clientMutationIdPlan,
    patch: UpdatePatchPayload_patchPlan,
    query: UpdatePatchPayload_queryPlan,
    patchEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques3[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_patchsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PatchOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdatePatchByRowIdInput: {
    clientMutationId: {
      applyPlan: UpdatePatchByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined,
    patchPatch: {
      applyPlan: UpdatePatchByRowIdInput_patchPatch_applyPlan
    }
  },
  PatchPatch: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateReservedPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateReservedPayload_clientMutationIdPlan,
    reserved: UpdateReservedPayload_reservedPlan,
    query: UpdateReservedPayload_queryPlan,
    reservedEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques4[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reservedPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateReservedByRowIdInput: {
    clientMutationId: {
      applyPlan: UpdateReservedByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined,
    reservedPatch: {
      applyPlan: UpdateReservedByRowIdInput_reservedPatch_applyPlan
    }
  },
  ReservedPatch: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateReservedPatchRecordPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateReservedPatchRecordPayload_clientMutationIdPlan,
    reservedPatchRecord: UpdateReservedPatchRecordPayload_reservedPatchRecordPlan,
    query: UpdateReservedPatchRecordPayload_queryPlan,
    reservedPatchRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques5[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reservedPatchsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedPatchRecordOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateReservedPatchRecordByRowIdInput: {
    clientMutationId: {
      applyPlan: UpdateReservedPatchRecordByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined,
    reservedPatchRecordPatch: {
      applyPlan: UpdateReservedPatchRecordByRowIdInput_reservedPatchRecordPatch_applyPlan
    }
  },
  ReservedPatchRecordPatch: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateReservedInputRecordPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateReservedInputRecordPayload_clientMutationIdPlan,
    reservedInputRecord: UpdateReservedInputRecordPayload_reservedInputRecordPlan,
    query: UpdateReservedInputRecordPayload_queryPlan,
    reservedInputRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques6[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reserved_inputPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedInputRecordOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateReservedInputRecordByRowIdInput: {
    clientMutationId: {
      applyPlan: UpdateReservedInputRecordByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined,
    reservedInputRecordPatch: {
      applyPlan: UpdateReservedInputRecordByRowIdInput_reservedInputRecordPatch_applyPlan
    }
  },
  ReservedInputRecordPatch: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateDefaultValuePayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateDefaultValuePayload_clientMutationIdPlan,
    defaultValue: UpdateDefaultValuePayload_defaultValuePlan,
    query: UpdateDefaultValuePayload_queryPlan,
    defaultValueEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques7[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_default_valuePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("DefaultValueOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateDefaultValueByRowIdInput: {
    clientMutationId: {
      applyPlan: UpdateDefaultValueByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined,
    defaultValuePatch: {
      applyPlan: UpdateDefaultValueByRowIdInput_defaultValuePatch_applyPlan
    }
  },
  DefaultValuePatch: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullValue: {
      applyPlan($insert, val) {
        $insert.set("null_value", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateNoPrimaryKeyPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateNoPrimaryKeyPayload_clientMutationIdPlan,
    noPrimaryKey: UpdateNoPrimaryKeyPayload_noPrimaryKeyPlan,
    query: UpdateNoPrimaryKeyPayload_queryPlan
  },
  UpdateNoPrimaryKeyByRowIdInput: {
    clientMutationId: {
      applyPlan: UpdateNoPrimaryKeyByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined,
    noPrimaryKeyPatch: {
      applyPlan: UpdateNoPrimaryKeyByRowIdInput_noPrimaryKeyPatch_applyPlan
    }
  },
  NoPrimaryKeyPatch: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    str: {
      applyPlan($insert, val) {
        $insert.set("str", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateUniqueForeignKeyPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateUniqueForeignKeyPayload_clientMutationIdPlan,
    uniqueForeignKey: UpdateUniqueForeignKeyPayload_uniqueForeignKeyPlan,
    query: UpdateUniqueForeignKeyPayload_queryPlan
  },
  UpdateUniqueForeignKeyByCompoundKey1AndCompoundKey2Input: {
    clientMutationId: {
      applyPlan: UpdateUniqueForeignKeyByCompoundKey1AndCompoundKey2Input_clientMutationId_applyPlan
    },
    compoundKey1: undefined,
    compoundKey2: undefined,
    uniqueForeignKeyPatch: {
      applyPlan: UpdateUniqueForeignKeyByCompoundKey1AndCompoundKey2Input_uniqueForeignKeyPatch_applyPlan
    }
  },
  UniqueForeignKeyPatch: {
    compoundKey1: {
      applyPlan($insert, val) {
        $insert.set("compound_key_1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    compoundKey2: {
      applyPlan($insert, val) {
        $insert.set("compound_key_2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateCMyTablePayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateCMyTablePayload_clientMutationIdPlan,
    cMyTable: UpdateCMyTablePayload_cMyTablePlan,
    query: UpdateCMyTablePayload_queryPlan,
    cMyTableEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques12[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_my_tablePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CMyTableOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateCMyTableByRowIdInput: {
    clientMutationId: {
      applyPlan: UpdateCMyTableByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined,
    cMyTablePatch: {
      applyPlan: UpdateCMyTableByRowIdInput_cMyTablePatch_applyPlan
    }
  },
  CMyTablePatch: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    jsonData: {
      applyPlan($insert, val) {
        $insert.set("json_data", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateCPersonSecretPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateCPersonSecretPayload_clientMutationIdPlan,
    cPersonSecret: UpdateCPersonSecretPayload_cPersonSecretPlan,
    query: UpdateCPersonSecretPayload_queryPlan,
    cPersonSecretEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques13[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_person_secretPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CPersonSecretOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateCPersonSecretByPersonIdInput: {
    clientMutationId: {
      applyPlan: UpdateCPersonSecretByPersonIdInput_clientMutationId_applyPlan
    },
    personId: undefined,
    cPersonSecretPatch: {
      applyPlan: UpdateCPersonSecretByPersonIdInput_cPersonSecretPatch_applyPlan
    }
  },
  CPersonSecretPatch: {
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    secret: {
      applyPlan($insert, val) {
        $insert.set("sekrit", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateViewTablePayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateViewTablePayload_clientMutationIdPlan,
    viewTable: UpdateViewTablePayload_viewTablePlan,
    query: UpdateViewTablePayload_queryPlan,
    viewTableEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques14[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_view_tablePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ViewTableOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateViewTableByRowIdInput: {
    clientMutationId: {
      applyPlan: UpdateViewTableByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined,
    viewTablePatch: {
      applyPlan: UpdateViewTableByRowIdInput_viewTablePatch_applyPlan
    }
  },
  ViewTablePatch: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col1: {
      applyPlan($insert, val) {
        $insert.set("col1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col2: {
      applyPlan($insert, val) {
        $insert.set("col2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateCCompoundKeyPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateCCompoundKeyPayload_clientMutationIdPlan,
    cCompoundKey: UpdateCCompoundKeyPayload_cCompoundKeyPlan,
    query: UpdateCCompoundKeyPayload_queryPlan,
    cCompoundKeyEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques16[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_compound_keyPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CCompoundKeyOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateCCompoundKeyByPersonId1AndPersonId2Input: {
    clientMutationId: {
      applyPlan: UpdateCCompoundKeyByPersonId1AndPersonId2Input_clientMutationId_applyPlan
    },
    personId1: undefined,
    personId2: undefined,
    cCompoundKeyPatch: {
      applyPlan: UpdateCCompoundKeyByPersonId1AndPersonId2Input_cCompoundKeyPatch_applyPlan
    }
  },
  CCompoundKeyPatch: {
    personId2: {
      applyPlan($insert, val) {
        $insert.set("person_id_2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId1: {
      applyPlan($insert, val) {
        $insert.set("person_id_1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    extra: {
      applyPlan($insert, val) {
        $insert.set("extra", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateSimilarTable1Payload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateSimilarTable1Payload_clientMutationIdPlan,
    similarTable1: UpdateSimilarTable1Payload_similarTable1Plan,
    query: UpdateSimilarTable1Payload_queryPlan,
    similarTable1Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques17[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_similar_table_1PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SimilarTable1OrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateSimilarTable1ByRowIdInput: {
    clientMutationId: {
      applyPlan: UpdateSimilarTable1ByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined,
    similarTable1Patch: {
      applyPlan: UpdateSimilarTable1ByRowIdInput_similarTable1Patch_applyPlan
    }
  },
  SimilarTable1Patch: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col1: {
      applyPlan($insert, val) {
        $insert.set("col1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col2: {
      applyPlan($insert, val) {
        $insert.set("col2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col3: {
      applyPlan($insert, val) {
        $insert.set("col3", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateSimilarTable2Payload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateSimilarTable2Payload_clientMutationIdPlan,
    similarTable2: UpdateSimilarTable2Payload_similarTable2Plan,
    query: UpdateSimilarTable2Payload_queryPlan,
    similarTable2Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques18[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_similar_table_2PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SimilarTable2OrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateSimilarTable2ByRowIdInput: {
    clientMutationId: {
      applyPlan: UpdateSimilarTable2ByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined,
    similarTable2Patch: {
      applyPlan: UpdateSimilarTable2ByRowIdInput_similarTable2Patch_applyPlan
    }
  },
  SimilarTable2Patch: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col3: {
      applyPlan($insert, val) {
        $insert.set("col3", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col4: {
      applyPlan($insert, val) {
        $insert.set("col4", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col5: {
      applyPlan($insert, val) {
        $insert.set("col5", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateCNullTestRecordPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateCNullTestRecordPayload_clientMutationIdPlan,
    cNullTestRecord: UpdateCNullTestRecordPayload_cNullTestRecordPlan,
    query: UpdateCNullTestRecordPayload_queryPlan,
    cNullTestRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques19[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_null_test_recordPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CNullTestRecordOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateCNullTestRecordByRowIdInput: {
    clientMutationId: {
      applyPlan: UpdateCNullTestRecordByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined,
    cNullTestRecordPatch: {
      applyPlan: UpdateCNullTestRecordByRowIdInput_cNullTestRecordPatch_applyPlan
    }
  },
  CNullTestRecordPatch: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableText: {
      applyPlan($insert, val) {
        $insert.set("nullable_text", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableInt: {
      applyPlan($insert, val) {
        $insert.set("nullable_int", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nonNullText: {
      applyPlan($insert, val) {
        $insert.set("non_null_text", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateCLeftArmPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateCLeftArmPayload_clientMutationIdPlan,
    cLeftArm: UpdateCLeftArmPayload_cLeftArmPlan,
    query: UpdateCLeftArmPayload_queryPlan,
    cLeftArmEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques21[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_left_armPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CLeftArmOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateCLeftArmByRowIdInput: {
    clientMutationId: {
      applyPlan: UpdateCLeftArmByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined,
    cLeftArmPatch: {
      applyPlan: UpdateCLeftArmByRowIdInput_cLeftArmPatch_applyPlan
    }
  },
  CLeftArmPatch: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lengthInMetres: {
      applyPlan($insert, val) {
        $insert.set("length_in_metres", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    mood: {
      applyPlan($insert, val) {
        $insert.set("mood", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateCLeftArmByPersonIdInput: {
    clientMutationId: {
      applyPlan: UpdateCLeftArmByPersonIdInput_clientMutationId_applyPlan
    },
    personId: undefined,
    cLeftArmPatch: {
      applyPlan: UpdateCLeftArmByPersonIdInput_cLeftArmPatch_applyPlan
    }
  },
  UpdateCIssue756Payload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateCIssue756Payload_clientMutationIdPlan,
    cIssue756: UpdateCIssue756Payload_cIssue756Plan,
    query: UpdateCIssue756Payload_queryPlan,
    cIssue756Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques23[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_issue756PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CIssue756OrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateCIssue756ByRowIdInput: {
    clientMutationId: {
      applyPlan: UpdateCIssue756ByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined,
    cIssue756Patch: {
      applyPlan: UpdateCIssue756ByRowIdInput_cIssue756Patch_applyPlan
    }
  },
  CIssue756Patch: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    ts: {
      applyPlan($insert, val) {
        $insert.set("ts", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdatePostPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdatePostPayload_clientMutationIdPlan,
    post: UpdatePostPayload_postPlan,
    query: UpdatePostPayload_queryPlan,
    postEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques25[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_postPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PostOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdatePostByRowIdInput: {
    clientMutationId: {
      applyPlan: UpdatePostByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined,
    postPatch: {
      applyPlan: UpdatePostByRowIdInput_postPatch_applyPlan
    }
  },
  PostPatch: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    headline: {
      applyPlan($insert, val) {
        $insert.set("headline", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    body: {
      applyPlan($insert, val) {
        $insert.set("body", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    authorId: {
      applyPlan($insert, val) {
        $insert.set("author_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    enums: {
      applyPlan($insert, val) {
        $insert.set("enums", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    comptypes: {
      applyPlan($insert, val) {
        $insert.set("comptypes", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateCPersonPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateCPersonPayload_clientMutationIdPlan,
    cPerson: UpdateCPersonPayload_cPersonPlan,
    query: UpdateCPersonPayload_queryPlan,
    cPersonEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques27[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_personPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CPersonOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateCPersonByRowIdInput: {
    clientMutationId: {
      applyPlan: UpdateCPersonByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined,
    cPersonPatch: {
      applyPlan: UpdateCPersonByRowIdInput_cPersonPatch_applyPlan
    }
  },
  CPersonPatch: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("person_full_name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    aliases: {
      applyPlan($insert, val) {
        $insert.set("aliases", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    about: {
      applyPlan($insert, val) {
        $insert.set("about", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    email: {
      applyPlan($insert, val) {
        $insert.set("email", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    site: {
      applyPlan($insert, val) {
        $insert.set("site", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    config: {
      applyPlan($insert, val) {
        $insert.set("config", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastLoginFromIp: {
      applyPlan($insert, val) {
        $insert.set("last_login_from_ip", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastLoginFromSubnet: {
      applyPlan($insert, val) {
        $insert.set("last_login_from_subnet", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userMac: {
      applyPlan($insert, val) {
        $insert.set("user_mac", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateCPersonByEmailInput: {
    clientMutationId: {
      applyPlan: UpdateCPersonByEmailInput_clientMutationId_applyPlan
    },
    email: undefined,
    cPersonPatch: {
      applyPlan: UpdateCPersonByEmailInput_cPersonPatch_applyPlan
    }
  },
  UpdateBTypePayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateBTypePayload_clientMutationIdPlan,
    bType: UpdateBTypePayload_bTypePlan,
    query: UpdateBTypePayload_queryPlan,
    bTypeEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques28[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_b_typesPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("BTypeOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateBTypeByRowIdInput: {
    clientMutationId: {
      applyPlan: UpdateBTypeByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined,
    bTypePatch: {
      applyPlan: UpdateBTypeByRowIdInput_bTypePatch_applyPlan
    }
  },
  BTypePatch: {
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    smallint: {
      applyPlan($insert, val) {
        $insert.set("smallint", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    bigint: {
      applyPlan($insert, val) {
        $insert.set("bigint", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    numeric: {
      applyPlan($insert, val) {
        $insert.set("numeric", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    decimal: {
      applyPlan($insert, val) {
        $insert.set("decimal", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    boolean: {
      applyPlan($insert, val) {
        $insert.set("boolean", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    varchar: {
      applyPlan($insert, val) {
        $insert.set("varchar", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    enum: {
      applyPlan($insert, val) {
        $insert.set("enum", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    enumArray: {
      applyPlan($insert, val) {
        $insert.set("enum_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    domain: {
      applyPlan($insert, val) {
        $insert.set("domain", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    domain2: {
      applyPlan($insert, val) {
        $insert.set("domain2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    textArray: {
      applyPlan($insert, val) {
        $insert.set("text_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    json: {
      applyPlan($insert, val) {
        $insert.set("json", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    jsonb: {
      applyPlan($insert, val) {
        $insert.set("jsonb", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableRange: {
      applyPlan($insert, val) {
        $insert.set("nullable_range", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    numrange: {
      applyPlan($insert, val) {
        $insert.set("numrange", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    daterange: {
      applyPlan($insert, val) {
        $insert.set("daterange", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    anIntRange: {
      applyPlan($insert, val) {
        $insert.set("an_int_range", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timestamp: {
      applyPlan($insert, val) {
        $insert.set("timestamp", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timestamptz: {
      applyPlan($insert, val) {
        $insert.set("timestamptz", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    date: {
      applyPlan($insert, val) {
        $insert.set("date", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    time: {
      applyPlan($insert, val) {
        $insert.set("time", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timetz: {
      applyPlan($insert, val) {
        $insert.set("timetz", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    interval: {
      applyPlan($insert, val) {
        $insert.set("interval", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    intervalArray: {
      applyPlan($insert, val) {
        $insert.set("interval_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    money: {
      applyPlan($insert, val) {
        $insert.set("money", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    compoundType: {
      applyPlan($insert, val) {
        $insert.set("compound_type", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nestedCompoundType: {
      applyPlan($insert, val) {
        $insert.set("nested_compound_type", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableCompoundType: {
      applyPlan($insert, val) {
        $insert.set("nullable_compound_type", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableNestedCompoundType: {
      applyPlan($insert, val) {
        $insert.set("nullable_nested_compound_type", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    point: {
      applyPlan($insert, val) {
        $insert.set("point", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullablePoint: {
      applyPlan($insert, val) {
        $insert.set("nullablePoint", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    inet: {
      applyPlan($insert, val) {
        $insert.set("inet", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    cidr: {
      applyPlan($insert, val) {
        $insert.set("cidr", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    macaddr: {
      applyPlan($insert, val) {
        $insert.set("macaddr", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regproc: {
      applyPlan($insert, val) {
        $insert.set("regproc", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regprocedure: {
      applyPlan($insert, val) {
        $insert.set("regprocedure", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regoper: {
      applyPlan($insert, val) {
        $insert.set("regoper", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regoperator: {
      applyPlan($insert, val) {
        $insert.set("regoperator", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regclass: {
      applyPlan($insert, val) {
        $insert.set("regclass", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regtype: {
      applyPlan($insert, val) {
        $insert.set("regtype", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regconfig: {
      applyPlan($insert, val) {
        $insert.set("regconfig", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regdictionary: {
      applyPlan($insert, val) {
        $insert.set("regdictionary", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    textArrayDomain: {
      applyPlan($insert, val) {
        $insert.set("text_array_domain", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    int8ArrayDomain: {
      applyPlan($insert, val) {
        $insert.set("int8_array_domain", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    bytea: {
      applyPlan($insert, val) {
        $insert.set("bytea", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    byteaArray: {
      applyPlan($insert, val) {
        $insert.set("bytea_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    ltree: {
      applyPlan($insert, val) {
        $insert.set("ltree", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    ltreeArray: {
      applyPlan($insert, val) {
        $insert.set("ltree_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  DeleteInputPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteInputPayload_clientMutationIdPlan,
    input: DeleteInputPayload_inputPlan,
    query: DeleteInputPayload_queryPlan,
    inputEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques2[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_inputsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("InputOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteInputByRowIdInput: {
    clientMutationId: {
      applyPlan: DeleteInputByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined
  },
  DeletePatchPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeletePatchPayload_clientMutationIdPlan,
    patch: DeletePatchPayload_patchPlan,
    query: DeletePatchPayload_queryPlan,
    patchEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques3[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_patchsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PatchOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeletePatchByRowIdInput: {
    clientMutationId: {
      applyPlan: DeletePatchByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined
  },
  DeleteReservedPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteReservedPayload_clientMutationIdPlan,
    reserved: DeleteReservedPayload_reservedPlan,
    query: DeleteReservedPayload_queryPlan,
    reservedEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques4[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reservedPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteReservedByRowIdInput: {
    clientMutationId: {
      applyPlan: DeleteReservedByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined
  },
  DeleteReservedPatchRecordPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteReservedPatchRecordPayload_clientMutationIdPlan,
    reservedPatchRecord: DeleteReservedPatchRecordPayload_reservedPatchRecordPlan,
    query: DeleteReservedPatchRecordPayload_queryPlan,
    reservedPatchRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques5[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reservedPatchsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedPatchRecordOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteReservedPatchRecordByRowIdInput: {
    clientMutationId: {
      applyPlan: DeleteReservedPatchRecordByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined
  },
  DeleteReservedInputRecordPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteReservedInputRecordPayload_clientMutationIdPlan,
    reservedInputRecord: DeleteReservedInputRecordPayload_reservedInputRecordPlan,
    query: DeleteReservedInputRecordPayload_queryPlan,
    reservedInputRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques6[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reserved_inputPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedInputRecordOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteReservedInputRecordByRowIdInput: {
    clientMutationId: {
      applyPlan: DeleteReservedInputRecordByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined
  },
  DeleteDefaultValuePayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteDefaultValuePayload_clientMutationIdPlan,
    defaultValue: DeleteDefaultValuePayload_defaultValuePlan,
    query: DeleteDefaultValuePayload_queryPlan,
    defaultValueEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques7[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_default_valuePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("DefaultValueOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteDefaultValueByRowIdInput: {
    clientMutationId: {
      applyPlan: DeleteDefaultValueByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined
  },
  DeleteNoPrimaryKeyPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteNoPrimaryKeyPayload_clientMutationIdPlan,
    noPrimaryKey: DeleteNoPrimaryKeyPayload_noPrimaryKeyPlan,
    query: DeleteNoPrimaryKeyPayload_queryPlan
  },
  DeleteNoPrimaryKeyByRowIdInput: {
    clientMutationId: {
      applyPlan: DeleteNoPrimaryKeyByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined
  },
  DeleteUniqueForeignKeyPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteUniqueForeignKeyPayload_clientMutationIdPlan,
    uniqueForeignKey: DeleteUniqueForeignKeyPayload_uniqueForeignKeyPlan,
    query: DeleteUniqueForeignKeyPayload_queryPlan
  },
  DeleteUniqueForeignKeyByCompoundKey1AndCompoundKey2Input: {
    clientMutationId: {
      applyPlan: DeleteUniqueForeignKeyByCompoundKey1AndCompoundKey2Input_clientMutationId_applyPlan
    },
    compoundKey1: undefined,
    compoundKey2: undefined
  },
  DeleteCMyTablePayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteCMyTablePayload_clientMutationIdPlan,
    cMyTable: DeleteCMyTablePayload_cMyTablePlan,
    query: DeleteCMyTablePayload_queryPlan,
    cMyTableEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques12[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_my_tablePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CMyTableOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteCMyTableByRowIdInput: {
    clientMutationId: {
      applyPlan: DeleteCMyTableByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined
  },
  DeleteCPersonSecretPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteCPersonSecretPayload_clientMutationIdPlan,
    cPersonSecret: DeleteCPersonSecretPayload_cPersonSecretPlan,
    query: DeleteCPersonSecretPayload_queryPlan,
    cPersonSecretEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques13[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_person_secretPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CPersonSecretOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteCPersonSecretByPersonIdInput: {
    clientMutationId: {
      applyPlan: DeleteCPersonSecretByPersonIdInput_clientMutationId_applyPlan
    },
    personId: undefined
  },
  DeleteViewTablePayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteViewTablePayload_clientMutationIdPlan,
    viewTable: DeleteViewTablePayload_viewTablePlan,
    query: DeleteViewTablePayload_queryPlan,
    viewTableEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques14[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_view_tablePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ViewTableOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteViewTableByRowIdInput: {
    clientMutationId: {
      applyPlan: DeleteViewTableByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined
  },
  DeleteCCompoundKeyPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteCCompoundKeyPayload_clientMutationIdPlan,
    cCompoundKey: DeleteCCompoundKeyPayload_cCompoundKeyPlan,
    query: DeleteCCompoundKeyPayload_queryPlan,
    cCompoundKeyEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques16[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_compound_keyPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CCompoundKeyOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteCCompoundKeyByPersonId1AndPersonId2Input: {
    clientMutationId: {
      applyPlan: DeleteCCompoundKeyByPersonId1AndPersonId2Input_clientMutationId_applyPlan
    },
    personId1: undefined,
    personId2: undefined
  },
  DeleteSimilarTable1Payload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteSimilarTable1Payload_clientMutationIdPlan,
    similarTable1: DeleteSimilarTable1Payload_similarTable1Plan,
    query: DeleteSimilarTable1Payload_queryPlan,
    similarTable1Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques17[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_similar_table_1PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SimilarTable1OrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteSimilarTable1ByRowIdInput: {
    clientMutationId: {
      applyPlan: DeleteSimilarTable1ByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined
  },
  DeleteSimilarTable2Payload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteSimilarTable2Payload_clientMutationIdPlan,
    similarTable2: DeleteSimilarTable2Payload_similarTable2Plan,
    query: DeleteSimilarTable2Payload_queryPlan,
    similarTable2Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques18[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_similar_table_2PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SimilarTable2OrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteSimilarTable2ByRowIdInput: {
    clientMutationId: {
      applyPlan: DeleteSimilarTable2ByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined
  },
  DeleteCNullTestRecordPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteCNullTestRecordPayload_clientMutationIdPlan,
    cNullTestRecord: DeleteCNullTestRecordPayload_cNullTestRecordPlan,
    query: DeleteCNullTestRecordPayload_queryPlan,
    cNullTestRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques19[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_null_test_recordPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CNullTestRecordOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteCNullTestRecordByRowIdInput: {
    clientMutationId: {
      applyPlan: DeleteCNullTestRecordByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined
  },
  DeleteCLeftArmPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteCLeftArmPayload_clientMutationIdPlan,
    cLeftArm: DeleteCLeftArmPayload_cLeftArmPlan,
    query: DeleteCLeftArmPayload_queryPlan,
    cLeftArmEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques21[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_left_armPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CLeftArmOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteCLeftArmByRowIdInput: {
    clientMutationId: {
      applyPlan: DeleteCLeftArmByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined
  },
  DeleteCLeftArmByPersonIdInput: {
    clientMutationId: {
      applyPlan: DeleteCLeftArmByPersonIdInput_clientMutationId_applyPlan
    },
    personId: undefined
  },
  DeleteCIssue756Payload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteCIssue756Payload_clientMutationIdPlan,
    cIssue756: DeleteCIssue756Payload_cIssue756Plan,
    query: DeleteCIssue756Payload_queryPlan,
    cIssue756Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques23[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_issue756PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CIssue756OrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteCIssue756ByRowIdInput: {
    clientMutationId: {
      applyPlan: DeleteCIssue756ByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined
  },
  DeletePostPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeletePostPayload_clientMutationIdPlan,
    post: DeletePostPayload_postPlan,
    query: DeletePostPayload_queryPlan,
    postEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques25[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_postPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PostOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeletePostByRowIdInput: {
    clientMutationId: {
      applyPlan: DeletePostByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined
  },
  DeleteCPersonPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteCPersonPayload_clientMutationIdPlan,
    cPerson: DeleteCPersonPayload_cPersonPlan,
    query: DeleteCPersonPayload_queryPlan,
    cPersonEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques27[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_c_personPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CPersonOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteCPersonByRowIdInput: {
    clientMutationId: {
      applyPlan: DeleteCPersonByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined
  },
  DeleteCPersonByEmailInput: {
    clientMutationId: {
      applyPlan: DeleteCPersonByEmailInput_clientMutationId_applyPlan
    },
    email: undefined
  },
  DeleteBTypePayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteBTypePayload_clientMutationIdPlan,
    bType: DeleteBTypePayload_bTypePlan,
    query: DeleteBTypePayload_queryPlan,
    bTypeEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques28[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_b_typesPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("BTypeOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteBTypeByRowIdInput: {
    clientMutationId: {
      applyPlan: DeleteBTypeByRowIdInput_clientMutationId_applyPlan
    },
    rowId: undefined
  }
};
export const schema = makeGrafastSchema({
  typeDefs: typeDefs,
  plans: plans
});
